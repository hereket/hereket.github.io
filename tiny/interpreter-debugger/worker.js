// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.5.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error. The loadId argument is the deferred import that resulted in
//    this uri being loaded. The loadPriority argument is the priority the
//    library should be loaded with as specified in the code via the
//    load-priority annotation (0: normal, 1: high).
// dartDeferredLibraryMultiLoader(uris, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of every URI in `uris`,
//    and call successCallback. If it fails to do so, it should call
//    errorCallback with an error. The loadId argument is the deferred import
//    that resulted in this uri being loaded. The loadPriority argument is the
//    priority the library should be loaded with as specified in the code via
//    the load-priority annotation (0: normal, 1: high).
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  function mixinPropertiesHard(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!to.hasOwnProperty(key)) {
        to[key] = from[key];
      }
    }
  }
  function mixinPropertiesEasy(from, to) {
    Object.assign(to, from);
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(Object.getPrototypeOf(object) && Object.getPrototypeOf(object).p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        Object.setPrototypeOf(cls.prototype, sup.prototype);
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++) {
      inherit(classes[i], sup);
    }
  }
  function mixinEasy(cls, mixin) {
    mixinPropertiesEasy(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function mixinHard(cls, mixin) {
    mixinPropertiesHard(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        holder[name] = initializer();
      }
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function lazyFinal(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        var value = initializer();
        if (holder[name] !== uninitializedSentinel) {
          A.throwLateFieldADI(name);
        }
        holder[name] = value;
      }
      var finalValue = holder[name];
      holder[getterName] = function() {
        return finalValue;
      };
      return finalValue;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i) {
      convertToFastObject(arrayOfObjects[i]);
    }
  }
  var functionCounter = 0;
  function instanceTearOffGetter(isIntercepted, parameters) {
    var cache = null;
    return isIntercepted ? function(receiver) {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(receiver, this);
    } : function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(this, null);
    };
  }
  function staticTearOffGetter(parameters) {
    var cache = null;
    return function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters).prototype;
      return cache;
    };
  }
  var typesOffset = 0;
  function tearOffParameters(container, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    if (typeof funType == "number") {
      funType += typesOffset;
    }
    return {co: container, iS: isStatic, iI: isIntercepted, rC: requiredParameterCount, dV: optionalParameterDefaultValues, cs: callNames, fs: funsOrNames, fT: funType, aI: applyIndex || 0, nDA: needsDirectAccess};
  }
  function installStaticTearOff(holder, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var parameters = tearOffParameters(holder, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, false);
    var getterFunction = staticTearOffGetter(parameters);
    holder[getterName] = getterFunction;
  }
  function installInstanceTearOff(prototype, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    isIntercepted = !!isIntercepted;
    var parameters = tearOffParameters(prototype, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, !!needsDirectAccess);
    var getterFunction = instanceTearOffGetter(isIntercepted, parameters);
    prototype[getterName] = getterFunction;
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex, false);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixinEasy, mixinHard: mixinHard, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, lazyFinal: lazyFinal, updateHolder: updateHolder, convertToFastObject: convertToFastObject, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  var J = {
    makeDispatchRecord(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor(object) {
      var proto, objectProto, $constructor, interceptor, t1,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          A.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw A.wrapException(A.UnimplementedError$("Return interceptor for " + A.S(proto(object, record))));
      }
      $constructor = object.constructor;
      if ($constructor == null)
        interceptor = null;
      else {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        interceptor = $constructor[t1];
      }
      if (interceptor != null)
        return interceptor;
      interceptor = A.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return B.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return B.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return B.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        Object.defineProperty($constructor, t1, {value: B.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return B.UnknownJavaScriptObject_methods;
      }
      return B.UnknownJavaScriptObject_methods;
    },
    JSArray_markFixedList(list, $T) {
      list.fixed$length = Array;
      return list;
    },
    JSString__isWhitespace(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = string.charCodeAt(index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace(string, index) {
      var t1, index0, codeUnit;
      for (t1 = string.length; index > 0; index = index0) {
        index0 = index - 1;
        if (!(index0 < t1))
          return A.ioore(string, index0);
        codeUnit = string.charCodeAt(index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSNumNotInt.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ansx(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax(receiver) {
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    get$hashCode$(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$iterator$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$length$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$runtimeType$(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    $add$ansx(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ansx(receiver).$add(receiver, a0);
    },
    $eq$(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    add$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).add$1(receiver, a0);
    },
    toString$0$(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    LegacyJavaScriptObject: function LegacyJavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JavaScriptBigInt: function JavaScriptBigInt() {
    },
    JavaScriptSymbol: function JavaScriptSymbol() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _._length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSNumNotInt: function JSNumNotInt() {
    },
    JSString: function JSString() {
    }
  },
  A = {JS_CONST: function JS_CONST() {
    },
    LateError$localNI(localName) {
      return new A.LateError("Local '" + localName + "' has not been initialized.");
    },
    checkNotNullable(value, $name, $T) {
      return value;
    },
    isToStringVisiting(object) {
      var t1, i;
      for (t1 = $.toStringVisiting.length, i = 0; i < t1; ++i)
        if (object === $.toStringVisiting[i])
          return true;
      return false;
    },
    IterableElementError_noElement() {
      return new A.StateError("No element");
    },
    LateError: function LateError(t0) {
      this._message = t0;
    },
    nullFuture_closure: function nullFuture_closure() {
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_length = t1;
      _.__internal$_index = 0;
      _.__internal$_current = null;
      _.$ti = t2;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    isJsIndexable(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return type$.JavaScriptIndexingBehavior_dynamic._is(object);
    },
    S(value) {
      var result;
      if (typeof value == "string")
        return value;
      if (typeof value == "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      result = J.toString$0$(value);
      return result;
    },
    Primitives_objectHashCode(object) {
      var hash,
        property = $.Primitives__identityHashCodeProperty;
      if (property == null)
        property = $.Primitives__identityHashCodeProperty = Symbol("identityHashCode");
      hash = object[property];
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object[property] = hash;
      }
      return hash;
    },
    Primitives_parseDouble(source) {
      var result, trimmed;
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return null;
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = B.JSString_methods.trim$0(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return null;
      }
      return result;
    },
    Primitives_objectTypeName(object) {
      return A.Primitives__objectTypeNameNewRti(object);
    },
    Primitives__objectTypeNameNewRti(object) {
      var interceptor, dispatchName, $constructor, constructorName;
      if (object instanceof A.Object)
        return A._rtiToString(A.instanceType(object), null);
      interceptor = J.getInterceptor$(object);
      if (interceptor === B.Interceptor_methods || interceptor === B.JavaScriptObject_methods || type$.UnknownJavaScriptObject._is(object)) {
        dispatchName = B.C_JS_CONST(object);
        if (dispatchName !== "Object" && dispatchName !== "")
          return dispatchName;
        $constructor = object.constructor;
        if (typeof $constructor == "function") {
          constructorName = $constructor.name;
          if (typeof constructorName == "string" && constructorName !== "Object" && constructorName !== "")
            return constructorName;
        }
      }
      return A._rtiToString(A.instanceType(object), null);
    },
    Primitives_safeToString(object) {
      if (typeof object == "number" || A._isBool(object))
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      if (object instanceof A.Closure)
        return object.toString$0(0);
      return "Instance of '" + A.Primitives_objectTypeName(object) + "'";
    },
    Primitives_extractStackTrace(error) {
      var jsError = error.$thrownJsError;
      if (jsError == null)
        return null;
      return A.getTraceFromException(jsError);
    },
    iae(argument) {
      throw A.wrapException(A.argumentErrorValue(argument));
    },
    ioore(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw A.wrapException(A.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError(indexable, index) {
      var $length, _s5_ = "index";
      if (!A._isInt(index))
        return new A.ArgumentError(true, index, _s5_, null);
      $length = A._asInt(J.get$length$asx(indexable));
      if (index < 0 || index >= $length)
        return A.IndexError$withLength(index, $length, indexable, _s5_);
      return new A.RangeError(null, null, true, index, _s5_, "Value not in range");
    },
    argumentErrorValue(object) {
      return new A.ArgumentError(true, object, null, null);
    },
    wrapException(ex) {
      return A.initializeExceptionWrapper(new Error(), ex);
    },
    initializeExceptionWrapper(wrapper, ex) {
      var t1;
      if (ex == null)
        ex = new A.TypeError();
      wrapper.dartException = ex;
      t1 = A.toStringWrapper;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: t1});
        wrapper.name = "";
      } else
        wrapper.toString = t1;
      return wrapper;
    },
    toStringWrapper() {
      return J.toString$0$(this.dartException);
    },
    throwExpression(ex) {
      throw A.wrapException(ex);
    },
    throwExpressionWithWrapper(ex, wrapper) {
      throw A.initializeExceptionWrapper(wrapper, ex);
    },
    throwConcurrentModificationError(collection) {
      throw A.wrapException(A.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = A.quoteStringForRegExp(message.replace(String({}), "$receiver$"));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = A._setArrayType([], type$.JSArray_String);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new A.TypeErrorDecoder(message.replace(new RegExp("\\\\\\$arguments\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$argumentsExpr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$expr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$method\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$receiver\\\\\\$", "g"), "((?:x|[^x])*)"), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn(expression) {
      return function($expr$) {
        var $argumentsExpr$ = "$arguments$";
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    JsNoSuchMethodError$(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new A.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException(ex) {
      var t1;
      if (ex == null)
        return new A.NullThrownFromJavaScriptException(ex);
      if (ex instanceof A.ExceptionAndStackTrace) {
        t1 = ex.dartException;
        return A.saveStackTrace(ex, t1 == null ? type$.Object._as(t1) : t1);
      }
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return A.saveStackTrace(ex, ex.dartException);
      return A._unwrapNonDartException(ex);
    },
    saveStackTrace(ex, error) {
      if (type$.Error._is(error))
        if (error.$thrownJsError == null)
          error.$thrownJsError = ex;
      return error;
    },
    _unwrapNonDartException(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match;
      if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((B.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              A.S(message);
              return A.saveStackTrace(ex, new A.NullError());
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
          } else if (nullCall.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefCall.matchTypeError$1(message) != null || undefLiteralCall.matchTypeError$1(message) != null || nullProperty.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefProperty.matchTypeError$1(message) != null || undefLiteralProperty.matchTypeError$1(message) != null) {
            A._asString(message);
            return A.saveStackTrace(ex, new A.NullError());
          }
        }
        return A.saveStackTrace(ex, new A.UnknownJsTypeError(typeof message == "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message == "string" && message.indexOf("call stack") !== -1)
          return new A.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return A.saveStackTrace(ex, new A.ArgumentError(false, null, null, typeof message == "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message == "string" && message === "too much recursion")
          return new A.StackOverflowError();
      return ex;
    },
    getTraceFromException(exception) {
      var trace;
      if (exception instanceof A.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new A._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      trace = new A._StackTrace(exception);
      if (typeof exception === "object")
        exception.$cachedTrace = trace;
      return trace;
    },
    objectHashCode(object) {
      if (object == null)
        return J.get$hashCode$(object);
      if (typeof object == "object")
        return A.Primitives_objectHashCode(object);
      return J.get$hashCode$(object);
    },
    fillLiteralMap(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    _invokeClosure(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      type$.Function._as(closure);
      switch (A._asInt(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw A.wrapException(A.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS(closure, arity) {
      var $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = A.convertDartClosureToJSUncached(closure, arity);
      closure.$identity = $function;
      return $function;
    },
    convertDartClosureToJSUncached(closure, arity) {
      var entry;
      switch (arity) {
        case 0:
          entry = closure.call$0;
          break;
        case 1:
          entry = closure.call$1;
          break;
        case 2:
          entry = closure.call$2;
          break;
        case 3:
          entry = closure.call$3;
          break;
        case 4:
          entry = closure.call$4;
          break;
        default:
          entry = null;
      }
      if (entry != null)
        return entry.bind(closure);
      return function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, A._invokeClosure);
    },
    Closure_fromTearOff(parameters) {
      var $prototype, $constructor, t2, trampoline, applyTrampoline, i, stub, stub0, stubName, stubCallName,
        container = parameters.co,
        isStatic = parameters.iS,
        isIntercepted = parameters.iI,
        needsDirectAccess = parameters.nDA,
        applyTrampolineIndex = parameters.aI,
        funsOrNames = parameters.fs,
        callNames = parameters.cs,
        $name = funsOrNames[0],
        callName = callNames[0],
        $function = container[$name],
        t1 = parameters.fT;
      t1.toString;
      $prototype = isStatic ? Object.create(new A.StaticClosure().constructor.prototype) : Object.create(new A.BoundClosure(null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      $constructor = isStatic ? function static_tear_off() {
        this.$initialize();
      } : function tear_off(a, b) {
        this.$initialize(a, b);
      };
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      $prototype.$_name = $name;
      $prototype.$_target = $function;
      t2 = !isStatic;
      if (t2)
        trampoline = A.Closure_forwardCallTo($name, $function, isIntercepted, needsDirectAccess);
      else {
        $prototype.$static_name = $name;
        trampoline = $function;
      }
      $prototype.$signature = A.Closure__computeSignatureFunctionNewRti(t1, isStatic, isIntercepted);
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < funsOrNames.length; ++i) {
        stub = funsOrNames[i];
        if (typeof stub == "string") {
          stub0 = container[stub];
          stubName = stub;
          stub = stub0;
        } else
          stubName = "";
        stubCallName = callNames[i];
        if (stubCallName != null) {
          if (t2)
            stub = A.Closure_forwardCallTo(stubName, stub, isIntercepted, needsDirectAccess);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex)
          applyTrampoline = stub;
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = parameters.rC;
      $prototype.$defaultValues = parameters.dV;
      return $constructor;
    },
    Closure__computeSignatureFunctionNewRti(functionType, isStatic, isIntercepted) {
      if (typeof functionType == "number")
        return functionType;
      if (typeof functionType == "string") {
        if (isStatic)
          throw A.wrapException("Cannot compute signature for static tearoff.");
        return function(recipe, evalOnReceiver) {
          return function() {
            return evalOnReceiver(this, recipe);
          };
        }(functionType, A.BoundClosure_evalRecipe);
      }
      throw A.wrapException("Error in functionType of tearoff");
    },
    Closure_cspForwardCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          return function(entry, receiverOf) {
            return function() {
              return receiverOf(this)[entry]();
            };
          }(stubName, getReceiver);
        case 1:
          return function(entry, receiverOf) {
            return function(a) {
              return receiverOf(this)[entry](a);
            };
          }(stubName, getReceiver);
        case 2:
          return function(entry, receiverOf) {
            return function(a, b) {
              return receiverOf(this)[entry](a, b);
            };
          }(stubName, getReceiver);
        case 3:
          return function(entry, receiverOf) {
            return function(a, b, c) {
              return receiverOf(this)[entry](a, b, c);
            };
          }(stubName, getReceiver);
        case 4:
          return function(entry, receiverOf) {
            return function(a, b, c, d) {
              return receiverOf(this)[entry](a, b, c, d);
            };
          }(stubName, getReceiver);
        case 5:
          return function(entry, receiverOf) {
            return function(a, b, c, d, e) {
              return receiverOf(this)[entry](a, b, c, d, e);
            };
          }(stubName, getReceiver);
        default:
          return function(f, receiverOf) {
            return function() {
              return f.apply(receiverOf(this), arguments);
            };
          }($function, getReceiver);
      }
    },
    Closure_forwardCallTo(stubName, $function, isIntercepted, needsDirectAccess) {
      if (isIntercepted)
        return A.Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess);
      return A.Closure_cspForwardCall($function.length, needsDirectAccess, stubName, $function);
    },
    Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf,
        getInterceptor = A.BoundClosure_interceptorOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          throw A.wrapException(new A.RuntimeError("Intercepted function with no arguments."));
        case 1:
          return function(entry, interceptorOf, receiverOf) {
            return function() {
              return interceptorOf(this)[entry](receiverOf(this));
            };
          }(stubName, getInterceptor, getReceiver);
        case 2:
          return function(entry, interceptorOf, receiverOf) {
            return function(a) {
              return interceptorOf(this)[entry](receiverOf(this), a);
            };
          }(stubName, getInterceptor, getReceiver);
        case 3:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b) {
              return interceptorOf(this)[entry](receiverOf(this), a, b);
            };
          }(stubName, getInterceptor, getReceiver);
        case 4:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c);
            };
          }(stubName, getInterceptor, getReceiver);
        case 5:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d);
            };
          }(stubName, getInterceptor, getReceiver);
        case 6:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d, e) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d, e);
            };
          }(stubName, getInterceptor, getReceiver);
        default:
          return function(f, interceptorOf, receiverOf) {
            return function() {
              var a = [receiverOf(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(interceptorOf(this), a);
            };
          }($function, getInterceptor, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess) {
      var arity, t1;
      if ($.BoundClosure__interceptorFieldNameCache == null)
        $.BoundClosure__interceptorFieldNameCache = A.BoundClosure__computeFieldNamed("interceptor");
      if ($.BoundClosure__receiverFieldNameCache == null)
        $.BoundClosure__receiverFieldNameCache = A.BoundClosure__computeFieldNamed("receiver");
      arity = $function.length;
      t1 = A.Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function);
      return t1;
    },
    closureFromTearOff(parameters) {
      return A.Closure_fromTearOff(parameters);
    },
    BoundClosure_evalRecipe(closure, recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, A.instanceType(closure._receiver), recipe);
    },
    BoundClosure_receiverOf(closure) {
      return closure._receiver;
    },
    BoundClosure_interceptorOf(closure) {
      return closure._interceptor;
    },
    BoundClosure__computeFieldNamed(fieldName) {
      var t1, i, $name,
        template = new A.BoundClosure("receiver", "interceptor"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template), type$.nullable_Object);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
      throw A.wrapException(A.ArgumentError$("Field name " + fieldName + " not found.", null));
    },
    boolConversionCheck(value) {
      if (value == null)
        A.assertThrow("boolean expression must not be null");
      return value;
    },
    assertThrow(message) {
      throw A.wrapException(new A._AssertionError(message));
    },
    throwCyclicInit(staticName) {
      throw A.wrapException(new A._CyclicInitializationError(staticName));
    },
    getIsolateAffinityTag($name) {
      return init.getIsolateTag($name);
    },
    lookupAndCacheInterceptor(obj) {
      var interceptor, interceptorClass, altTag, mark, t1,
        tag = A._asString($.getTagFunction.call$1(obj)),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        altTag = A._asStringQ($.alternateTagFunction.call$2(obj, tag));
        if (altTag != null) {
          record = $.dispatchRecordsForInstanceTags[altTag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[altTag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[altTag];
          tag = altTag;
        }
      }
      if (interceptorClass == null)
        return null;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = A.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return A.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw A.wrapException(A.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return A.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return A.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      A.initNativeDispatchContinue();
    },
    initNativeDispatchContinue() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      A.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = A.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = B.C_JS_CONST0();
      hooks = A.applyHooksTransformer(B.C_JS_CONST1, A.applyHooksTransformer(B.C_JS_CONST2, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST4, A.applyHooksTransformer(B.C_JS_CONST5, A.applyHooksTransformer(B.C_JS_CONST6(B.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (Array.isArray(transformers))
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new A.initHooks_closure(getTag);
      $.alternateTagFunction = new A.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new A.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    createRecordTypePredicate(shape, fieldRtis) {
      var $length = fieldRtis.length,
        $function = init.rttc["" + $length + ";" + shape];
      if ($function == null)
        return null;
      if ($length === 0)
        return $function;
      if ($length === $function.length)
        return $function.apply(null, fieldRtis);
      return $function(fieldRtis);
    },
    quoteStringForRegExp(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError() {
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this.__js_helper$_message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this.__js_helper$_message = t0;
    },
    NullThrownFromJavaScriptException: function NullThrownFromJavaScriptException(t0) {
      this._irritant = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    _StackTrace: function _StackTrace(t0) {
      this._exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    Closure0Args: function Closure0Args() {
    },
    Closure2Args: function Closure2Args() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1) {
      this._receiver = t0;
      this._interceptor = t1;
    },
    _CyclicInitializationError: function _CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      this.hashMapCellKey = t0;
      this.hashMapCellValue = t1;
      this._next = null;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    throwLateFieldNI(fieldName) {
      A.throwExpressionWithWrapper(new A.LateError("Field '" + fieldName + "' has not been initialized."), new Error());
    },
    throwLateFieldADI(fieldName) {
      A.throwExpressionWithWrapper(new A.LateError("Field '" + fieldName + "' has been assigned during initialization."), new Error());
    },
    _Cell$named(_name) {
      var t1 = new A._Cell(_name);
      return t1._value = t1;
    },
    _Cell: function _Cell(t0) {
      this.__late_helper$_name = t0;
      this._value = null;
    },
    _checkValidIndex(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw A.wrapException(A.diagnoseIndexError(list, index));
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    Rti__getQuestionFromStar(universe, rti) {
      var question = rti._precomputed1;
      return question == null ? rti._precomputed1 = A._Universe__lookupQuestionRti(universe, rti._primary, true) : question;
    },
    Rti__getFutureFromFutureOr(universe, rti) {
      var future = rti._precomputed1;
      return future == null ? rti._precomputed1 = A._Universe__lookupInterfaceRti(universe, "Future", [rti._primary]) : future;
    },
    Rti__isUnionOfFunctionType(rti) {
      var kind = rti._kind;
      if (kind === 6 || kind === 7 || kind === 8)
        return A.Rti__isUnionOfFunctionType(rti._primary);
      return kind === 12 || kind === 13;
    },
    Rti__getCanonicalRecipe(rti) {
      return rti._canonicalRecipe;
    },
    findType(recipe) {
      return A._Universe_eval(init.typeUniverse, recipe, false);
    },
    _substitute(universe, rti, typeArguments, depth) {
      var baseType, substitutedBaseType, interfaceTypeArguments, substitutedInterfaceTypeArguments, base, substitutedBase, $arguments, substitutedArguments, t1, fields, substitutedFields, returnType, substitutedReturnType, functionParameters, substitutedFunctionParameters, bounds, substitutedBounds, index, argument,
        kind = rti._kind;
      switch (kind) {
        case 5:
        case 1:
        case 2:
        case 3:
        case 4:
          return rti;
        case 6:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupStarRti(universe, substitutedBaseType, true);
        case 7:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupQuestionRti(universe, substitutedBaseType, true);
        case 8:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupFutureOrRti(universe, substitutedBaseType, true);
        case 9:
          interfaceTypeArguments = rti._rest;
          substitutedInterfaceTypeArguments = A._substituteArray(universe, interfaceTypeArguments, typeArguments, depth);
          if (substitutedInterfaceTypeArguments === interfaceTypeArguments)
            return rti;
          return A._Universe__lookupInterfaceRti(universe, rti._primary, substitutedInterfaceTypeArguments);
        case 10:
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          $arguments = rti._rest;
          substitutedArguments = A._substituteArray(universe, $arguments, typeArguments, depth);
          if (substitutedBase === base && substitutedArguments === $arguments)
            return rti;
          return A._Universe__lookupBindingRti(universe, substitutedBase, substitutedArguments);
        case 11:
          t1 = rti._primary;
          fields = rti._rest;
          substitutedFields = A._substituteArray(universe, fields, typeArguments, depth);
          if (substitutedFields === fields)
            return rti;
          return A._Universe__lookupRecordRti(universe, t1, substitutedFields);
        case 12:
          returnType = rti._primary;
          substitutedReturnType = A._substitute(universe, returnType, typeArguments, depth);
          functionParameters = rti._rest;
          substitutedFunctionParameters = A._substituteFunctionParameters(universe, functionParameters, typeArguments, depth);
          if (substitutedReturnType === returnType && substitutedFunctionParameters === functionParameters)
            return rti;
          return A._Universe__lookupFunctionRti(universe, substitutedReturnType, substitutedFunctionParameters);
        case 13:
          bounds = rti._rest;
          depth += bounds.length;
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, depth);
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          if (substitutedBounds === bounds && substitutedBase === base)
            return rti;
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, true);
        case 14:
          index = rti._primary;
          if (index < depth)
            return rti;
          argument = typeArguments[index - depth];
          if (argument == null)
            return rti;
          return argument;
        default:
          throw A.wrapException(A.AssertionError$("Attempted to substitute unexpected RTI kind " + kind));
      }
    },
    _substituteArray(universe, rtiArray, typeArguments, depth) {
      var changed, i, rti, substitutedRti,
        $length = rtiArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; ++i) {
        rti = rtiArray[i];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result[i] = substitutedRti;
      }
      return changed ? result : rtiArray;
    },
    _substituteNamed(universe, namedArray, typeArguments, depth) {
      var changed, i, t1, t2, rti, substitutedRti,
        $length = namedArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; i += 3) {
        t1 = namedArray[i];
        t2 = namedArray[i + 1];
        rti = namedArray[i + 2];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result.splice(i, 3, t1, t2, substitutedRti);
      }
      return changed ? result : namedArray;
    },
    _substituteFunctionParameters(universe, functionParameters, typeArguments, depth) {
      var result,
        requiredPositional = functionParameters._requiredPositional,
        substitutedRequiredPositional = A._substituteArray(universe, requiredPositional, typeArguments, depth),
        optionalPositional = functionParameters._optionalPositional,
        substitutedOptionalPositional = A._substituteArray(universe, optionalPositional, typeArguments, depth),
        named = functionParameters._named,
        substitutedNamed = A._substituteNamed(universe, named, typeArguments, depth);
      if (substitutedRequiredPositional === requiredPositional && substitutedOptionalPositional === optionalPositional && substitutedNamed === named)
        return functionParameters;
      result = new A._FunctionParameters();
      result._requiredPositional = substitutedRequiredPositional;
      result._optionalPositional = substitutedOptionalPositional;
      result._named = substitutedNamed;
      return result;
    },
    _setArrayType(target, rti) {
      target[init.arrayRti] = rti;
      return target;
    },
    closureFunctionType(closure) {
      var signature = closure.$signature;
      if (signature != null) {
        if (typeof signature == "number")
          return A.getTypeFromTypesTable(signature);
        return closure.$signature();
      }
      return null;
    },
    instanceOrFunctionType(object, testRti) {
      var rti;
      if (A.Rti__isUnionOfFunctionType(testRti))
        if (object instanceof A.Closure) {
          rti = A.closureFunctionType(object);
          if (rti != null)
            return rti;
        }
      return A.instanceType(object);
    },
    instanceType(object) {
      if (object instanceof A.Object)
        return A._instanceType(object);
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A._instanceTypeFromConstructor(J.getInterceptor$(object));
    },
    _arrayInstanceType(object) {
      var rti = object[init.arrayRti],
        defaultRti = type$.JSArray_dynamic;
      if (rti == null)
        return defaultRti;
      if (rti.constructor !== defaultRti.constructor)
        return defaultRti;
      return rti;
    },
    _instanceType(object) {
      var rti = object.$ti;
      return rti != null ? rti : A._instanceTypeFromConstructor(object);
    },
    _instanceTypeFromConstructor(instance) {
      var $constructor = instance.constructor,
        probe = $constructor.$ccache;
      if (probe != null)
        return probe;
      return A._instanceTypeFromConstructorMiss(instance, $constructor);
    },
    _instanceTypeFromConstructorMiss(instance, $constructor) {
      var effectiveConstructor = instance instanceof A.Closure ? Object.getPrototypeOf(Object.getPrototypeOf(instance)).constructor : $constructor,
        rti = A._Universe_findErasedType(init.typeUniverse, effectiveConstructor.name);
      $constructor.$ccache = rti;
      return rti;
    },
    getTypeFromTypesTable(index) {
      var rti,
        table = init.types,
        type = table[index];
      if (typeof type == "string") {
        rti = A._Universe_eval(init.typeUniverse, type, false);
        table[index] = rti;
        return rti;
      }
      return type;
    },
    getRuntimeTypeOfDartObject(object) {
      return A.createRuntimeType(A._instanceType(object));
    },
    _structuralTypeOf(object) {
      var functionRti = object instanceof A.Closure ? A.closureFunctionType(object) : null;
      if (functionRti != null)
        return functionRti;
      if (type$.TrustedGetRuntimeType._is(object))
        return J.get$runtimeType$(object)._rti;
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A.instanceType(object);
    },
    createRuntimeType(rti) {
      var t1 = rti._cachedRuntimeType;
      return t1 == null ? rti._cachedRuntimeType = A._createRuntimeType(rti) : t1;
    },
    _createRuntimeType(rti) {
      var starErasedRti, t1,
        s = rti._canonicalRecipe,
        starErasedRecipe = s.replace(/\*/g, "");
      if (starErasedRecipe === s)
        return rti._cachedRuntimeType = new A._Type(rti);
      starErasedRti = A._Universe_eval(init.typeUniverse, starErasedRecipe, true);
      t1 = starErasedRti._cachedRuntimeType;
      return t1 == null ? starErasedRti._cachedRuntimeType = A._createRuntimeType(starErasedRti) : t1;
    },
    typeLiteral(recipe) {
      return A.createRuntimeType(A._Universe_eval(init.typeUniverse, recipe, false));
    },
    _installSpecializedIsTest(object) {
      var t1, unstarred, unstarredKind, isFn, $name, predicate, testRti = this;
      if (testRti === type$.Object)
        return A._finishIsFn(testRti, object, A._isObject);
      if (!A.isSoundTopType(testRti))
        t1 = testRti === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        return A._finishIsFn(testRti, object, A._isTop);
      t1 = testRti._kind;
      if (t1 === 7)
        return A._finishIsFn(testRti, object, A._generalNullableIsTestImplementation);
      if (t1 === 1)
        return A._finishIsFn(testRti, object, A._isNever);
      unstarred = t1 === 6 ? testRti._primary : testRti;
      unstarredKind = unstarred._kind;
      if (unstarredKind === 8)
        return A._finishIsFn(testRti, object, A._isFutureOr);
      if (unstarred === type$.int)
        isFn = A._isInt;
      else if (unstarred === type$.double || unstarred === type$.num)
        isFn = A._isNum;
      else if (unstarred === type$.String)
        isFn = A._isString;
      else
        isFn = unstarred === type$.bool ? A._isBool : null;
      if (isFn != null)
        return A._finishIsFn(testRti, object, isFn);
      if (unstarredKind === 9) {
        $name = unstarred._primary;
        if (unstarred._rest.every(A.isDefinitelyTopType)) {
          testRti._specializedTestResource = "$is" + $name;
          if ($name === "List")
            return A._finishIsFn(testRti, object, A._isListTestViaProperty);
          return A._finishIsFn(testRti, object, A._isTestViaProperty);
        }
      } else if (unstarredKind === 11) {
        predicate = A.createRecordTypePredicate(unstarred._primary, unstarred._rest);
        return A._finishIsFn(testRti, object, predicate == null ? A._isNever : predicate);
      }
      return A._finishIsFn(testRti, object, A._generalIsTestImplementation);
    },
    _finishIsFn(testRti, object, isFn) {
      testRti._is = isFn;
      return testRti._is(object);
    },
    _installSpecializedAsCheck(object) {
      var t1, testRti = this,
        asFn = A._generalAsCheckImplementation;
      if (!A.isSoundTopType(testRti))
        t1 = testRti === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        asFn = A._asTop;
      else if (testRti === type$.Object)
        asFn = A._asObject;
      else {
        t1 = A.isNullable(testRti);
        if (t1)
          asFn = A._generalNullableAsCheckImplementation;
      }
      testRti._as = asFn;
      return testRti._as(object);
    },
    _nullIs(testRti) {
      var kind = testRti._kind,
        t1 = true;
      if (!A.isSoundTopType(testRti))
        if (!(testRti === type$.legacy_Object))
          if (!(testRti === type$.legacy_Never))
            if (kind !== 7)
              if (!(kind === 6 && A._nullIs(testRti._primary)))
                t1 = kind === 8 && A._nullIs(testRti._primary) || testRti === type$.Null || testRti === type$.JSNull;
      return t1;
    },
    _generalIsTestImplementation(object) {
      var testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      return A.isSubtype(init.typeUniverse, A.instanceOrFunctionType(object, testRti), testRti);
    },
    _generalNullableIsTestImplementation(object) {
      if (object == null)
        return true;
      return this._primary._is(object);
    },
    _isTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _isListTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      if (typeof object != "object")
        return false;
      if (Array.isArray(object))
        return true;
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _generalAsCheckImplementation(object) {
      var testRti = this;
      if (object == null) {
        if (A.isNullable(testRti))
          return object;
      } else if (testRti._is(object))
        return object;
      A._failedAsCheck(object, testRti);
    },
    _generalNullableAsCheckImplementation(object) {
      var testRti = this;
      if (object == null)
        return object;
      else if (testRti._is(object))
        return object;
      A._failedAsCheck(object, testRti);
    },
    _failedAsCheck(object, testRti) {
      throw A.wrapException(A._TypeError$fromMessage(A._Error_compose(object, A._rtiToString(testRti, null))));
    },
    _Error_compose(object, checkedTypeDescription) {
      return A.Error_safeToString(object) + ": type '" + A._rtiToString(A._structuralTypeOf(object), null) + "' is not a subtype of type '" + checkedTypeDescription + "'";
    },
    _TypeError$fromMessage(message) {
      return new A._TypeError("TypeError: " + message);
    },
    _TypeError__TypeError$forType(object, type) {
      return new A._TypeError("TypeError: " + A._Error_compose(object, type));
    },
    _isFutureOr(object) {
      var testRti = this,
        unstarred = testRti._kind === 6 ? testRti._primary : testRti;
      return unstarred._primary._is(object) || A.Rti__getFutureFromFutureOr(init.typeUniverse, unstarred)._is(object);
    },
    _isObject(object) {
      return object != null;
    },
    _asObject(object) {
      if (object != null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "Object"));
    },
    _isTop(object) {
      return true;
    },
    _asTop(object) {
      return object;
    },
    _isNever(object) {
      return false;
    },
    _isBool(object) {
      return true === object || false === object;
    },
    _asBool(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolS(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolQ(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool?"));
    },
    _asDouble(object) {
      if (typeof object == "number")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleS(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double?"));
    },
    _isInt(object) {
      return typeof object == "number" && Math.floor(object) === object;
    },
    _asInt(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int"));
    },
    _asIntS(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int"));
    },
    _asIntQ(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int?"));
    },
    _isNum(object) {
      return typeof object == "number";
    },
    _asNum(object) {
      if (typeof object == "number")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num"));
    },
    _asNumS(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num"));
    },
    _asNumQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num?"));
    },
    _isString(object) {
      return typeof object == "string";
    },
    _asString(object) {
      if (typeof object == "string")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String"));
    },
    _asStringS(object) {
      if (typeof object == "string")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String"));
    },
    _asStringQ(object) {
      if (typeof object == "string")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String?"));
    },
    _rtiArrayToString(array, genericContext) {
      var s, sep, i;
      for (s = "", sep = "", i = 0; i < array.length; ++i, sep = ", ")
        s += sep + A._rtiToString(array[i], genericContext);
      return s;
    },
    _recordRtiToString(recordType, genericContext) {
      var fieldCount, names, namesIndex, s, comma, i,
        partialShape = recordType._primary,
        fields = recordType._rest;
      if ("" === partialShape)
        return "(" + A._rtiArrayToString(fields, genericContext) + ")";
      fieldCount = fields.length;
      names = partialShape.split(",");
      namesIndex = names.length - fieldCount;
      for (s = "(", comma = "", i = 0; i < fieldCount; ++i, comma = ", ") {
        s += comma;
        if (namesIndex === 0)
          s += "{";
        s += A._rtiToString(fields[i], genericContext);
        if (namesIndex >= 0)
          s += " " + names[namesIndex];
        ++namesIndex;
      }
      return s + "})";
    },
    _functionRtiToString(functionType, genericContext, bounds) {
      var boundsLength, offset, i, t1, t2, typeParametersText, typeSep, t3, t4, boundRti, kind, parameters, requiredPositional, requiredPositionalLength, optionalPositional, optionalPositionalLength, named, namedLength, returnTypeText, argumentsText, sep, _s2_ = ", ", outerContextLength = null;
      if (bounds != null) {
        boundsLength = bounds.length;
        if (genericContext == null)
          genericContext = A._setArrayType([], type$.JSArray_String);
        else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsLength; i > 0; --i)
          B.JSArray_methods.add$1(genericContext, "T" + (offset + i));
        for (t1 = type$.nullable_Object, t2 = type$.legacy_Object, typeParametersText = "<", typeSep = "", i = 0; i < boundsLength; ++i, typeSep = _s2_) {
          t3 = genericContext.length;
          t4 = t3 - 1 - i;
          if (!(t4 >= 0))
            return A.ioore(genericContext, t4);
          typeParametersText = B.JSString_methods.$add(typeParametersText + typeSep, genericContext[t4]);
          boundRti = bounds[i];
          kind = boundRti._kind;
          if (!(kind === 2 || kind === 3 || kind === 4 || kind === 5 || boundRti === t1))
            t3 = boundRti === t2;
          else
            t3 = true;
          if (!t3)
            typeParametersText += " extends " + A._rtiToString(boundRti, genericContext);
        }
        typeParametersText += ">";
      } else
        typeParametersText = "";
      t1 = functionType._primary;
      parameters = functionType._rest;
      requiredPositional = parameters._requiredPositional;
      requiredPositionalLength = requiredPositional.length;
      optionalPositional = parameters._optionalPositional;
      optionalPositionalLength = optionalPositional.length;
      named = parameters._named;
      namedLength = named.length;
      returnTypeText = A._rtiToString(t1, genericContext);
      for (argumentsText = "", sep = "", i = 0; i < requiredPositionalLength; ++i, sep = _s2_)
        argumentsText += sep + A._rtiToString(requiredPositional[i], genericContext);
      if (optionalPositionalLength > 0) {
        argumentsText += sep + "[";
        for (sep = "", i = 0; i < optionalPositionalLength; ++i, sep = _s2_)
          argumentsText += sep + A._rtiToString(optionalPositional[i], genericContext);
        argumentsText += "]";
      }
      if (namedLength > 0) {
        argumentsText += sep + "{";
        for (sep = "", i = 0; i < namedLength; i += 3, sep = _s2_) {
          argumentsText += sep;
          if (named[i + 1])
            argumentsText += "required ";
          argumentsText += A._rtiToString(named[i + 2], genericContext) + " " + named[i];
        }
        argumentsText += "}";
      }
      if (outerContextLength != null) {
        genericContext.toString;
        genericContext.length = outerContextLength;
      }
      return typeParametersText + "(" + argumentsText + ") => " + returnTypeText;
    },
    _rtiToString(rti, genericContext) {
      var questionArgument, s, argumentKind, $name, $arguments, t1, t2,
        kind = rti._kind;
      if (kind === 5)
        return "erased";
      if (kind === 2)
        return "dynamic";
      if (kind === 3)
        return "void";
      if (kind === 1)
        return "Never";
      if (kind === 4)
        return "any";
      if (kind === 6)
        return A._rtiToString(rti._primary, genericContext);
      if (kind === 7) {
        questionArgument = rti._primary;
        s = A._rtiToString(questionArgument, genericContext);
        argumentKind = questionArgument._kind;
        return (argumentKind === 12 || argumentKind === 13 ? "(" + s + ")" : s) + "?";
      }
      if (kind === 8)
        return "FutureOr<" + A._rtiToString(rti._primary, genericContext) + ">";
      if (kind === 9) {
        $name = A._unminifyOrTag(rti._primary);
        $arguments = rti._rest;
        return $arguments.length > 0 ? $name + ("<" + A._rtiArrayToString($arguments, genericContext) + ">") : $name;
      }
      if (kind === 11)
        return A._recordRtiToString(rti, genericContext);
      if (kind === 12)
        return A._functionRtiToString(rti, genericContext, null);
      if (kind === 13)
        return A._functionRtiToString(rti._primary, genericContext, rti._rest);
      if (kind === 14) {
        t1 = rti._primary;
        t2 = genericContext.length;
        t1 = t2 - 1 - t1;
        if (!(t1 >= 0 && t1 < t2))
          return A.ioore(genericContext, t1);
        return genericContext[t1];
      }
      return "?";
    },
    _unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    _Universe_findRule(universe, targetType) {
      var rule = universe.tR[targetType];
      for (; typeof rule == "string";)
        rule = universe.tR[rule];
      return rule;
    },
    _Universe_findErasedType(universe, cls) {
      var $length, erased, $arguments, i, $interface,
        t1 = universe.eT,
        probe = t1[cls];
      if (probe == null)
        return A._Universe_eval(universe, cls, false);
      else if (typeof probe == "number") {
        $length = probe;
        erased = A._Universe__lookupTerminalRti(universe, 5, "#");
        $arguments = A._Utils_newArrayOrEmpty($length);
        for (i = 0; i < $length; ++i)
          $arguments[i] = erased;
        $interface = A._Universe__lookupInterfaceRti(universe, cls, $arguments);
        t1[cls] = $interface;
        return $interface;
      } else
        return probe;
    },
    _Universe_addRules(universe, rules) {
      return A._Utils_objectAssign(universe.tR, rules);
    },
    _Universe_addErasedTypes(universe, types) {
      return A._Utils_objectAssign(universe.eT, types);
    },
    _Universe_eval(universe, recipe, normalize) {
      var rti,
        t1 = universe.eC,
        probe = t1.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, null, recipe, normalize));
      t1.set(recipe, rti);
      return rti;
    },
    _Universe_evalInEnvironment(universe, environment, recipe) {
      var probe, rti,
        cache = environment._evalCache;
      if (cache == null)
        cache = environment._evalCache = new Map();
      probe = cache.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, environment, recipe, true));
      cache.set(recipe, rti);
      return rti;
    },
    _Universe_bind(universe, environment, argumentsRti) {
      var argumentsRecipe, probe, rti,
        cache = environment._bindCache;
      if (cache == null)
        cache = environment._bindCache = new Map();
      argumentsRecipe = argumentsRti._canonicalRecipe;
      probe = cache.get(argumentsRecipe);
      if (probe != null)
        return probe;
      rti = A._Universe__lookupBindingRti(universe, environment, argumentsRti._kind === 10 ? argumentsRti._rest : [argumentsRti]);
      cache.set(argumentsRecipe, rti);
      return rti;
    },
    _Universe__installTypeTests(universe, rti) {
      rti._as = A._installSpecializedAsCheck;
      rti._is = A._installSpecializedIsTest;
      return rti;
    },
    _Universe__lookupTerminalRti(universe, kind, key) {
      var rti, t1,
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = kind;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupStarRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "*",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createStarRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createStarRti(universe, baseType, key, normalize) {
      var baseKind, t1, rti;
      if (normalize) {
        baseKind = baseType._kind;
        if (!A.isSoundTopType(baseType))
          t1 = baseType === type$.Null || baseType === type$.JSNull || baseKind === 7 || baseKind === 6;
        else
          t1 = true;
        if (t1)
          return baseType;
      }
      rti = new A.Rti(null, null);
      rti._kind = 6;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupQuestionRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "?",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createQuestionRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createQuestionRti(universe, baseType, key, normalize) {
      var baseKind, t1, starArgument, rti;
      if (normalize) {
        baseKind = baseType._kind;
        t1 = true;
        if (!A.isSoundTopType(baseType))
          if (!(baseType === type$.Null || baseType === type$.JSNull))
            if (baseKind !== 7)
              t1 = baseKind === 8 && A.isNullable(baseType._primary);
        if (t1)
          return baseType;
        else if (baseKind === 1 || baseType === type$.legacy_Never)
          return type$.Null;
        else if (baseKind === 6) {
          starArgument = baseType._primary;
          if (starArgument._kind === 8 && A.isNullable(starArgument._primary))
            return starArgument;
          else
            return A.Rti__getQuestionFromStar(universe, baseType);
        }
      }
      rti = new A.Rti(null, null);
      rti._kind = 7;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupFutureOrRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "/",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createFutureOrRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createFutureOrRti(universe, baseType, key, normalize) {
      var t1, rti;
      if (normalize) {
        t1 = baseType._kind;
        if (A.isSoundTopType(baseType) || baseType === type$.Object || baseType === type$.legacy_Object)
          return baseType;
        else if (t1 === 1)
          return A._Universe__lookupInterfaceRti(universe, "Future", [baseType]);
        else if (baseType === type$.Null || baseType === type$.JSNull)
          return type$.nullable_Future_Null;
      }
      rti = new A.Rti(null, null);
      rti._kind = 8;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupGenericFunctionParameterRti(universe, index) {
      var rti, t1,
        key = "" + index + "^",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 14;
      rti._primary = index;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__canonicalRecipeJoin($arguments) {
      var s, sep, i,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; ++i, sep = ",")
        s += sep + $arguments[i]._canonicalRecipe;
      return s;
    },
    _Universe__canonicalRecipeJoinNamed($arguments) {
      var s, sep, i, t1, nameSep,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; i += 3, sep = ",") {
        t1 = $arguments[i];
        nameSep = $arguments[i + 1] ? "!" : ":";
        s += sep + t1 + nameSep + $arguments[i + 2]._canonicalRecipe;
      }
      return s;
    },
    _Universe__lookupInterfaceRti(universe, $name, $arguments) {
      var probe, rti, t1,
        s = $name;
      if ($arguments.length > 0)
        s += "<" + A._Universe__canonicalRecipeJoin($arguments) + ">";
      probe = universe.eC.get(s);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 9;
      rti._primary = $name;
      rti._rest = $arguments;
      if ($arguments.length > 0)
        rti._precomputed1 = $arguments[0];
      rti._canonicalRecipe = s;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(s, t1);
      return t1;
    },
    _Universe__lookupBindingRti(universe, base, $arguments) {
      var newBase, newArguments, key, probe, rti, t1;
      if (base._kind === 10) {
        newBase = base._primary;
        newArguments = base._rest.concat($arguments);
      } else {
        newArguments = $arguments;
        newBase = base;
      }
      key = newBase._canonicalRecipe + (";<" + A._Universe__canonicalRecipeJoin(newArguments) + ">");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 10;
      rti._primary = newBase;
      rti._rest = newArguments;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupRecordRti(universe, partialShapeTag, fields) {
      var rti, t1,
        key = "+" + (partialShapeTag + "(" + A._Universe__canonicalRecipeJoin(fields) + ")"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 11;
      rti._primary = partialShapeTag;
      rti._rest = fields;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupFunctionRti(universe, returnType, parameters) {
      var sep, key, probe, rti, t1,
        s = returnType._canonicalRecipe,
        requiredPositional = parameters._requiredPositional,
        requiredPositionalLength = requiredPositional.length,
        optionalPositional = parameters._optionalPositional,
        optionalPositionalLength = optionalPositional.length,
        named = parameters._named,
        namedLength = named.length,
        recipe = "(" + A._Universe__canonicalRecipeJoin(requiredPositional);
      if (optionalPositionalLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "[" + A._Universe__canonicalRecipeJoin(optionalPositional) + "]";
      }
      if (namedLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "{" + A._Universe__canonicalRecipeJoinNamed(named) + "}";
      }
      key = s + (recipe + ")");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 12;
      rti._primary = returnType;
      rti._rest = parameters;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupGenericFunctionRti(universe, baseFunctionType, bounds, normalize) {
      var t1,
        key = baseFunctionType._canonicalRecipe + ("<" + A._Universe__canonicalRecipeJoin(bounds) + ">"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize) {
      var $length, typeArguments, count, i, bound, substitutedBase, substitutedBounds, rti;
      if (normalize) {
        $length = bounds.length;
        typeArguments = A._Utils_newArrayOrEmpty($length);
        for (count = 0, i = 0; i < $length; ++i) {
          bound = bounds[i];
          if (bound._kind === 1) {
            typeArguments[i] = bound;
            ++count;
          }
        }
        if (count > 0) {
          substitutedBase = A._substitute(universe, baseFunctionType, typeArguments, 0);
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, 0);
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, bounds !== substitutedBounds);
        }
      }
      rti = new A.Rti(null, null);
      rti._kind = 13;
      rti._primary = baseFunctionType;
      rti._rest = bounds;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Parser_create(universe, environment, recipe, normalize) {
      return {u: universe, e: environment, r: recipe, s: [], p: 0, n: normalize};
    },
    _Parser_parse(parser) {
      var t2, i, ch, t3, array, end, item,
        source = parser.r,
        t1 = parser.s;
      for (t2 = source.length, i = 0; i < t2;) {
        ch = source.charCodeAt(i);
        if (ch >= 48 && ch <= 57)
          i = A._Parser_handleDigit(i + 1, ch, source, t1);
        else if ((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124)
          i = A._Parser_handleIdentifier(parser, i, source, t1, false);
        else if (ch === 46)
          i = A._Parser_handleIdentifier(parser, i, source, t1, true);
        else {
          ++i;
          switch (ch) {
            case 44:
              break;
            case 58:
              t1.push(false);
              break;
            case 33:
              t1.push(true);
              break;
            case 59:
              t1.push(A._Parser_toType(parser.u, parser.e, t1.pop()));
              break;
            case 94:
              t1.push(A._Universe__lookupGenericFunctionParameterRti(parser.u, t1.pop()));
              break;
            case 35:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 5, "#"));
              break;
            case 64:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 2, "@"));
              break;
            case 126:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 3, "~"));
              break;
            case 60:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 62:
              A._Parser_handleTypeArguments(parser, t1);
              break;
            case 38:
              A._Parser_handleExtendedOperations(parser, t1);
              break;
            case 42:
              t3 = parser.u;
              t1.push(A._Universe__lookupStarRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 63:
              t3 = parser.u;
              t1.push(A._Universe__lookupQuestionRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 47:
              t3 = parser.u;
              t1.push(A._Universe__lookupFutureOrRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 40:
              t1.push(-3);
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 41:
              A._Parser_handleArguments(parser, t1);
              break;
            case 91:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 93:
              array = t1.splice(parser.p);
              A._Parser_toTypes(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-1);
              break;
            case 123:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 125:
              array = t1.splice(parser.p);
              A._Parser_toTypesNamed(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-2);
              break;
            case 43:
              end = source.indexOf("(", i);
              t1.push(source.substring(i, end));
              t1.push(-4);
              t1.push(parser.p);
              parser.p = t1.length;
              i = end + 1;
              break;
            default:
              throw "Bad character " + ch;
          }
        }
      }
      item = t1.pop();
      return A._Parser_toType(parser.u, parser.e, item);
    },
    _Parser_handleDigit(i, digit, source, stack) {
      var t1, ch,
        value = digit - 48;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (!(ch >= 48 && ch <= 57))
          break;
        value = value * 10 + (ch - 48);
      }
      stack.push(value);
      return i;
    },
    _Parser_handleIdentifier(parser, start, source, stack, hasPeriod) {
      var t1, ch, t2, string, environment, recipe,
        i = start + 1;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (ch === 46) {
          if (hasPeriod)
            break;
          hasPeriod = true;
        } else {
          if (!((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124))
            t2 = ch >= 48 && ch <= 57;
          else
            t2 = true;
          if (!t2)
            break;
        }
      }
      string = source.substring(start, i);
      if (hasPeriod) {
        t1 = parser.u;
        environment = parser.e;
        if (environment._kind === 10)
          environment = environment._primary;
        recipe = A._Universe_findRule(t1, environment._primary)[string];
        if (recipe == null)
          A.throwExpression('No "' + string + '" in "' + A.Rti__getCanonicalRecipe(environment) + '"');
        stack.push(A._Universe_evalInEnvironment(t1, environment, recipe));
      } else
        stack.push(string);
      return i;
    },
    _Parser_handleTypeArguments(parser, stack) {
      var base,
        t1 = parser.u,
        $arguments = A._Parser_collectArray(parser, stack),
        head = stack.pop();
      if (typeof head == "string")
        stack.push(A._Universe__lookupInterfaceRti(t1, head, $arguments));
      else {
        base = A._Parser_toType(t1, parser.e, head);
        switch (base._kind) {
          case 12:
            stack.push(A._Universe__lookupGenericFunctionRti(t1, base, $arguments, parser.n));
            break;
          default:
            stack.push(A._Universe__lookupBindingRti(t1, base, $arguments));
            break;
        }
      }
    },
    _Parser_handleArguments(parser, stack) {
      var requiredPositional, returnType, parameters,
        t1 = parser.u,
        head = stack.pop(),
        optionalPositional = null, named = null;
      if (typeof head == "number")
        switch (head) {
          case -1:
            optionalPositional = stack.pop();
            break;
          case -2:
            named = stack.pop();
            break;
          default:
            stack.push(head);
            break;
        }
      else
        stack.push(head);
      requiredPositional = A._Parser_collectArray(parser, stack);
      head = stack.pop();
      switch (head) {
        case -3:
          head = stack.pop();
          if (optionalPositional == null)
            optionalPositional = t1.sEA;
          if (named == null)
            named = t1.sEA;
          returnType = A._Parser_toType(t1, parser.e, head);
          parameters = new A._FunctionParameters();
          parameters._requiredPositional = requiredPositional;
          parameters._optionalPositional = optionalPositional;
          parameters._named = named;
          stack.push(A._Universe__lookupFunctionRti(t1, returnType, parameters));
          return;
        case -4:
          stack.push(A._Universe__lookupRecordRti(t1, stack.pop(), requiredPositional));
          return;
        default:
          throw A.wrapException(A.AssertionError$("Unexpected state under `()`: " + A.S(head)));
      }
    },
    _Parser_handleExtendedOperations(parser, stack) {
      var $top = stack.pop();
      if (0 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 1, "0&"));
        return;
      }
      if (1 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 4, "1&"));
        return;
      }
      throw A.wrapException(A.AssertionError$("Unexpected extended operation " + A.S($top)));
    },
    _Parser_collectArray(parser, stack) {
      var array = stack.splice(parser.p);
      A._Parser_toTypes(parser.u, parser.e, array);
      parser.p = stack.pop();
      return array;
    },
    _Parser_toType(universe, environment, item) {
      if (typeof item == "string")
        return A._Universe__lookupInterfaceRti(universe, item, universe.sEA);
      else if (typeof item == "number") {
        environment.toString;
        return A._Parser_indexToType(universe, environment, item);
      } else
        return item;
    },
    _Parser_toTypes(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 0; i < $length; ++i)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_toTypesNamed(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 2; i < $length; i += 3)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_indexToType(universe, environment, index) {
      var typeArguments, len,
        kind = environment._kind;
      if (kind === 10) {
        if (index === 0)
          return environment._primary;
        typeArguments = environment._rest;
        len = typeArguments.length;
        if (index <= len)
          return typeArguments[index - 1];
        index -= len;
        environment = environment._primary;
        kind = environment._kind;
      } else if (index === 0)
        return environment;
      if (kind !== 9)
        throw A.wrapException(A.AssertionError$("Indexed base must be an interface type"));
      typeArguments = environment._rest;
      if (index <= typeArguments.length)
        return typeArguments[index - 1];
      throw A.wrapException(A.AssertionError$("Bad index " + index + " for " + environment.toString$0(0)));
    },
    isSubtype(universe, s, t) {
      var result,
        sCache = s._isSubtypeCache;
      if (sCache == null)
        sCache = s._isSubtypeCache = new Map();
      result = sCache.get(t);
      if (result == null) {
        result = A._isSubtype(universe, s, null, t, null, false) ? 1 : 0;
        sCache.set(t, result);
      }
      if (0 === result)
        return false;
      if (1 === result)
        return true;
      return true;
    },
    _isSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var t1, sKind, leftTypeVariable, tKind, t2, sBounds, tBounds, sLength, i, sBound, tBound;
      if (s === t)
        return true;
      if (!A.isSoundTopType(t))
        t1 = t === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        return true;
      sKind = s._kind;
      if (sKind === 4)
        return true;
      if (A.isSoundTopType(s))
        return false;
      t1 = s._kind;
      if (t1 === 1)
        return true;
      leftTypeVariable = sKind === 14;
      if (leftTypeVariable)
        if (A._isSubtype(universe, sEnv[s._primary], sEnv, t, tEnv, false))
          return true;
      tKind = t._kind;
      t1 = s === type$.Null || s === type$.JSNull;
      if (t1) {
        if (tKind === 8)
          return A._isSubtype(universe, s, sEnv, t._primary, tEnv, false);
        return t === type$.Null || t === type$.JSNull || tKind === 7 || tKind === 6;
      }
      if (t === type$.Object) {
        if (sKind === 8)
          return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
        if (sKind === 6)
          return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
        return sKind !== 7;
      }
      if (sKind === 6)
        return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
      if (tKind === 6) {
        t1 = A.Rti__getQuestionFromStar(universe, t);
        return A._isSubtype(universe, s, sEnv, t1, tEnv, false);
      }
      if (sKind === 8) {
        if (!A._isSubtype(universe, s._primary, sEnv, t, tEnv, false))
          return false;
        return A._isSubtype(universe, A.Rti__getFutureFromFutureOr(universe, s), sEnv, t, tEnv, false);
      }
      if (sKind === 7) {
        t1 = A._isSubtype(universe, type$.Null, sEnv, t, tEnv, false);
        return t1 && A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
      }
      if (tKind === 8) {
        if (A._isSubtype(universe, s, sEnv, t._primary, tEnv, false))
          return true;
        return A._isSubtype(universe, s, sEnv, A.Rti__getFutureFromFutureOr(universe, t), tEnv, false);
      }
      if (tKind === 7) {
        t1 = A._isSubtype(universe, s, sEnv, type$.Null, tEnv, false);
        return t1 || A._isSubtype(universe, s, sEnv, t._primary, tEnv, false);
      }
      if (leftTypeVariable)
        return false;
      t1 = sKind !== 12;
      if ((!t1 || sKind === 13) && t === type$.Function)
        return true;
      t2 = sKind === 11;
      if (t2 && t === type$.Record)
        return true;
      if (tKind === 13) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (sKind !== 13)
          return false;
        sBounds = s._rest;
        tBounds = t._rest;
        sLength = sBounds.length;
        if (sLength !== tBounds.length)
          return false;
        sEnv = sEnv == null ? sBounds : sBounds.concat(sEnv);
        tEnv = tEnv == null ? tBounds : tBounds.concat(tEnv);
        for (i = 0; i < sLength; ++i) {
          sBound = sBounds[i];
          tBound = tBounds[i];
          if (!A._isSubtype(universe, sBound, sEnv, tBound, tEnv, false) || !A._isSubtype(universe, tBound, tEnv, sBound, sEnv, false))
            return false;
        }
        return A._isFunctionSubtype(universe, s._primary, sEnv, t._primary, tEnv, false);
      }
      if (tKind === 12) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (t1)
          return false;
        return A._isFunctionSubtype(universe, s, sEnv, t, tEnv, false);
      }
      if (sKind === 9) {
        if (tKind !== 9)
          return false;
        return A._isInterfaceSubtype(universe, s, sEnv, t, tEnv, false);
      }
      if (t2 && tKind === 11)
        return A._isRecordSubtype(universe, s, sEnv, t, tEnv, false);
      return false;
    },
    _isFunctionSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var sParameters, tParameters, sRequiredPositional, tRequiredPositional, sRequiredPositionalLength, tRequiredPositionalLength, requiredPositionalDelta, sOptionalPositional, tOptionalPositional, sOptionalPositionalLength, tOptionalPositionalLength, i, t1, sNamed, tNamed, sNamedLength, tNamedLength, sIndex, tIndex, tName, sName, sIsRequired;
      if (!A._isSubtype(universe, s._primary, sEnv, t._primary, tEnv, false))
        return false;
      sParameters = s._rest;
      tParameters = t._rest;
      sRequiredPositional = sParameters._requiredPositional;
      tRequiredPositional = tParameters._requiredPositional;
      sRequiredPositionalLength = sRequiredPositional.length;
      tRequiredPositionalLength = tRequiredPositional.length;
      if (sRequiredPositionalLength > tRequiredPositionalLength)
        return false;
      requiredPositionalDelta = tRequiredPositionalLength - sRequiredPositionalLength;
      sOptionalPositional = sParameters._optionalPositional;
      tOptionalPositional = tParameters._optionalPositional;
      sOptionalPositionalLength = sOptionalPositional.length;
      tOptionalPositionalLength = tOptionalPositional.length;
      if (sRequiredPositionalLength + sOptionalPositionalLength < tRequiredPositionalLength + tOptionalPositionalLength)
        return false;
      for (i = 0; i < sRequiredPositionalLength; ++i) {
        t1 = sRequiredPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[i], tEnv, t1, sEnv, false))
          return false;
      }
      for (i = 0; i < requiredPositionalDelta; ++i) {
        t1 = sOptionalPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[sRequiredPositionalLength + i], tEnv, t1, sEnv, false))
          return false;
      }
      for (i = 0; i < tOptionalPositionalLength; ++i) {
        t1 = sOptionalPositional[requiredPositionalDelta + i];
        if (!A._isSubtype(universe, tOptionalPositional[i], tEnv, t1, sEnv, false))
          return false;
      }
      sNamed = sParameters._named;
      tNamed = tParameters._named;
      sNamedLength = sNamed.length;
      tNamedLength = tNamed.length;
      for (sIndex = 0, tIndex = 0; tIndex < tNamedLength; tIndex += 3) {
        tName = tNamed[tIndex];
        for (; true;) {
          if (sIndex >= sNamedLength)
            return false;
          sName = sNamed[sIndex];
          sIndex += 3;
          if (tName < sName)
            return false;
          sIsRequired = sNamed[sIndex - 2];
          if (sName < tName) {
            if (sIsRequired)
              return false;
            continue;
          }
          t1 = tNamed[tIndex + 1];
          if (sIsRequired && !t1)
            return false;
          t1 = sNamed[sIndex - 1];
          if (!A._isSubtype(universe, tNamed[tIndex + 2], tEnv, t1, sEnv, false))
            return false;
          break;
        }
      }
      for (; sIndex < sNamedLength;) {
        if (sNamed[sIndex + 1])
          return false;
        sIndex += 3;
      }
      return true;
    },
    _isInterfaceSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var rule, recipes, $length, supertypeArgs, i,
        sName = s._primary,
        tName = t._primary;
      for (; sName !== tName;) {
        rule = universe.tR[sName];
        if (rule == null)
          return false;
        if (typeof rule == "string") {
          sName = rule;
          continue;
        }
        recipes = rule[tName];
        if (recipes == null)
          return false;
        $length = recipes.length;
        supertypeArgs = $length > 0 ? new Array($length) : init.typeUniverse.sEA;
        for (i = 0; i < $length; ++i)
          supertypeArgs[i] = A._Universe_evalInEnvironment(universe, s, recipes[i]);
        return A._areArgumentsSubtypes(universe, supertypeArgs, null, sEnv, t._rest, tEnv, false);
      }
      return A._areArgumentsSubtypes(universe, s._rest, null, sEnv, t._rest, tEnv, false);
    },
    _areArgumentsSubtypes(universe, sArgs, sVariances, sEnv, tArgs, tEnv, isLegacy) {
      var i,
        $length = sArgs.length;
      for (i = 0; i < $length; ++i)
        if (!A._isSubtype(universe, sArgs[i], sEnv, tArgs[i], tEnv, false))
          return false;
      return true;
    },
    _isRecordSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var i,
        sFields = s._rest,
        tFields = t._rest,
        sCount = sFields.length;
      if (sCount !== tFields.length)
        return false;
      if (s._primary !== t._primary)
        return false;
      for (i = 0; i < sCount; ++i)
        if (!A._isSubtype(universe, sFields[i], sEnv, tFields[i], tEnv, false))
          return false;
      return true;
    },
    isNullable(t) {
      var kind = t._kind,
        t1 = true;
      if (!(t === type$.Null || t === type$.JSNull))
        if (!A.isSoundTopType(t))
          if (kind !== 7)
            if (!(kind === 6 && A.isNullable(t._primary)))
              t1 = kind === 8 && A.isNullable(t._primary);
      return t1;
    },
    isDefinitelyTopType(t) {
      var t1;
      if (!A.isSoundTopType(t))
        t1 = t === type$.legacy_Object;
      else
        t1 = true;
      return t1;
    },
    isSoundTopType(t) {
      var kind = t._kind;
      return kind === 2 || kind === 3 || kind === 4 || kind === 5 || t === type$.nullable_Object;
    },
    _Utils_objectAssign(o, other) {
      var i, key,
        keys = Object.keys(other),
        $length = keys.length;
      for (i = 0; i < $length; ++i) {
        key = keys[i];
        o[key] = other[key];
      }
    },
    _Utils_newArrayOrEmpty($length) {
      return $length > 0 ? new Array($length) : init.typeUniverse.sEA;
    },
    Rti: function Rti(t0, t1) {
      var _ = this;
      _._as = t0;
      _._is = t1;
      _._cachedRuntimeType = _._specializedTestResource = _._isSubtypeCache = _._precomputed1 = null;
      _._kind = 0;
      _._canonicalRecipe = _._bindCache = _._evalCache = _._rest = _._primary = null;
    },
    _FunctionParameters: function _FunctionParameters() {
      this._named = this._optionalPositional = this._requiredPositional = null;
    },
    _Type: function _Type(t0) {
      this._rti = t0;
    },
    _Error: function _Error() {
    },
    _TypeError: function _TypeError(t0) {
      this.__rti$_message = t0;
    },
    _AsyncRun__initializeScheduleImmediate() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return A.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(A.convertDartClosureToJS(new A._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new A._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return A.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return A.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride(callback) {
      self.scheduleImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateJsOverride_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate(callback) {
      self.setImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer(callback) {
      A.Timer__createTimer(B.Duration_0, type$.void_Function._as(callback));
    },
    Timer__createTimer(duration, callback) {
      var milliseconds = B.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return A._TimerImpl$(milliseconds, callback);
    },
    _TimerImpl$(milliseconds, callback) {
      var t1 = new A._TimerImpl();
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter($T) {
      return new A._AsyncAwaitCompleter(new A._Future($.Zone__current, $T._eval$1("_Future<0>")), $T._eval$1("_AsyncAwaitCompleter<0>"));
    },
    _asyncStartSync(bodyFunction, completer) {
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._future;
    },
    _asyncAwait(object, bodyFunction) {
      A._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn(object, completer) {
      completer.complete$1(object);
    },
    _asyncRethrow(object, completer) {
      completer.completeError$2(A.unwrapException(object), A.getTraceFromException(object));
    },
    _awaitOnObject(object, bodyFunction) {
      var t1, future,
        thenCallback = new A._awaitOnObject_closure(bodyFunction),
        errorCallback = new A._awaitOnObject_closure0(bodyFunction);
      if (object instanceof A._Future)
        object._thenAwait$1$2(thenCallback, errorCallback, type$.dynamic);
      else {
        t1 = type$.dynamic;
        if (object instanceof A._Future)
          object.then$1$2$onError(thenCallback, errorCallback, t1);
        else {
          future = new A._Future($.Zone__current, type$._Future_dynamic);
          future._state = 8;
          future._resultOrListeners = object;
          future._thenAwait$1$2(thenCallback, errorCallback, t1);
        }
      }
    },
    _wrapJsFunctionForAsync($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true) {
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
          }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new A._wrapJsFunctionForAsync_closure($protected), type$.void, type$.int, type$.dynamic);
    },
    _asyncStarHelper(object, bodyFunctionOrErrorCode, controller) {
      var t1, t2, t3,
        _s10_ = "controller";
      if (bodyFunctionOrErrorCode === 0) {
        t1 = controller.cancelationFuture;
        if (t1 != null)
          t1._completeWithValue$1(null);
        else {
          t1 = controller.___AsyncStarStreamController_controller_A;
          t1 === $ && A.throwLateFieldNI(_s10_);
          t1.close$0();
        }
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        t1 = controller.cancelationFuture;
        if (t1 != null)
          t1._completeError$2(A.unwrapException(object), A.getTraceFromException(object));
        else {
          t1 = A.unwrapException(object);
          t2 = A.getTraceFromException(object);
          t3 = controller.___AsyncStarStreamController_controller_A;
          t3 === $ && A.throwLateFieldNI(_s10_);
          t3.addError$2(t1, t2);
          controller.___AsyncStarStreamController_controller_A.close$0();
        }
        return;
      }
      type$.void_Function_int_dynamic._as(bodyFunctionOrErrorCode);
      if (object instanceof A._IterationMarker) {
        if (controller.cancelationFuture != null) {
          bodyFunctionOrErrorCode.call$2(2, null);
          return;
        }
        t1 = object.state;
        if (t1 === 0) {
          t1 = object.value;
          t2 = controller.___AsyncStarStreamController_controller_A;
          t2 === $ && A.throwLateFieldNI(_s10_);
          t2.add$1(0, controller.$ti._precomputed1._as(t1));
          A.scheduleMicrotask(new A._asyncStarHelper_closure(controller, bodyFunctionOrErrorCode));
          return;
        } else if (t1 === 1) {
          t1 = controller.$ti._eval$1("Stream<1>")._as(type$.Stream_dynamic._as(object.value));
          t2 = controller.___AsyncStarStreamController_controller_A;
          t2 === $ && A.throwLateFieldNI(_s10_);
          t2.addStream$2$cancelOnError(t1, false).then$1$1(new A._asyncStarHelper_closure0(controller, bodyFunctionOrErrorCode), type$.Null);
          return;
        }
      }
      A._awaitOnObject(object, bodyFunctionOrErrorCode);
    },
    _streamOfController(controller) {
      var t1 = controller.___AsyncStarStreamController_controller_A;
      t1 === $ && A.throwLateFieldNI("controller");
      return new A._ControllerStream(t1, A._instanceType(t1)._eval$1("_ControllerStream<1>"));
    },
    _AsyncStarStreamController$(body, $T) {
      var t1 = new A._AsyncStarStreamController($T._eval$1("_AsyncStarStreamController<0>"));
      t1._AsyncStarStreamController$1(body, $T);
      return t1;
    },
    _makeAsyncStarStreamController(body, $T) {
      return A._AsyncStarStreamController$(body, $T);
    },
    _IterationMarker_yieldStar(values) {
      return new A._IterationMarker(values, 1);
    },
    _IterationMarker_yieldSingle(value) {
      return new A._IterationMarker(value, 0);
    },
    AsyncError$(error, stackTrace) {
      var t1 = A.checkNotNullable(error, "error", type$.Object);
      return new A.AsyncError(t1, stackTrace == null ? A.AsyncError_defaultStackTrace(error) : stackTrace);
    },
    AsyncError_defaultStackTrace(error) {
      var stackTrace;
      if (type$.Error._is(error)) {
        stackTrace = error.get$stackTrace();
        if (stackTrace != null)
          return stackTrace;
      }
      return B.C__StringStackTrace;
    },
    Future_Future$delayed(duration, computation, $T) {
      var result = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      A.Timer_Timer(duration, new A.Future_Future$delayed_closure(computation, result, $T));
      return result;
    },
    _Future$zoneValue(value, _zone, $T) {
      var t1 = new A._Future(_zone, $T._eval$1("_Future<0>"));
      $T._as(value);
      t1._state = 8;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainCoreFutureSync(source, target) {
      var t1, t2, listeners;
      for (t1 = type$._Future_dynamic; t2 = source._state, (t2 & 4) !== 0;)
        source = t1._as(source._resultOrListeners);
      if (source === target) {
        target._asyncCompleteError$2(new A.ArgumentError(true, source, null, "Cannot complete a future with itself"), A.StackTrace_current());
        return;
      }
      t1 = t2 | target._state & 1;
      source._state = t1;
      if ((t1 & 24) !== 0) {
        listeners = target._removeListeners$0();
        target._cloneResult$1(source);
        A._Future__propagateToListeners(target, listeners);
      } else {
        listeners = type$.nullable__FutureListener_dynamic_dynamic._as(target._resultOrListeners);
        target._setChained$1(source);
        source._prependListeners$1(listeners);
      }
    },
    _Future__chainCoreFutureAsync(source, target) {
      var t2, t3, listeners, _box_0 = {},
        t1 = _box_0.source = source;
      for (t2 = type$._Future_dynamic; t3 = t1._state, (t3 & 4) !== 0; t1 = source) {
        source = t2._as(t1._resultOrListeners);
        _box_0.source = source;
      }
      if (t1 === target) {
        target._asyncCompleteError$2(new A.ArgumentError(true, t1, null, "Cannot complete a future with itself"), A.StackTrace_current());
        return;
      }
      if ((t3 & 24) === 0) {
        listeners = type$.nullable__FutureListener_dynamic_dynamic._as(target._resultOrListeners);
        target._setChained$1(t1);
        _box_0.source._prependListeners$1(listeners);
        return;
      }
      if ((t3 & 16) === 0 && target._resultOrListeners == null) {
        target._cloneResult$1(t1);
        return;
      }
      target._state ^= 2;
      A._rootScheduleMicrotask(null, null, target._zone, type$.void_Function._as(new A._Future__chainCoreFutureAsync_closure(_box_0, target)));
    },
    _Future__propagateToListeners(source, listeners) {
      var t2, t3, t4, _box_0, t5, t6, hasError, asyncError, nextListener, nextListener0, sourceResult, t7, zone, oldZone, result, current, _box_1 = {},
        t1 = _box_1.source = source;
      for (t2 = type$.AsyncError, t3 = type$.nullable__FutureListener_dynamic_dynamic, t4 = type$.Future_dynamic; true;) {
        _box_0 = {};
        t5 = t1._state;
        t6 = (t5 & 16) === 0;
        hasError = !t6;
        if (listeners == null) {
          if (hasError && (t5 & 1) === 0) {
            asyncError = t2._as(t1._resultOrListeners);
            A._rootHandleError(asyncError.error, asyncError.stackTrace);
          }
          return;
        }
        _box_0.listener = listeners;
        nextListener = listeners._nextListener;
        for (t1 = listeners; nextListener != null; t1 = nextListener, nextListener = nextListener0) {
          t1._nextListener = null;
          A._Future__propagateToListeners(_box_1.source, t1);
          _box_0.listener = nextListener;
          nextListener0 = nextListener._nextListener;
        }
        t5 = _box_1.source;
        sourceResult = t5._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        if (t6) {
          t7 = t1.state;
          t7 = (t7 & 1) !== 0 || (t7 & 15) === 8;
        } else
          t7 = true;
        if (t7) {
          zone = t1.result._zone;
          if (hasError) {
            t5 = t5._zone === zone;
            t5 = !(t5 || t5);
          } else
            t5 = false;
          if (t5) {
            t2._as(sourceResult);
            A._rootHandleError(sourceResult.error, sourceResult.stackTrace);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone !== zone)
            $.Zone__current = zone;
          else
            oldZone = null;
          t1 = t1.state;
          if ((t1 & 15) === 8)
            new A._Future__propagateToListeners_handleWhenCompleteCallback(_box_0, _box_1, hasError).call$0();
          else if (t6) {
            if ((t1 & 1) !== 0)
              new A._Future__propagateToListeners_handleValueCallback(_box_0, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new A._Future__propagateToListeners_handleError(_box_1, _box_0).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (t1 instanceof A._Future) {
            t5 = _box_0.listener.$ti;
            t5 = t5._eval$1("Future<2>")._is(t1) || !t5._rest[1]._is(t1);
          } else
            t5 = false;
          if (t5) {
            t4._as(t1);
            result = _box_0.listener.result;
            if ((t1._state & 24) !== 0) {
              current = t3._as(result._resultOrListeners);
              result._resultOrListeners = null;
              listeners = result._reverseListeners$1(current);
              result._state = t1._state & 30 | result._state & 1;
              result._resultOrListeners = t1._resultOrListeners;
              _box_1.source = t1;
              continue;
            } else
              A._Future__chainCoreFutureSync(t1, result);
            return;
          }
        }
        result = _box_0.listener.result;
        current = t3._as(result._resultOrListeners);
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t5 = _box_0.listenerValueOrError;
        if (!t1) {
          result.$ti._precomputed1._as(t5);
          result._state = 8;
          result._resultOrListeners = t5;
        } else {
          t2._as(t5);
          result._state = result._state & 1 | 16;
          result._resultOrListeners = t5;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler(errorHandler, zone) {
      var t1;
      if (type$.dynamic_Function_Object_StackTrace._is(errorHandler))
        return zone.registerBinaryCallback$3$1(errorHandler, type$.dynamic, type$.Object, type$.StackTrace);
      t1 = type$.dynamic_Function_Object;
      if (t1._is(errorHandler))
        return t1._as(errorHandler);
      throw A.wrapException(A.ArgumentError$value(errorHandler, "onError", string$.Error_));
    },
    _microtaskLoop() {
      var entry, next;
      for (entry = $._nextCallback; entry != null; entry = $._nextCallback) {
        $._lastPriorityCallback = null;
        next = entry.next;
        $._nextCallback = next;
        if (next == null)
          $._lastCallback = null;
        entry.callback.call$0();
      }
    },
    _startMicrotaskLoop() {
      $._isInCallbackLoop = true;
      try {
        A._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback(callback) {
      var newEntry = new A._AsyncCallbackEntry(callback),
        lastCallback = $._lastCallback;
      if (lastCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback(callback) {
      var entry, lastPriorityCallback, next,
        t1 = $._nextCallback;
      if (t1 == null) {
        A._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new A._AsyncCallbackEntry(callback);
      lastPriorityCallback = $._lastPriorityCallback;
      if (lastPriorityCallback == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        next = lastPriorityCallback.next;
        entry.next = next;
        $._lastPriorityCallback = lastPriorityCallback.next = entry;
        if (next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask(callback) {
      var _null = null,
        currentZone = $.Zone__current;
      if (B.C__RootZone === currentZone) {
        A._rootScheduleMicrotask(_null, _null, B.C__RootZone, callback);
        return;
      }
      A._rootScheduleMicrotask(_null, _null, currentZone, type$.void_Function._as(currentZone.bindCallbackGuarded$1(callback)));
    },
    StreamIterator_StreamIterator(stream, $T) {
      return new A._StreamIterator(A.checkNotNullable(stream, "stream", type$.Object), $T._eval$1("_StreamIterator<0>"));
    },
    StreamController_StreamController(onCancel, onListen, onResume, $T) {
      return new A._AsyncStreamController(onListen, null, onResume, onCancel, $T._eval$1("_AsyncStreamController<0>"));
    },
    _runGuarded(notificationHandler) {
      var e, s, exception;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    _AddStreamState_makeErrorHandler(controller) {
      return new A._AddStreamState_makeErrorHandler_closure(controller);
    },
    _BufferingStreamSubscription__registerErrorHandler(zone, handleError) {
      if (handleError == null)
        handleError = A.async___nullErrorHandler$closure();
      if (type$.void_Function_Object_StackTrace._is(handleError))
        return zone.registerBinaryCallback$3$1(handleError, type$.dynamic, type$.Object, type$.StackTrace);
      if (type$.void_Function_Object._is(handleError))
        return type$.dynamic_Function_Object._as(handleError);
      throw A.wrapException(A.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace.", null));
    },
    _nullErrorHandler(error, stackTrace) {
      A._rootHandleError(type$.Object._as(error), type$.StackTrace._as(stackTrace));
    },
    Timer_Timer(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === B.C__RootZone)
        return A.Timer__createTimer(duration, type$.void_Function._as(callback));
      return A.Timer__createTimer(duration, type$.void_Function._as(t1.bindCallbackGuarded$1(callback)));
    },
    _rootHandleError(error, stackTrace) {
      A._schedulePriorityAsyncCallback(new A._rootHandleError_closure(error, stackTrace));
    },
    _rootRun($self, $parent, zone, f, $R) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary($self, $parent, zone, f, arg, $R, $T) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask($self, $parent, zone, f) {
      type$.void_Function._as(f);
      if (B.C__RootZone !== zone)
        f = zone.bindCallbackGuarded$1(f);
      A._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl() {
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._future = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _asyncStarHelper_closure: function _asyncStarHelper_closure(t0, t1) {
      this.controller = t0;
      this.bodyFunction = t1;
    },
    _asyncStarHelper_closure0: function _asyncStarHelper_closure0(t0, t1) {
      this.controller = t0;
      this.bodyFunction = t1;
    },
    _AsyncStarStreamController: function _AsyncStarStreamController(t0) {
      var _ = this;
      _.___AsyncStarStreamController_controller_A = $;
      _.isSuspended = false;
      _.cancelationFuture = null;
      _.$ti = t0;
    },
    _AsyncStarStreamController__resumeBody: function _AsyncStarStreamController__resumeBody(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController__resumeBody_closure: function _AsyncStarStreamController__resumeBody_closure(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController_closure0: function _AsyncStarStreamController_closure0(t0) {
      this._resumeBody = t0;
    },
    _AsyncStarStreamController_closure1: function _AsyncStarStreamController_closure1(t0, t1) {
      this.$this = t0;
      this._resumeBody = t1;
    },
    _AsyncStarStreamController_closure: function _AsyncStarStreamController_closure(t0, t1) {
      this.$this = t0;
      this.body = t1;
    },
    _AsyncStarStreamController__closure: function _AsyncStarStreamController__closure(t0) {
      this.body = t0;
    },
    _IterationMarker: function _IterationMarker(t0, t1) {
      this.value = t0;
      this.state = t1;
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    Future_Future$delayed_closure: function Future_Future$delayed_closure(t0, t1, t2) {
      this.computation = t0;
      this.result = t1;
      this.T = t2;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.$this = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.$this = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__chainCoreFutureAsync_closure: function _Future__chainCoreFutureAsync_closure(t0, t1) {
      this._box_0 = t0;
      this.target = t1;
    },
    _Future__asyncCompleteWithValue_closure: function _Future__asyncCompleteWithValue_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2) {
      this._box_0 = t0;
      this._box_1 = t1;
      this.hasError = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1) {
      this._box_0 = t0;
      this.sourceResult = t1;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1) {
      this._box_1 = t0;
      this._box_0 = t1;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._controller = t0;
      _._onData = t1;
      _._onError = t2;
      _._onDone = t3;
      _._zone = t4;
      _._state = t5;
      _._pending = _._cancelFuture = null;
      _.$ti = t6;
    },
    _AddStreamState: function _AddStreamState() {
    },
    _AddStreamState_makeErrorHandler_closure: function _AddStreamState_makeErrorHandler_closure(t0) {
      this.controller = t0;
    },
    _AddStreamState_cancel_closure: function _AddStreamState_cancel_closure(t0) {
      this.$this = t0;
    },
    _StreamControllerAddStreamState: function _StreamControllerAddStreamState(t0, t1, t2, t3) {
      var _ = this;
      _._varData = t0;
      _.addStreamFuture = t1;
      _.addSubscription = t2;
      _.$ti = t3;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription() {
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents(t0) {
      var _ = this;
      _._state = 0;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _.$ti = t0;
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamIterator: function _StreamIterator(t0, t1) {
      var _ = this;
      _._subscription = null;
      _._stateData = t0;
      _._async$_hasValue = false;
      _.$ti = t1;
    },
    _Zone: function _Zone() {
    },
    _rootHandleError_closure: function _rootHandleError_closure(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    LinkedHashMap_LinkedHashMap$_literal(keyValuePairs, $K, $V) {
      return $K._eval$1("@<0>")._bind$1($V)._eval$1("LinkedHashMap<1,2>")._as(A.fillLiteralMap(keyValuePairs, new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"))));
    },
    LinkedHashMap_LinkedHashMap$_empty($K, $V) {
      return new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"));
    },
    MapBase_mapToString(m) {
      var result, t1 = {};
      if (A.isToStringVisiting(m))
        return "{...}";
      result = new A.StringBuffer("");
      try {
        B.JSArray_methods.add$1($.toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        m.forEach$1(0, new A.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    ListBase: function ListBase() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    double_parse(source) {
      var value = A.Primitives_parseDouble(source);
      if (value != null)
        return value;
      throw A.wrapException(new A.FormatException("Invalid double", source));
    },
    Error__throw(error, stackTrace) {
      error = A.wrapException(error);
      if (error == null)
        error = type$.Object._as(error);
      error.stack = stackTrace.toString$0(0);
      throw error;
      throw A.wrapException("unreachable");
    },
    List_List$of(elements, $E) {
      var t1 = A.List_List$_of(elements, $E);
      return t1;
    },
    List_List$_of(elements, $E) {
      var list, t1;
      if (Array.isArray(elements))
        return A._setArrayType(elements.slice(0), $E._eval$1("JSArray<0>"));
      list = A._setArrayType([], $E._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, t1.get$current());
      return list;
    },
    StringBuffer__writeAll(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += A.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        string += A.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          string = string + separator + A.S(iterator.get$current());
      }
      return string;
    },
    StackTrace_current() {
      return A.getTraceFromException(new Error());
    },
    Error_safeToString(object) {
      if (typeof object == "number" || A._isBool(object) || object == null)
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      return A.Primitives_safeToString(object);
    },
    Error_throwWithStackTrace(error, stackTrace) {
      A.checkNotNullable(error, "error", type$.Object);
      A.checkNotNullable(stackTrace, "stackTrace", type$.StackTrace);
      A.Error__throw(error, stackTrace);
    },
    AssertionError$(message) {
      return new A.AssertionError(message);
    },
    ArgumentError$(message, $name) {
      return new A.ArgumentError(false, null, $name, message);
    },
    ArgumentError$value(value, $name, message) {
      return new A.ArgumentError(true, value, $name, message);
    },
    RangeError$range(invalidValue, minValue, maxValue, $name, message) {
      return new A.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValidRange(start, end, $length) {
      if (0 > start || start > $length)
        throw A.wrapException(A.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (start > end || end > $length)
          throw A.wrapException(A.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    IndexError$withLength(invalidValue, $length, indexable, $name) {
      return new A.IndexError($length, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$(message) {
      return new A.UnsupportedError(message);
    },
    UnimplementedError$(message) {
      return new A.UnimplementedError(message);
    },
    StateError$(message) {
      return new A.StateError(message);
    },
    ConcurrentModificationError$(modifiedObject) {
      return new A.ConcurrentModificationError(modifiedObject);
    },
    Exception_Exception(message) {
      return new A._Exception(message);
    },
    Iterable_iterableToFullString(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (A.isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new A.StringBuffer(leftDelimiter);
      B.JSArray_methods.add$1($.toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = A.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    print(object) {
      A.printString(object);
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    _Enum: function _Enum() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    TypeError: function TypeError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1) {
      this.message = t0;
      this.source = t1;
    },
    Null: function Null() {
    },
    Object: function Object() {
    },
    _StringStackTrace: function _StringStackTrace() {
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    LanguageCallableImpl: function LanguageCallableImpl(t0, t1, t2) {
      this.argCount = t0;
      this.action = t1;
      this.stringName = t2;
    },
    LanguageFunction: function LanguageFunction(t0, t1, t2) {
      this.declaration = t0;
      this.closure = t1;
      this.isInitializer = t2;
    },
    LanguageFunction_call_closure: function LanguageFunction_call_closure(t0) {
      this.controller = t0;
    },
    LanguageFunction_call_closure1: function LanguageFunction_call_closure1(t0, t1) {
      this._box_0 = t0;
      this.controller = t1;
    },
    LanguageFunction_call_closure0: function LanguageFunction_call_closure0(t0) {
      this.controller = t0;
    },
    LanguageClass: function LanguageClass(t0, t1, t2) {
      this.name = t0;
      this.superClass = t1;
      this.methods = t2;
    },
    LanguageInstance: function LanguageInstance(t0, t1) {
      this.klass = t0;
      this.fields = t1;
    },
    Environment: function Environment(t0, t1) {
      this.enclosing = t0;
      this.values = t1;
    },
    ParseError$(cause) {
      return new A.ParseError(cause);
    },
    ParserRuntimeError$(cause, token) {
      return new A.ParserRuntimeError(cause, token);
    },
    ParseError: function ParseError(t0) {
      this.cause = t0;
    },
    ParserRuntimeError: function ParserRuntimeError(t0, t1) {
      this.cause = t0;
      this.token = t1;
    },
    Return: function Return(t0) {
      this.value = t0;
    },
    ExpressionResultX: function ExpressionResultX() {
    },
    StmtState: function StmtState() {
    },
    Expr: function Expr() {
    },
    ExprNull: function ExprNull(t0) {
      this.result = t0;
    },
    ExprAssign: function ExprAssign(t0, t1, t2) {
      this.name = t0;
      this.value = t1;
      this.result = t2;
    },
    ExprBinary: function ExprBinary(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.op = t1;
      _.right = t2;
      _.result = t3;
    },
    ExprCall: function ExprCall(t0, t1, t2, t3) {
      var _ = this;
      _.callee = t0;
      _.paren = t1;
      _.$arguments = t2;
      _.result = t3;
    },
    ExprGet: function ExprGet(t0, t1, t2) {
      this.object = t0;
      this.name = t1;
      this.result = t2;
    },
    ExprGrouping: function ExprGrouping(t0, t1) {
      this.expression = t0;
      this.result = t1;
    },
    ExprLiteral: function ExprLiteral(t0, t1) {
      this.value = t0;
      this.result = t1;
    },
    ExprLogical: function ExprLogical(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.op = t1;
      _.right = t2;
      _.result = t3;
    },
    ExprSet: function ExprSet(t0, t1, t2, t3) {
      var _ = this;
      _.object = t0;
      _.name = t1;
      _.value = t2;
      _.result = t3;
    },
    ExprSuper: function ExprSuper(t0, t1, t2) {
      this.keyword = t0;
      this.method = t1;
      this.result = t2;
    },
    ExprThis: function ExprThis(t0, t1) {
      this.keyword = t0;
      this.result = t1;
    },
    ExprUnary: function ExprUnary(t0, t1, t2) {
      this.op = t0;
      this.right = t1;
      this.result = t2;
    },
    ExprVariable: function ExprVariable(t0, t1) {
      this.name = t0;
      this.result = t1;
    },
    Stmt: function Stmt() {
    },
    StmtNull: function StmtNull(t0, t1) {
      this.reason = t0;
      this.state = t1;
    },
    StmtBlock: function StmtBlock(t0, t1) {
      this.statements = t0;
      this.state = t1;
    },
    StmtClass: function StmtClass(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.superClass = t1;
      _.methods = t2;
      _.state = t3;
    },
    StmtExpression: function StmtExpression(t0, t1) {
      this.expression = t0;
      this.state = t1;
    },
    StmtFunction: function StmtFunction(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.params = t1;
      _.body = t2;
      _.state = t3;
    },
    StmtIf: function StmtIf(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.thenBranch = t1;
      _.elseBranch = t2;
      _.state = t3;
    },
    StmtPrint: function StmtPrint(t0, t1) {
      this.expression = t0;
      this.state = t1;
    },
    StmtReturn: function StmtReturn(t0, t1, t2) {
      this.keyword = t0;
      this.value = t1;
      this.state = t2;
    },
    StmtVar: function StmtVar(t0, t1, t2) {
      this.name = t0;
      this.initializer = t1;
      this.state = t2;
    },
    StmtWhile: function StmtWhile(t0, t1, t2) {
      this.condition = t0;
      this.body = t1;
      this.state = t2;
    },
    Interpreter$() {
      var t1 = new A.Interpreter(new A.Environment(null, A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Object)), A.LinkedHashMap_LinkedHashMap$_empty(type$.Expr, type$.int), new A.ExpressionResultX());
      t1.Interpreter$0();
      return t1;
    },
    InterpreterInfoType: function InterpreterInfoType(t0) {
      this._name = t0;
    },
    InterpreterInfo: function InterpreterInfo(t0, t1, t2, t3) {
      var _ = this;
      _.type = t0;
      _.object = t1;
      _.output = t2;
      _.completer = t3;
    },
    Interpreter: function Interpreter(t0, t1, t2) {
      var _ = this;
      _.globals = t0;
      _.__Interpreter_environment_A = $;
      _.locals = t1;
      _.currentExprResult = t2;
    },
    Interpreter_closure: function Interpreter_closure() {
    },
    Interpreter_executeBlock_closure: function Interpreter_executeBlock_closure(t0, t1) {
      this.controller = t0;
      this.statement = t1;
    },
    Interpreter_executeBlock__closure: function Interpreter_executeBlock__closure(t0) {
      this.statement = t0;
    },
    Interpreter_executeBlock_closure1: function Interpreter_executeBlock_closure1(t0) {
      this.controller = t0;
    },
    Interpreter_executeBlock_closure0: function Interpreter_executeBlock_closure0(t0) {
      this.controller = t0;
    },
    ParserStateType: function ParserStateType(t0) {
      this._name = t0;
    },
    ParserState: function ParserState(t0, t1, t2, t3) {
      var _ = this;
      _.statement = t0;
      _.expression = t1;
      _.type = t2;
      _.completer = t3;
    },
    Parser: function Parser(t0, t1) {
      var _ = this;
      _.topStatementCounter = 0;
      _.isInner = false;
      _.tokens = t0;
      _.current = 0;
      _.errors = t1;
    },
    ResolveInfo$(depth, message, type) {
      return new A.ResolveInfo();
    },
    FunctionType: function FunctionType(t0) {
      this._name = t0;
    },
    ClassType: function ClassType(t0) {
      this._name = t0;
    },
    ResolveInfoType: function ResolveInfoType(t0) {
      this._name = t0;
    },
    ResolveInfo: function ResolveInfo() {
    },
    Resolver: function Resolver(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.interpreter = t0;
      _.scopes = t1;
      _.errors = t2;
      _.currentFunction = t3;
      _.currentClass = t4;
      _.depth = -1;
      _.outputData = t5;
    },
    _charDescription(char) {
      if (char == null)
        return "<NULL>";
      else if (char === " ")
        return "<SPACE>";
      else if (char === "\n")
        return "<NEWLINE>";
      else if (char === "\r")
        return "<CARRIAGE_RETURN>";
      else if (char === "\t")
        return "<TAB>";
      return char;
    },
    ScanStateType: function ScanStateType(t0) {
      this._name = t0;
    },
    ScanState: function ScanState(t0, t1, t2) {
      this.token = t0;
      this.type = t1;
      this.completer = t2;
    },
    Scanner: function Scanner(t0, t1, t2) {
      var _ = this;
      _.source = t0;
      _.tokens = t1;
      _.current = _.start = 0;
      _.line = 1;
      _.startLineOffsetStart = _.currentLineOffsetStart = 0;
      _.startLine = 1;
      _.errors = t2;
    },
    Token_Token$empty() {
      return new A.Token(B.TokenType_40, "", null, -1);
    },
    TokenType: function TokenType(t0) {
      this._name = t0;
    },
    Token: function Token(t0, t1, t2, t3) {
      var _ = this;
      _.type = t0;
      _.lexeme = t1;
      _.literal = t2;
      _.line = t3;
    },
    isolateEntryInterpreter() {
      var t1, t2, result;
      A.print("------------- isolateEntryInterpreter");
      t1 = new A.isolateEntryInterpreter_sendy();
      t2 = type$.JSObject._as(self.self);
      t1 = new A.isolateEntryInterpreter_closure(new A.isolateEntryInterpreter_executeInContext(t1), t1);
      if (typeof t1 == "function")
        A.throwExpression(A.ArgumentError$("Attempting to rewrap a JS function.", null));
      result = function(_call, f) {
        return function(arg1) {
          return _call(f, arg1, arguments.length);
        };
      }(A._callDartFunctionFast1, t1);
      result[$.$get$DART_CLOSURE_PROPERTY_NAME()] = t1;
      t2.onmessage = result;
    },
    main() {
      A.print("Worker script is running. Origin: " + A._asString(type$.JSObject._as(self.self).origin));
      A.isolateEntryInterpreter();
    },
    isolateEntryInterpreter_sendy: function isolateEntryInterpreter_sendy() {
    },
    isolateEntryInterpreter_executeInContext: function isolateEntryInterpreter_executeInContext(t0) {
      this.sendy = t0;
    },
    isolateEntryInterpreter_executeInContext_closure: function isolateEntryInterpreter_executeInContext_closure(t0) {
      this.statements = t0;
    },
    isolateEntryInterpreter_executeInContext_closure0: function isolateEntryInterpreter_executeInContext_closure0(t0) {
      this.parseStreamCompleter = t0;
    },
    isolateEntryInterpreter_executeInContext_closure1: function isolateEntryInterpreter_executeInContext_closure1(t0, t1) {
      this._box_0 = t0;
      this.parseStreamCompleter = t1;
    },
    isolateEntryInterpreter_executeInContext_closure2: function isolateEntryInterpreter_executeInContext_closure2() {
    },
    isolateEntryInterpreter_executeInContext_closure3: function isolateEntryInterpreter_executeInContext_closure3(t0) {
      this.resolverStreamCompleter = t0;
    },
    isolateEntryInterpreter_executeInContext_closure4: function isolateEntryInterpreter_executeInContext_closure4(t0) {
      this.resolverStreamCompleter = t0;
    },
    isolateEntryInterpreter_executeInContext_closure5: function isolateEntryInterpreter_executeInContext_closure5(t0, t1) {
      this._box_0 = t0;
      this.sendy = t1;
    },
    isolateEntryInterpreter_executeInContext_closure7: function isolateEntryInterpreter_executeInContext_closure7(t0) {
      this.sendy = t0;
    },
    isolateEntryInterpreter_executeInContext_closure6: function isolateEntryInterpreter_executeInContext_closure6(t0) {
      this.sendy = t0;
    },
    isolateEntryInterpreter_closure: function isolateEntryInterpreter_closure(t0, t1) {
      this.executeInContext = t0;
      this.sendy = t1;
    },
    isolateEntryInterpreter__closure: function isolateEntryInterpreter__closure(t0) {
      this.sendy = t0;
    },
    isolateEntryInterpreter__closure1: function isolateEntryInterpreter__closure1(t0) {
      this.sendy = t0;
    },
    isolateEntryInterpreter__closure0: function isolateEntryInterpreter__closure0(t0) {
      this.sendy = t0;
    },
    printString(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    },
    _callDartFunctionFast1(callback, arg1, $length) {
      type$.Function._as(callback);
      if (A._asInt($length) >= 1)
        return callback.call$1(arg1);
      return callback.call$0();
    },
    Language_error(token, message) {
      var t1 = "" + token.line;
      if (token.type === B.TokenType_41)
        return "[line " + t1 + "] Error at end: " + message;
      else
        return "[line " + t1 + "] Error" + (" at '" + token.lexeme + "'") + ": " + message;
    }
  },
  B = {};
  var holders = [A, J, B];
  var $ = {};
  A.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq(receiver, other) {
      return receiver === other;
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    toString$0(receiver) {
      return "Instance of '" + A.Primitives_objectTypeName(receiver) + "'";
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._instanceTypeFromConstructor(this));
    }
  };
  J.JSBool.prototype = {
    toString$0(receiver) {
      return String(receiver);
    },
    get$hashCode(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.bool);
    },
    $isTrustedGetRuntimeType: 1,
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq(receiver, other) {
      return null == other;
    },
    toString$0(receiver) {
      return "null";
    },
    get$hashCode(receiver) {
      return 0;
    },
    $isTrustedGetRuntimeType: 1,
    $isNull: 1
  };
  J.JavaScriptObject.prototype = {$isJSObject: 1};
  J.LegacyJavaScriptObject.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    get$runtimeType(receiver) {
      return B.Type_JSObject_0ua;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$LegacyJavaScriptObject$toString(receiver);
      return "JavaScript function for " + J.toString$0$(dartClosure);
    },
    $isFunction: 1
  };
  J.JavaScriptBigInt.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JavaScriptSymbol.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JSArray.prototype = {
    add$1(receiver, value) {
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("add"));
      receiver.push(value);
    },
    addAll$1(receiver, collection) {
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(collection);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("addAll"));
      this._addAllFromArray$1(receiver, collection);
      return;
    },
    _addAllFromArray$1(receiver, array) {
      var len, i;
      type$.JSArray_dynamic._as(array);
      len = array.length;
      if (len === 0)
        return;
      if (receiver === array)
        throw A.wrapException(A.ConcurrentModificationError$(receiver));
      for (i = 0; i < len; ++i)
        receiver.push(array[i]);
    },
    get$last(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw A.wrapException(A.IterableElementError_noElement());
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    },
    get$iterator(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, A._arrayInstanceType(receiver)._eval$1("ArrayIterator<1>"));
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $add(receiver, other) {
      var t1 = A._arrayInstanceType(receiver);
      t1._eval$1("List<1>")._as(other);
      t1 = A.List_List$of(receiver, t1._precomputed1);
      this.addAll$1(t1, other);
      return t1;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._arrayInstanceType(receiver));
    },
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current() {
      var t1 = this._current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this._length !== $length) {
        t1 = A.throwConcurrentModificationError(t1);
        throw A.wrapException(t1);
      }
      t2 = _this._index;
      if (t2 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t1[t2]);
      ++_this._index;
      return true;
    },
    set$_current(_current) {
      this._current = this.$ti._eval$1("1?")._as(_current);
    }
  };
  J.JSNumber.prototype = {
    toString$0(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return intValue & 536870911;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259 & 536870911;
    },
    _tdivFast$1(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw A.wrapException(A.UnsupportedError$("Result of truncating division is " + A.S(quotient) + ": " + A.S(receiver) + " ~/ " + other));
    },
    _shrOtherPositive$1(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrBothPositive$1(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.num);
    },
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.int);
    },
    $isTrustedGetRuntimeType: 1,
    $isint: 1
  };
  J.JSNumNotInt.prototype = {
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.double);
    },
    $isTrustedGetRuntimeType: 1
  };
  J.JSString.prototype = {
    $add(receiver, other) {
      return receiver + other;
    },
    endsWith$1(receiver, other) {
      var otherLength = other.length,
        t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    startsWith$1(receiver, pattern) {
      var otherLength = pattern.length;
      if (otherLength > receiver.length)
        return false;
      return pattern === receiver.substring(0, otherLength);
    },
    substring$2(receiver, start, end) {
      return receiver.substring(start, A.RangeError_checkValidRange(start, end, receiver.length));
    },
    substring$1(receiver, start) {
      return this.substring$2(receiver, start, null);
    },
    trim$0(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (0 >= endIndex)
        return A.ioore(result, 0);
      if (result.charCodeAt(0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      if (!(t1 >= 0))
        return A.ioore(result, t1);
      endIndex0 = result.charCodeAt(t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw A.wrapException(B.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    toString$0(receiver) {
      return receiver;
    },
    get$hashCode(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = hash + receiver.charCodeAt(i) & 536870911;
        hash = hash + ((hash & 524287) << 10) & 536870911;
        hash ^= hash >> 6;
      }
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.String);
    },
    get$length(receiver) {
      return receiver.length;
    },
    $isTrustedGetRuntimeType: 1,
    $isPattern: 1,
    $isString: 1
  };
  A.LateError.prototype = {
    toString$0(_) {
      return "LateInitializationError: " + this._message;
    }
  };
  A.nullFuture_closure.prototype = {
    call$0() {
      var t1 = new A._Future($.Zone__current, type$._Future_Null);
      t1._asyncComplete$1(null);
      return t1;
    },
    $signature: 8
  };
  A.ListIterator.prototype = {
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t3, _this = this,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length !== $length)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      t3 = _this.__internal$_index;
      if (t3 >= $length) {
        _this.set$__internal$_current(null);
        return false;
      }
      _this.set$__internal$_current(t2.$index(t1, t3));
      ++_this.__internal$_index;
      return true;
    },
    set$__internal$_current(_current) {
      this.__internal$_current = this.$ti._eval$1("1?")._as(_current);
    }
  };
  A.FixedLengthListMixin.prototype = {};
  A.TypeErrorDecoder.prototype = {
    matchTypeError$1(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return null;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  A.NullError.prototype = {
    toString$0(_) {
      return "Null check operator used on a null value";
    }
  };
  A.JsNoSuchMethodError.prototype = {
    toString$0(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + _this.__js_helper$_message;
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + _this.__js_helper$_message + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + _this.__js_helper$_message + ")";
    }
  };
  A.UnknownJsTypeError.prototype = {
    toString$0(_) {
      var t1 = this.__js_helper$_message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  A.NullThrownFromJavaScriptException.prototype = {
    toString$0(_) {
      return "Throw of null ('" + (this._irritant === null ? "null" : "undefined") + "' from JavaScript)";
    }
  };
  A.ExceptionAndStackTrace.prototype = {};
  A._StackTrace.prototype = {
    toString$0(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  A.Closure.prototype = {
    toString$0(_) {
      var $constructor = this.constructor,
        $name = $constructor == null ? null : $constructor.name;
      return "Closure '" + A.unminifyOrTag($name == null ? "unknown" : $name) + "'";
    },
    get$runtimeType(_) {
      var rti = A.closureFunctionType(this);
      return A.createRuntimeType(rti == null ? A.instanceType(this) : rti);
    },
    $isFunction: 1,
    get$$call() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  A.Closure0Args.prototype = {"call*": "call$0", $requiredArgCount: 0};
  A.Closure2Args.prototype = {"call*": "call$2", $requiredArgCount: 2};
  A.TearOffClosure.prototype = {};
  A.StaticClosure.prototype = {
    toString$0(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + A.unminifyOrTag($name) + "'";
    }
  };
  A.BoundClosure.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof A.BoundClosure))
        return false;
      return this.$_target === other.$_target && this._receiver === other._receiver;
    },
    get$hashCode(_) {
      return (A.objectHashCode(this._receiver) ^ A.Primitives_objectHashCode(this.$_target)) >>> 0;
    },
    toString$0(_) {
      return "Closure '" + this.$_name + "' of " + ("Instance of '" + A.Primitives_objectTypeName(this._receiver) + "'");
    }
  };
  A._CyclicInitializationError.prototype = {
    toString$0(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  };
  A.RuntimeError.prototype = {
    toString$0(_) {
      return "RuntimeError: " + this.message;
    }
  };
  A._AssertionError.prototype = {
    toString$0(_) {
      return "Assertion failed: " + A.Error_safeToString(this.message);
    }
  };
  A.JsLinkedHashMap.prototype = {
    get$length(_) {
      return this.__js_helper$_length;
    },
    containsKey$1(key) {
      var strings = this._strings;
      if (strings == null)
        return false;
      return strings[key] != null;
    },
    $index(_, key) {
      var strings, cell, t1, nums, _null = null;
      if (typeof key == "string") {
        strings = this._strings;
        if (strings == null)
          return _null;
        cell = strings[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return _null;
        cell = nums[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else
        return this.internalGet$1(key);
    },
    internalGet$1(key) {
      var bucket, index,
        rest = this.__js_helper$_rest;
      if (rest == null)
        return null;
      bucket = rest[J.get$hashCode$(key) & 1073741823];
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return null;
      return bucket[index].hashMapCellValue;
    },
    $indexSet(_, key, value) {
      var strings, nums, rest, hash, bucket, index, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (typeof key == "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else {
        rest = _this.__js_helper$_rest;
        if (rest == null)
          rest = _this.__js_helper$_rest = _this._newHashTable$0();
        hash = J.get$hashCode$(key) & 1073741823;
        bucket = rest[hash];
        if (bucket == null)
          rest[hash] = [_this._newLinkedCell$2(key, value)];
        else {
          index = _this.internalFindBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index].hashMapCellValue = value;
          else
            bucket.push(_this._newLinkedCell$2(key, value));
        }
      }
    },
    forEach$1(_, action) {
      var cell, modifications, _this = this;
      _this.$ti._eval$1("~(1,2)")._as(action);
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3(table, key, value) {
      var cell,
        t1 = this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.hashMapCellValue = value;
    },
    _newLinkedCell$2(key, value) {
      var _this = this,
        t1 = _this.$ti,
        cell = new A.LinkedHashMapCell(t1._precomputed1._as(key), t1._rest[1]._as(value));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else
        _this._last = _this._last._next = cell;
      ++_this.__js_helper$_length;
      _this._modifications = _this._modifications + 1 & 1073741823;
      return cell;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    _newHashTable$0() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    $isLinkedHashMap: 1
  };
  A.LinkedHashMapCell.prototype = {};
  A.initHooks_closure.prototype = {
    call$1(o) {
      return this.getTag(o);
    },
    $signature: 9
  };
  A.initHooks_closure0.prototype = {
    call$2(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 10
  };
  A.initHooks_closure1.prototype = {
    call$1(tag) {
      return this.prototypeForTag(A._asString(tag));
    },
    $signature: 11
  };
  A._Cell.prototype = {
    _readLocal$0() {
      var t1 = this._value;
      if (t1 === this)
        throw A.wrapException(new A.LateError("Local '" + this.__late_helper$_name + "' has not been initialized."));
      return t1;
    }
  };
  A.NativeByteBuffer.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteBuffer_EOZ;
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeTypedData.prototype = {};
  A.NativeByteData.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteData_mF8;
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeTypedArray.prototype = {
    get$length(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: 1
  };
  A.NativeTypedArrayOfDouble.prototype = {
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isIterable: 1,
    $isList: 1
  };
  A.NativeTypedArrayOfInt.prototype = {$isIterable: 1, $isList: 1};
  A.NativeFloat32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float32List_Ymk;
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeFloat64List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float64List_Ymk;
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeInt16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int16List_cot;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeInt32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int32List_m1p;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeInt8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int8List_woc;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeUint16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint16List_2mh;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeUint32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint32List_2mh;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeUint8ClampedList.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8ClampedList_9Bb;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A.NativeUint8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8List_CSc;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1
  };
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A.Rti.prototype = {
    _eval$1(recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, this, recipe);
    },
    _bind$1(typeOrTuple) {
      return A._Universe_bind(init.typeUniverse, this, typeOrTuple);
    }
  };
  A._FunctionParameters.prototype = {};
  A._Type.prototype = {
    toString$0(_) {
      return A._rtiToString(this._rti, null);
    }
  };
  A._Error.prototype = {
    toString$0(_) {
      return this.__rti$_message;
    }
  };
  A._TypeError.prototype = {$isTypeError: 1};
  A._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 1
  };
  A._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1(callback) {
      var t1, t2;
      this._box_0.storedCallback = type$.void_Function._as(callback);
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 12
  };
  A._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 2
  };
  A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 2
  };
  A._TimerImpl.prototype = {
    _TimerImpl$2(milliseconds, callback) {
      if (self.setTimeout != null)
        self.setTimeout(A.convertDartClosureToJS(new A._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw A.wrapException(A.UnsupportedError$("`setTimeout()` not found."));
    }
  };
  A._TimerImpl_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 0
  };
  A._AsyncAwaitCompleter.prototype = {
    complete$1(value) {
      var t2, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/?")._as(value);
      if (value == null)
        value = t1._precomputed1._as(value);
      if (!_this.isSync)
        _this._future._asyncComplete$1(value);
      else {
        t2 = _this._future;
        if (t1._eval$1("Future<1>")._is(value))
          t2._chainFuture$1(value);
        else
          t2._completeWithValue$1(value);
      }
    },
    completeError$2(e, st) {
      var t1 = this._future;
      if (this.isSync)
        t1._completeError$2(e, st);
      else
        t1._asyncCompleteError$2(e, st);
    },
    $isCompleter: 1
  };
  A._awaitOnObject_closure.prototype = {
    call$1(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 13
  };
  A._awaitOnObject_closure0.prototype = {
    call$2(error, stackTrace) {
      this.bodyFunction.call$2(1, new A.ExceptionAndStackTrace(error, type$.StackTrace._as(stackTrace)));
    },
    $signature: 14
  };
  A._wrapJsFunctionForAsync_closure.prototype = {
    call$2(errorCode, result) {
      this.$protected(A._asInt(errorCode), result);
    },
    $signature: 15
  };
  A._asyncStarHelper_closure.prototype = {
    call$0() {
      var t3,
        t1 = this.controller,
        t2 = t1.___AsyncStarStreamController_controller_A;
      t2 === $ && A.throwLateFieldNI("controller");
      t3 = t2._state;
      if ((t3 & 1) !== 0 ? (t2.get$_subscription()._state & 4) !== 0 : (t3 & 2) === 0) {
        t1.isSuspended = true;
        return;
      }
      t1 = t1.cancelationFuture != null ? 2 : 0;
      this.bodyFunction.call$2(t1, null);
    },
    $signature: 0
  };
  A._asyncStarHelper_closure0.prototype = {
    call$1(_) {
      var errorCode = this.controller.cancelationFuture != null ? 2 : 0;
      this.bodyFunction.call$2(errorCode, null);
    },
    $signature: 1
  };
  A._AsyncStarStreamController.prototype = {
    _AsyncStarStreamController$1(body, $T) {
      var _this = this,
        t1 = new A._AsyncStarStreamController__resumeBody(body);
      _this.set$___AsyncStarStreamController_controller_A(_this.$ti._eval$1("StreamController<1>")._as(A.StreamController_StreamController(new A._AsyncStarStreamController_closure(_this, body), new A._AsyncStarStreamController_closure0(t1), new A._AsyncStarStreamController_closure1(_this, t1), $T)));
    },
    set$___AsyncStarStreamController_controller_A(___AsyncStarStreamController_controller_A) {
      this.___AsyncStarStreamController_controller_A = this.$ti._eval$1("StreamController<1>")._as(___AsyncStarStreamController_controller_A);
    }
  };
  A._AsyncStarStreamController__resumeBody.prototype = {
    call$0() {
      A.scheduleMicrotask(new A._AsyncStarStreamController__resumeBody_closure(this.body));
    },
    $signature: 2
  };
  A._AsyncStarStreamController__resumeBody_closure.prototype = {
    call$0() {
      this.body.call$2(0, null);
    },
    $signature: 0
  };
  A._AsyncStarStreamController_closure0.prototype = {
    call$0() {
      this._resumeBody.call$0();
    },
    $signature: 0
  };
  A._AsyncStarStreamController_closure1.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1.isSuspended) {
        t1.isSuspended = false;
        this._resumeBody.call$0();
      }
    },
    $signature: 0
  };
  A._AsyncStarStreamController_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1.___AsyncStarStreamController_controller_A;
      t2 === $ && A.throwLateFieldNI("controller");
      if ((t2._state & 4) === 0) {
        t1.cancelationFuture = new A._Future($.Zone__current, type$._Future_dynamic);
        if (t1.isSuspended) {
          t1.isSuspended = false;
          A.scheduleMicrotask(new A._AsyncStarStreamController__closure(this.body));
        }
        return t1.cancelationFuture;
      }
    },
    $signature: 16
  };
  A._AsyncStarStreamController__closure.prototype = {
    call$0() {
      this.body.call$2(2, null);
    },
    $signature: 0
  };
  A._IterationMarker.prototype = {
    toString$0(_) {
      return "IterationMarker(" + this.state + ", " + A.S(this.value) + ")";
    }
  };
  A.AsyncError.prototype = {
    toString$0(_) {
      return A.S(this.error);
    },
    $isError: 1,
    get$stackTrace() {
      return this.stackTrace;
    }
  };
  A.Future_Future$delayed_closure.prototype = {
    call$0() {
      var computationResult, e, s, exception, stackTrace, _this = this,
        t1 = _this.computation;
      if (t1 == null) {
        _this.T._as(null);
        _this.result._complete$1(null);
      } else {
        computationResult = null;
        try {
          computationResult = t1.call$0();
        } catch (exception) {
          e = A.unwrapException(exception);
          s = A.getTraceFromException(exception);
          t1 = e;
          stackTrace = s;
          if (stackTrace == null)
            stackTrace = A.AsyncError_defaultStackTrace(t1);
          _this.result._completeError$2(t1, stackTrace);
          return;
        }
        _this.result._complete$1(computationResult);
      }
    },
    $signature: 0
  };
  A._Completer.prototype = {
    completeError$2(error, stackTrace) {
      var t1;
      A.checkNotNullable(error, "error", type$.Object);
      t1 = this.future;
      if ((t1._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t1._asyncCompleteError$2(error, stackTrace);
    },
    $isCompleter: 1
  };
  A._AsyncCompleter.prototype = {
    complete$1(value) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("1/?")._as(value);
      t2 = this.future;
      if ((t2._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t2._asyncComplete$1(t1._eval$1("1/")._as(value));
    },
    complete$0() {
      return this.complete$1(null);
    }
  };
  A._FutureListener.prototype = {
    matchesErrorTest$1(asyncError) {
      if ((this.state & 15) !== 6)
        return true;
      return this.result._zone.runUnary$2$2(type$.bool_Function_Object._as(this.callback), asyncError.error, type$.bool, type$.Object);
    },
    handleError$1(asyncError) {
      var exception, _this = this,
        errorCallback = _this.errorCallback,
        result = null,
        t1 = type$.dynamic,
        t2 = type$.Object,
        t3 = asyncError.error,
        t4 = _this.result._zone;
      if (type$.dynamic_Function_Object_StackTrace._is(errorCallback))
        result = t4.runBinary$3$3(errorCallback, t3, asyncError.stackTrace, t1, t2, type$.StackTrace);
      else
        result = t4.runUnary$2$2(type$.dynamic_Function_Object._as(errorCallback), t3, t1, t2);
      try {
        t1 = _this.$ti._eval$1("2/")._as(result);
        return t1;
      } catch (exception) {
        if (type$.TypeError._is(A.unwrapException(exception))) {
          if ((_this.state & 1) !== 0)
            throw A.wrapException(A.ArgumentError$("The error handler of Future.then must return a value of the returned future's type", "onError"));
          throw A.wrapException(A.ArgumentError$("The error handler of Future.catchError must return a value of the future's type", "onError"));
        } else
          throw exception;
      }
    }
  };
  A._Future.prototype = {
    _setChained$1(source) {
      this._state = this._state & 1 | 4;
      this._resultOrListeners = source;
    },
    then$1$2$onError(f, onError, $R) {
      var currentZone, result, t2,
        t1 = this.$ti;
      t1._bind$1($R)._eval$1("1/(2)")._as(f);
      currentZone = $.Zone__current;
      if (currentZone === B.C__RootZone) {
        if (onError != null && !type$.dynamic_Function_Object_StackTrace._is(onError) && !type$.dynamic_Function_Object._is(onError))
          throw A.wrapException(A.ArgumentError$value(onError, "onError", string$.Error_));
      } else {
        $R._eval$1("@<0/>")._bind$1(t1._precomputed1)._eval$1("1(2)")._as(f);
        if (onError != null)
          onError = A._registerErrorHandler(onError, currentZone);
      }
      result = new A._Future(currentZone, $R._eval$1("_Future<0>"));
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new A._FutureListener(result, t2, f, onError, t1._eval$1("@<1>")._bind$1($R)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    then$1$1(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    _thenAwait$1$2(f, onError, $E) {
      var result,
        t1 = this.$ti;
      t1._bind$1($E)._eval$1("1/(2)")._as(f);
      result = new A._Future($.Zone__current, $E._eval$1("_Future<0>"));
      this._addListener$1(new A._FutureListener(result, 19, f, onError, t1._eval$1("@<1>")._bind$1($E)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    whenComplete$1(action) {
      var t1, result;
      type$.dynamic_Function._as(action);
      t1 = this.$ti;
      result = new A._Future($.Zone__current, t1);
      this._addListener$1(new A._FutureListener(result, 8, action, null, t1._eval$1("_FutureListener<1,1>")));
      return result;
    },
    _setErrorObject$1(error) {
      this._state = this._state & 1 | 16;
      this._resultOrListeners = error;
    },
    _cloneResult$1(source) {
      this._state = source._state & 30 | this._state & 1;
      this._resultOrListeners = source._resultOrListeners;
    },
    _addListener$1(listener) {
      var source, _this = this,
        t1 = _this._state;
      if (t1 <= 3) {
        listener._nextListener = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listener;
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._addListener$1(listener);
            return;
          }
          _this._cloneResult$1(source);
        }
        A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__addListener_closure(_this, listener)));
      }
    },
    _prependListeners$1(listeners) {
      var t1, existingListeners, next, cursor, next0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 3) {
        existingListeners = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          next = listeners._nextListener;
          for (cursor = listeners; next != null; cursor = next, next = next0)
            next0 = next._nextListener;
          cursor._nextListener = existingListeners;
        }
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._cloneResult$1(source);
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__prependListeners_closure(_box_0, _this)));
      }
    },
    _removeListeners$0() {
      var current = type$.nullable__FutureListener_dynamic_dynamic._as(this._resultOrListeners);
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _chainForeignFuture$1(source) {
      var e, s, exception, _this = this;
      _this._state ^= 2;
      try {
        source.then$1$2$onError(new A._Future__chainForeignFuture_closure(_this), new A._Future__chainForeignFuture_closure0(_this), type$.Null);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A.scheduleMicrotask(new A._Future__chainForeignFuture_closure1(_this, e, s));
      }
    },
    _complete$1(value) {
      var listeners, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value))
        if (t1._is(value))
          A._Future__chainCoreFutureSync(value, _this);
        else
          _this._chainForeignFuture$1(value);
      else {
        listeners = _this._removeListeners$0();
        t1._precomputed1._as(value);
        _this._state = 8;
        _this._resultOrListeners = value;
        A._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1(value) {
      var listeners, _this = this;
      _this.$ti._precomputed1._as(value);
      listeners = _this._removeListeners$0();
      _this._state = 8;
      _this._resultOrListeners = value;
      A._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2(error, stackTrace) {
      var listeners;
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      listeners = this._removeListeners$0();
      this._setErrorObject$1(A.AsyncError$(error, stackTrace));
      A._Future__propagateToListeners(this, listeners);
    },
    _asyncComplete$1(value) {
      var t1 = this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value)) {
        this._chainFuture$1(value);
        return;
      }
      this._asyncCompleteWithValue$1(value);
    },
    _asyncCompleteWithValue$1(value) {
      var _this = this;
      _this.$ti._precomputed1._as(value);
      _this._state ^= 2;
      A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__asyncCompleteWithValue_closure(_this, value)));
    },
    _chainFuture$1(value) {
      var t1 = this.$ti;
      t1._eval$1("Future<1>")._as(value);
      if (t1._is(value)) {
        A._Future__chainCoreFutureAsync(value, this);
        return;
      }
      this._chainForeignFuture$1(value);
    },
    _asyncCompleteError$2(error, stackTrace) {
      type$.StackTrace._as(stackTrace);
      this._state ^= 2;
      A._rootScheduleMicrotask(null, null, this._zone, type$.void_Function._as(new A._Future__asyncCompleteError_closure(this, error, stackTrace)));
    },
    $isFuture: 1
  };
  A._Future__addListener_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this.listener);
    },
    $signature: 0
  };
  A._Future__prependListeners_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    $signature: 0
  };
  A._Future__chainForeignFuture_closure.prototype = {
    call$1(value) {
      var error, stackTrace, exception,
        t1 = this.$this;
      t1._state ^= 2;
      try {
        t1._completeWithValue$1(t1.$ti._precomputed1._as(value));
      } catch (exception) {
        error = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        t1._completeError$2(error, stackTrace);
      }
    },
    $signature: 1
  };
  A._Future__chainForeignFuture_closure0.prototype = {
    call$2(error, stackTrace) {
      this.$this._completeError$2(type$.Object._as(error), type$.StackTrace._as(stackTrace));
    },
    $signature: 5
  };
  A._Future__chainForeignFuture_closure1.prototype = {
    call$0() {
      this.$this._completeError$2(this.e, this.s);
    },
    $signature: 0
  };
  A._Future__chainCoreFutureAsync_closure.prototype = {
    call$0() {
      A._Future__chainCoreFutureSync(this._box_0.source, this.target);
    },
    $signature: 0
  };
  A._Future__asyncCompleteWithValue_closure.prototype = {
    call$0() {
      this.$this._completeWithValue$1(this.value);
    },
    $signature: 0
  };
  A._Future__asyncCompleteError_closure.prototype = {
    call$0() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0() {
      var e, s, t1, exception, t2, originalSource, _this = this, completeResult = null;
      try {
        t1 = _this._box_0.listener;
        completeResult = t1.result._zone.run$1$1(type$.dynamic_Function._as(t1.callback), type$.dynamic);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = _this.hasError && type$.AsyncError._as(_this._box_1.source._resultOrListeners).error === e;
        t2 = _this._box_0;
        if (t1)
          t2.listenerValueOrError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        else
          t2.listenerValueOrError = A.AsyncError$(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (completeResult instanceof A._Future && (completeResult._state & 24) !== 0) {
        if ((completeResult._state & 16) !== 0) {
          t1 = _this._box_0;
          t1.listenerValueOrError = type$.AsyncError._as(completeResult._resultOrListeners);
          t1.listenerHasError = true;
        }
        return;
      }
      if (completeResult instanceof A._Future) {
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new A._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), type$.dynamic);
        t1.listenerHasError = false;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1(_) {
      return this.originalSource;
    },
    $signature: 17
  };
  A._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0() {
      var e, s, t1, t2, t3, t4, t5, exception;
      try {
        t1 = this._box_0;
        t2 = t1.listener;
        t3 = t2.$ti;
        t4 = t3._precomputed1;
        t5 = t4._as(this.sourceResult);
        t1.listenerValueOrError = t2.result._zone.runUnary$2$2(t3._eval$1("2/(1)")._as(t2.callback), t5, t3._eval$1("2/"), t4);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = this._box_0;
        t1.listenerValueOrError = A.AsyncError$(e, s);
        t1.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleError.prototype = {
    call$0() {
      var asyncError, e, s, t1, exception, t2, _this = this;
      try {
        asyncError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        t1 = _this._box_0;
        if (t1.listener.matchesErrorTest$1(asyncError) && t1.listener.errorCallback != null) {
          t1.listenerValueOrError = t1.listener.handleError$1(asyncError);
          t1.listenerHasError = false;
        }
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        t2 = _this._box_0;
        if (t1.error === e)
          t2.listenerValueOrError = t1;
        else
          t2.listenerValueOrError = A.AsyncError$(e, s);
        t2.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._AsyncCallbackEntry.prototype = {};
  A.Stream.prototype = {
    get$length(_) {
      var t1 = {},
        future = new A._Future($.Zone__current, type$._Future_int);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new A.Stream_length_closure(t1, this), true, new A.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    }
  };
  A.Stream_length_closure.prototype = {
    call$1(_) {
      this.$this.$ti._precomputed1._as(_);
      ++this._box_0.count;
    },
    $signature() {
      return this.$this.$ti._eval$1("~(1)");
    }
  };
  A.Stream_length_closure0.prototype = {
    call$0() {
      this.future._complete$1(this._box_0.count);
    },
    $signature: 0
  };
  A._StreamController.prototype = {
    get$_pendingEvents() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(_this._varData);
      t1 = A._instanceType(_this);
      return t1._eval$1("_PendingEvents<1>?")._as(t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData)._varData);
    },
    _ensurePendingEvents$0() {
      var events, t1, state, _this = this;
      if ((_this._state & 8) === 0) {
        events = _this._varData;
        if (events == null)
          events = _this._varData = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
        return A._instanceType(_this)._eval$1("_PendingEvents<1>")._as(events);
      }
      t1 = A._instanceType(_this);
      state = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
      events = state._varData;
      if (events == null)
        events = state._varData = new A._PendingEvents(t1._eval$1("_PendingEvents<1>"));
      return t1._eval$1("_PendingEvents<1>")._as(events);
    },
    get$_subscription() {
      var varData = this._varData;
      if ((this._state & 8) !== 0)
        varData = type$._StreamControllerAddStreamState_nullable_Object._as(varData)._varData;
      return A._instanceType(this)._eval$1("_ControllerSubscription<1>")._as(varData);
    },
    _badEventState$0() {
      if ((this._state & 4) !== 0)
        return new A.StateError("Cannot add event after closing");
      return new A.StateError("Cannot add event while adding a stream");
    },
    addStream$2$cancelOnError(source, cancelOnError) {
      var t2, t3, t4, t5, t6, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("Stream<1>")._as(source);
      t2 = _this._state;
      if (t2 >= 4)
        throw A.wrapException(_this._badEventState$0());
      if ((t2 & 2) !== 0) {
        t1 = new A._Future($.Zone__current, type$._Future_dynamic);
        t1._asyncComplete$1(null);
        return t1;
      }
      t2 = _this._varData;
      t3 = cancelOnError === true;
      t4 = new A._Future($.Zone__current, type$._Future_dynamic);
      t5 = t1._eval$1("~(1)")._as(_this.get$_add());
      t6 = t3 ? A._AddStreamState_makeErrorHandler(_this) : _this.get$_addError();
      t6 = source.listen$4$cancelOnError$onDone$onError(t5, t3, _this.get$_close(), t6);
      t3 = _this._state;
      if ((t3 & 1) !== 0 ? (_this.get$_subscription()._state & 4) !== 0 : (t3 & 2) === 0)
        t6.pause$0();
      _this._varData = new A._StreamControllerAddStreamState(t2, t4, t6, t1._eval$1("_StreamControllerAddStreamState<1>"));
      _this._state |= 8;
      return t4;
    },
    _ensureDoneFuture$0() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new A._Future($.Zone__current, type$._Future_void);
      return t1;
    },
    add$1(_, value) {
      var _this = this;
      A._instanceType(_this)._precomputed1._as(value);
      if (_this._state >= 4)
        throw A.wrapException(_this._badEventState$0());
      _this._add$1(value);
    },
    addError$2(error, stackTrace) {
      A.checkNotNullable(error, "error", type$.Object);
      if (this._state >= 4)
        throw A.wrapException(this._badEventState$0());
      if (stackTrace == null)
        stackTrace = A.AsyncError_defaultStackTrace(error);
      this._addError$2(error, stackTrace);
    },
    close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw A.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, B.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _add$1(value) {
      var t2, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(value);
      t2 = _this._state;
      if ((t2 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t2 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new A._DelayedData(value, t1._eval$1("_DelayedData<1>")));
    },
    _addError$2(error, stackTrace) {
      var t1;
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new A._DelayedError(error, stackTrace));
    },
    _close$0() {
      var _this = this,
        addState = A._instanceType(_this)._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
      _this._varData = addState._varData;
      _this._state &= 4294967287;
      addState.addStreamFuture._asyncComplete$1(null);
    },
    _subscribe$4(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, pendingEvents, addState, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      if ((_this._state & 3) !== 0)
        throw A.wrapException(A.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      type$.$env_1_1_void._bind$1(t1._precomputed1)._eval$1("1(2)")._as(onData);
      t4 = A._BufferingStreamSubscription__registerErrorHandler(t2, onError);
      subscription = new A._ControllerSubscription(_this, onData, t4, type$.void_Function._as(onDone), t2, t3 | 32, t1._eval$1("_ControllerSubscription<1>"));
      pendingEvents = _this.get$_pendingEvents();
      t2 = _this._state |= 1;
      if ((t2 & 8) !== 0) {
        addState = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
        addState._varData = subscription;
        addState.addSubscription.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new A._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1(subscription) {
      var result, onCancel, cancelResult, e, s, exception, result0, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("StreamSubscription<1>")._as(subscription);
      result = null;
      if ((_this._state & 8) !== 0)
        result = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).cancel$0();
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      onCancel = _this.onCancel;
      if (onCancel != null)
        if (result == null)
          try {
            cancelResult = onCancel.call$0();
            if (cancelResult instanceof A._Future)
              result = cancelResult;
          } catch (exception) {
            e = A.unwrapException(exception);
            s = A.getTraceFromException(exception);
            result0 = new A._Future($.Zone__current, type$._Future_void);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(onCancel);
      t1 = new A._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  A._StreamController__subscribe_closure.prototype = {
    call$0() {
      A._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  A._StreamController__recordCancel_complete.prototype = {
    call$0() {
      var doneFuture = this.$this._doneFuture;
      if (doneFuture != null && (doneFuture._state & 30) === 0)
        doneFuture._asyncComplete$1(null);
    },
    $signature: 0
  };
  A._AsyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      var t1 = this.$ti;
      t1._precomputed1._as(data);
      this.get$_subscription()._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<1>")));
    },
    _sendError$2(error, stackTrace) {
      this.get$_subscription()._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _sendDone$0() {
      this.get$_subscription()._addPending$1(B.C__DelayedDone);
    }
  };
  A._AsyncStreamController.prototype = {};
  A._ControllerStream.prototype = {
    get$hashCode(_) {
      return (A.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._ControllerStream && other._controller === this._controller;
    }
  };
  A._ControllerSubscription.prototype = {
    _onCancel$0() {
      return this._controller._recordCancel$1(this);
    },
    _onPause$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).addSubscription.pause$0();
      A._runGuarded(t1.onPause);
    },
    _onResume$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).addSubscription.resume$0();
      A._runGuarded(t1.onResume);
    }
  };
  A._AddStreamState.prototype = {
    cancel$0() {
      var cancel = this.addSubscription.cancel$0();
      return cancel.whenComplete$1(new A._AddStreamState_cancel_closure(this));
    }
  };
  A._AddStreamState_makeErrorHandler_closure.prototype = {
    call$2(e, s) {
      var t1 = this.controller;
      t1._addError$2(type$.Object._as(e), type$.StackTrace._as(s));
      t1._close$0();
    },
    $signature: 5
  };
  A._AddStreamState_cancel_closure.prototype = {
    call$0() {
      this.$this.addStreamFuture._asyncComplete$1(null);
    },
    $signature: 2
  };
  A._StreamControllerAddStreamState.prototype = {};
  A._BufferingStreamSubscription.prototype = {
    _setPendingEvents$1(pendingEvents) {
      var _this = this;
      A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(pendingEvents);
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (pendingEvents.lastPendingEvent != null) {
        _this._state = (_this._state | 128) >>> 0;
        pendingEvents.schedule$1(_this);
      }
    },
    pause$0() {
      var t2, t3, _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 256 | 4) >>> 0;
      _this._state = t2;
      if (t1 < 256) {
        t3 = _this._pending;
        if (t3 != null)
          if (t3._state === 1)
            t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 64) === 0)
        _this._guardCallback$1(_this.get$_onPause());
    },
    resume$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 256) {
        t1 = _this._state = t1 - 256;
        if (t1 < 256)
          if ((t1 & 128) !== 0 && _this._pending.lastPendingEvent != null)
            _this._pending.schedule$1(_this);
          else {
            t1 = (t1 & 4294967291) >>> 0;
            _this._state = t1;
            if ((t1 & 64) === 0)
              _this._guardCallback$1(_this.get$_onResume());
          }
      }
    },
    cancel$0() {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 128) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 64) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _onPause$0() {
    },
    _onResume$0() {
    },
    _onCancel$0() {
      return null;
    },
    _addPending$1($event) {
      var t1, _this = this,
        pending = _this._pending;
      if (pending == null) {
        pending = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
        _this.set$_pending(pending);
      }
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 128) === 0) {
        t1 = (t1 | 128) >>> 0;
        _this._state = t1;
        if (t1 < 256)
          pending.schedule$1(_this);
      }
    },
    _sendData$1(data) {
      var t2, _this = this,
        t1 = A._instanceType(_this)._precomputed1;
      t1._as(data);
      t2 = _this._state;
      _this._state = (t2 | 64) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._onData, data, t1);
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2(error, stackTrace) {
      var cancelFuture, _this = this,
        t1 = _this._state,
        t2 = new A._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        cancelFuture = _this._cancelFuture;
        if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
          cancelFuture.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0() {
      var cancelFuture, _this = this,
        t1 = new A._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      cancelFuture = _this._cancelFuture;
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1(callback) {
      var t1, _this = this;
      type$.void_Function._as(callback);
      t1 = _this._state;
      _this._state = (t1 | 64) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1(wasInputPaused) {
      var t2, isInputPaused, _this = this,
        t1 = _this._state;
      if ((t1 & 128) !== 0 && _this._pending.lastPendingEvent == null) {
        t1 = _this._state = (t1 & 4294967167) >>> 0;
        t2 = false;
        if ((t1 & 4) !== 0)
          if (t1 < 256) {
            t2 = _this._pending;
            t2 = t2 == null ? null : t2.lastPendingEvent == null;
            t2 = t2 !== false;
          }
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          _this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 64) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        t1 = (_this._state & 4294967231) >>> 0;
        _this._state = t1;
      }
      if ((t1 & 128) !== 0 && t1 < 256)
        _this._pending.schedule$1(_this);
    },
    set$_pending(_pending) {
      this._pending = A._instanceType(this)._eval$1("_PendingEvents<1>?")._as(_pending);
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  A._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 64) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = type$.Object;
      t4 = t1._zone;
      if (type$.void_Function_Object_StackTrace._is(onError))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, type$.StackTrace);
      else
        t4.runUnaryGuarded$1$2(type$.void_Function_Object._as(onError), t2, t3);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 74) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return this._controller._subscribe$4(t1._eval$1("~(1)?")._as(onData), onError, onDone, cancelOnError === true);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  A._DelayedEvent.prototype = {
    set$next(next) {
      this.next = type$.nullable__DelayedEvent_dynamic._as(next);
    },
    get$next() {
      return this.next;
    }
  };
  A._DelayedData.prototype = {
    perform$1(dispatch) {
      this.$ti._eval$1("_EventDispatch<1>")._as(dispatch)._sendData$1(this.value);
    }
  };
  A._DelayedError.prototype = {
    perform$1(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  };
  A._DelayedDone.prototype = {
    perform$1(dispatch) {
      dispatch._sendDone$0();
    },
    get$next() {
      return null;
    },
    set$next(_) {
      throw A.wrapException(A.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  };
  A._PendingEvents.prototype = {
    schedule$1(dispatch) {
      var t1, _this = this;
      _this.$ti._eval$1("_EventDispatch<1>")._as(dispatch);
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      A.scheduleMicrotask(new A._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    },
    add$1(_, $event) {
      var _this = this,
        lastEvent = _this.lastPendingEvent;
      if (lastEvent == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        lastEvent.set$next($event);
        _this.lastPendingEvent = $event;
      }
    }
  };
  A._PendingEvents_schedule_closure.prototype = {
    call$0() {
      var t2, $event, nextEvent,
        t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t2 = t1.$ti._eval$1("_EventDispatch<1>")._as(this.dispatch);
      $event = t1.firstPendingEvent;
      nextEvent = $event.get$next();
      t1.firstPendingEvent = nextEvent;
      if (nextEvent == null)
        t1.lastPendingEvent = null;
      $event.perform$1(t2);
    },
    $signature: 0
  };
  A._StreamIterator.prototype = {
    get$current() {
      var _this = this;
      if (_this._async$_hasValue)
        return _this.$ti._precomputed1._as(_this._stateData);
      return _this.$ti._precomputed1._as(null);
    },
    moveNext$0() {
      var future, _this = this,
        subscription = _this._subscription;
      if (subscription != null) {
        if (_this._async$_hasValue) {
          future = new A._Future($.Zone__current, type$._Future_bool);
          _this._stateData = future;
          _this._async$_hasValue = false;
          subscription.resume$0();
          return future;
        }
        throw A.wrapException(A.StateError$("Already waiting for next."));
      }
      return _this._initializeOrDone$0();
    },
    _initializeOrDone$0() {
      var future, subscription, _this = this,
        stateData = _this._stateData;
      if (stateData != null) {
        _this.$ti._eval$1("Stream<1>")._as(stateData);
        future = new A._Future($.Zone__current, type$._Future_bool);
        _this._stateData = future;
        subscription = stateData.listen$4$cancelOnError$onDone$onError(_this.get$_onData(), true, _this.get$_onDone(), _this.get$_onError());
        if (_this._stateData != null)
          _this.set$_subscription(subscription);
        return future;
      }
      return $.$get$Future__falseFuture();
    },
    cancel$0() {
      var _this = this,
        subscription = _this._subscription,
        stateData = _this._stateData;
      _this._stateData = null;
      if (subscription != null) {
        _this.set$_subscription(null);
        if (!_this._async$_hasValue)
          type$._Future_bool._as(stateData)._asyncComplete$1(false);
        else
          _this._async$_hasValue = false;
        return subscription.cancel$0();
      }
      return $.$get$Future__nullFuture();
    },
    _onData$1(data) {
      var moveNextFuture, t1, _this = this;
      _this.$ti._precomputed1._as(data);
      if (_this._subscription == null)
        return;
      moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this._stateData = data;
      _this._async$_hasValue = true;
      moveNextFuture._complete$1(true);
      if (_this._async$_hasValue) {
        t1 = _this._subscription;
        if (t1 != null)
          t1.pause$0();
      }
    },
    _onError$2(error, stackTrace) {
      var subscription, moveNextFuture, _this = this;
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      subscription = _this._subscription;
      moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this.set$_subscription(null);
      _this._stateData = null;
      if (subscription != null)
        moveNextFuture._completeError$2(error, stackTrace);
      else
        moveNextFuture._asyncCompleteError$2(error, stackTrace);
    },
    _onDone$0() {
      var _this = this,
        subscription = _this._subscription,
        moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this.set$_subscription(null);
      _this._stateData = null;
      if (subscription != null)
        moveNextFuture._completeWithValue$1(false);
      else
        moveNextFuture._asyncCompleteWithValue$1(false);
    },
    set$_subscription(_subscription) {
      this._subscription = this.$ti._eval$1("StreamSubscription<1>?")._as(_subscription);
    }
  };
  A._Zone.prototype = {$isZone: 1};
  A._rootHandleError_closure.prototype = {
    call$0() {
      A.Error_throwWithStackTrace(this.error, this.stackTrace);
    },
    $signature: 0
  };
  A._RootZone.prototype = {
    runGuarded$1(f) {
      var e, s, exception;
      type$.void_Function._as(f);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        A._rootRun(null, null, this, f, type$.void);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runUnaryGuarded$1$2(f, arg, $T) {
      var e, s, exception;
      $T._eval$1("~(0)")._as(f);
      $T._as(arg);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        A._rootRunUnary(null, null, this, f, arg, type$.void, $T);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runBinaryGuarded$2$3(f, arg1, arg2, T1, T2) {
      var e, s, exception;
      T1._eval$1("@<0>")._bind$1(T2)._eval$1("~(1,2)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        A._rootRunBinary(null, null, this, f, arg1, arg2, type$.void, T1, T2);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    bindCallbackGuarded$1(f) {
      return new A._RootZone_bindCallbackGuarded_closure(this, type$.void_Function._as(f));
    },
    run$1$1(f, $R) {
      $R._eval$1("0()")._as(f);
      if ($.Zone__current === B.C__RootZone)
        return f.call$0();
      return A._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2(f, arg, $R, $T) {
      $R._eval$1("@<0>")._bind$1($T)._eval$1("1(2)")._as(f);
      $T._as(arg);
      if ($.Zone__current === B.C__RootZone)
        return f.call$1(arg);
      return A._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3(f, arg1, arg2, $R, T1, T2) {
      $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      if ($.Zone__current === B.C__RootZone)
        return f.call$2(arg1, arg2);
      return A._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerBinaryCallback$3$1(f, $R, T1, T2) {
      return $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
    }
  };
  A._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0() {
      return this.$this.runGuarded$1(this.f);
    },
    $signature: 0
  };
  A.ListBase.prototype = {
    get$iterator(receiver) {
      return new A.ListIterator(receiver, this.get$length(receiver), A.instanceType(receiver)._eval$1("ListIterator<ListBase.E>"));
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    }
  };
  A.MapBase.prototype = {
    get$length(_) {
      return this.__js_helper$_length;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    $isMap: 1
  };
  A.MapBase_mapToString_closure.prototype = {
    call$2(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = A.S(k);
      t2 = t1._contents += t2;
      t1._contents = t2 + ": ";
      t2 = A.S(v);
      t1._contents += t2;
    },
    $signature: 18
  };
  A.Duration.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Duration && this._duration === other._duration;
    },
    get$hashCode(_) {
      return B.JSInt_methods.get$hashCode(this._duration);
    },
    toString$0(_) {
      var minutes, minutesPadding, seconds, secondsPadding,
        microseconds = this._duration,
        hours = B.JSInt_methods._tdivFast$1(microseconds, 3600000000);
      microseconds %= 3600000000;
      minutes = B.JSInt_methods._tdivFast$1(microseconds, 60000000);
      microseconds %= 60000000;
      minutesPadding = minutes < 10 ? "0" : "";
      seconds = B.JSInt_methods._tdivFast$1(microseconds, 1000000);
      secondsPadding = seconds < 10 ? "0" : "";
      return "" + hours + ":" + minutesPadding + minutes + ":" + secondsPadding + seconds + "." + B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(microseconds % 1000000), 6, "0");
    }
  };
  A._Enum.prototype = {
    toString$0(_) {
      return this._enumToString$0();
    }
  };
  A.Error.prototype = {
    get$stackTrace() {
      return A.Primitives_extractStackTrace(this);
    }
  };
  A.AssertionError.prototype = {
    toString$0(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Assertion failed: " + A.Error_safeToString(t1);
      return "Assertion failed";
    }
  };
  A.TypeError.prototype = {};
  A.ArgumentError.prototype = {
    get$_errorName() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation() {
      return "";
    },
    toString$0(_) {
      var _this = this,
        $name = _this.name,
        nameString = $name == null ? "" : " (" + $name + ")",
        message = _this.message,
        messageString = message == null ? "" : ": " + message,
        prefix = _this.get$_errorName() + nameString + messageString;
      if (!_this._hasValue)
        return prefix;
      return prefix + _this.get$_errorExplanation() + ": " + A.Error_safeToString(_this.get$invalidValue());
    },
    get$invalidValue() {
      return this.invalidValue;
    }
  };
  A.RangeError.prototype = {
    get$invalidValue() {
      return A._asNumQ(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      var explanation,
        start = this.start,
        end = this.end;
      if (start == null)
        explanation = end != null ? ": Not less than or equal to " + A.S(end) : "";
      else if (end == null)
        explanation = ": Not greater than or equal to " + A.S(start);
      else if (end > start)
        explanation = ": Not in inclusive range " + A.S(start) + ".." + A.S(end);
      else
        explanation = end < start ? ": Valid value range is empty" : ": Only valid value is " + A.S(start);
      return explanation;
    }
  };
  A.IndexError.prototype = {
    get$invalidValue() {
      return A._asInt(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      if (A._asInt(this.invalidValue) < 0)
        return ": index must not be negative";
      var t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length(receiver) {
      return this.length;
    }
  };
  A.UnsupportedError.prototype = {
    toString$0(_) {
      return "Unsupported operation: " + this.message;
    }
  };
  A.UnimplementedError.prototype = {
    toString$0(_) {
      return "UnimplementedError: " + this.message;
    }
  };
  A.StateError.prototype = {
    toString$0(_) {
      return "Bad state: " + this.message;
    }
  };
  A.ConcurrentModificationError.prototype = {
    toString$0(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + A.Error_safeToString(t1) + ".";
    }
  };
  A.OutOfMemoryError.prototype = {
    toString$0(_) {
      return "Out of Memory";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A.StackOverflowError.prototype = {
    toString$0(_) {
      return "Stack Overflow";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A._Exception.prototype = {
    toString$0(_) {
      return "Exception: " + A.S(this.message);
    }
  };
  A.FormatException.prototype = {
    toString$0(_) {
      var message = this.message,
        report = "" !== message ? "FormatException: " + message : "FormatException",
        source = this.source;
      if (source.length > 78)
        source = B.JSString_methods.substring$2(source, 0, 75) + "...";
      return report + "\n" + source;
    }
  };
  A.Null.prototype = {
    get$hashCode(_) {
      return A.Object.prototype.get$hashCode.call(this, 0);
    },
    toString$0(_) {
      return "null";
    }
  };
  A.Object.prototype = {$isObject: 1,
    $eq(_, other) {
      return this === other;
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(this);
    },
    toString$0(_) {
      return "Instance of '" + A.Primitives_objectTypeName(this) + "'";
    },
    get$runtimeType(_) {
      return A.getRuntimeTypeOfDartObject(this);
    },
    toString() {
      return this.toString$0(this);
    }
  };
  A._StringStackTrace.prototype = {
    toString$0(_) {
      return "";
    },
    $isStackTrace: 1
  };
  A.StringBuffer.prototype = {
    get$length(_) {
      return this._contents.length;
    },
    toString$0(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A.LanguageCallableImpl.prototype = {
    arity$0() {
      return this.argCount;
    },
    call$2(interpreter, $arguments) {
      return this.$call$body$LanguageCallableImpl(type$.Interpreter._as(interpreter), type$.List_Object._as($arguments));
    },
    $call$body$LanguageCallableImpl(interpreter, $arguments) {
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.action.call$2(interpreter, $arguments)), $async$call$2, $async$controller);
            case 3:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$2, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    toString$0(_) {
      return this.stringName;
    },
    $isLanguageCallable: 1
  };
  A.LanguageFunction.prototype = {
    bind$1(instance) {
      var t1 = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Object);
      t1.$indexSet(0, "this", instance);
      return new A.LanguageFunction(this.declaration, new A.Environment(this.closure, t1), this.isInitializer);
    },
    call$2(interpreter, $arguments) {
      return this.$call$body$LanguageFunction(type$.Interpreter._as(interpreter), type$.List_Object._as($arguments));
    },
    $call$body$LanguageFunction(interpreter, $arguments) {
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              t1 = $async$self.closure;
              t2 = type$.Object;
              t3 = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, t2);
              for (t4 = $async$self.declaration, t5 = t4.params, t6 = J.getInterceptor$asx($arguments), i = 0; i < t5.length; ++i)
                t3.$indexSet(0, t5[i].lexeme, t2._as(t6.$index($arguments, i)));
              _box_0.returnResult = $.$get$Language_NULL_OBJECT();
              controller = A.StreamController_StreamController(null, null, null, type$.InterpreterInfo);
              interpreter.executeBlock$2(t4.body, new A.Environment(t1, t3)).listen$3$onDone$onError(new A.LanguageFunction_call_closure(controller), new A.LanguageFunction_call_closure0(controller), new A.LanguageFunction_call_closure1(_box_0, controller));
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar(new A._ControllerStream(controller, A._instanceType(controller)._eval$1("_ControllerStream<1>"))), $async$call$2, $async$controller);
            case 3:
              // after yield
              t2 = type$._Future_dynamic;
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = $async$self.isInitializer ? 4 : 6;
              break;
            case 4:
              // then
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_3, t1.getAt$2(0, "this"), null, new A._AsyncCompleter(new A._Future($.Zone__current, t2), t3))), $async$call$2, $async$controller);
            case 7:
              // after yield
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_3, _box_0.returnResult, null, new A._AsyncCompleter(new A._Future($.Zone__current, t2), t3))), $async$call$2, $async$controller);
            case 8:
              // after yield
            case 5:
              // join
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$2, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t4, t5, t6, i, controller, _box_0, t1, t2, t3;
      return A._streamOfController($async$controller);
    },
    arity$0() {
      return this.declaration.params.length;
    },
    toString$0(_) {
      return "<fn " + this.declaration.name.lexeme + ">";
    },
    $isLanguageCallable: 1
  };
  A.LanguageFunction_call_closure.prototype = {
    call$1(item) {
      this.controller.add$1(0, type$.InterpreterInfo._as(item));
    },
    $signature: 7
  };
  A.LanguageFunction_call_closure1.prototype = {
    call$1(error) {
      if (error instanceof A.Return)
        this._box_0.returnResult = error.value;
      this.controller.close$0();
    },
    $signature: 1
  };
  A.LanguageFunction_call_closure0.prototype = {
    call$0() {
      this.controller.close$0();
    },
    $signature: 0
  };
  A.LanguageClass.prototype = {
    call$2(interpreter, $arguments) {
      return this.$call$body$LanguageClass(type$.Interpreter._as(interpreter), type$.List_Object._as($arguments));
    },
    $call$body$LanguageClass(interpreter, $arguments) {
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              instance = new A.LanguageInstance($async$self, A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Object));
              initializer = $async$self.findMethod$1("init");
              if (initializer != null)
                initializer.bind$1(instance).call$2(interpreter, $arguments);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_3, instance, null, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic))), $async$call$2, $async$controller);
            case 3:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$2, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, instance, initializer;
      return A._streamOfController($async$controller);
    },
    arity$0() {
      var initializer = this.findMethod$1("init");
      if (initializer == null)
        return 0;
      return initializer.declaration.params.length;
    },
    toString$0(_) {
      return this.name;
    },
    findMethod$1($name) {
      var t1 = this.methods;
      if (t1.containsKey$1($name))
        return t1.$index(0, $name);
      t1 = this.superClass;
      if (t1 != null)
        return t1.findMethod$1($name);
      return null;
    },
    $isLanguageCallable: 1
  };
  A.LanguageInstance.prototype = {
    $get$1($name) {
      var method,
        t1 = this.fields,
        t2 = $name.lexeme;
      if (t1.containsKey$1(t2)) {
        t1 = t1.$index(0, t2);
        return t1 == null ? $.$get$Language_NULL_OBJECT() : t1;
      }
      method = this.klass.findMethod$1(t2);
      if (method != null)
        return method.bind$1(this);
      throw A.wrapException(A.ParserRuntimeError$("Undefined property '" + t2 + "'.", $name));
    },
    toString$0(_) {
      return this.klass.name + " instance";
    }
  };
  A.Environment.prototype = {
    assign$2($name, value) {
      var t1 = this.values,
        t2 = $name.lexeme;
      if (t1.containsKey$1(t2)) {
        t1.$indexSet(0, t2, value);
        return;
      }
      t1 = this.enclosing;
      if (t1 != null) {
        t1.assign$2($name, value);
        return;
      }
      throw A.wrapException(A.ParserRuntimeError$("-Undefined variable '" + t2 + "'.", $name));
    },
    $get$1($name) {
      var t1 = this.values,
        t2 = $name.lexeme;
      if (t1.containsKey$1(t2)) {
        t1 = t1.$index(0, t2);
        return t1 == null ? $.$get$Language_NULL_OBJECT() : t1;
      }
      t1 = this.enclosing;
      if (t1 != null)
        return t1.$get$1($name);
      throw A.wrapException(A.ParserRuntimeError$("Undefined variable '" + t2 + "'", $name));
    },
    getAt$2(distance, $name) {
      var t1 = this.ancestor$1(distance).values.$index(0, $name);
      return t1 == null ? $.$get$Language_NULL_OBJECT() : t1;
    },
    ancestor$1(distance) {
      var environment, i, environment0;
      for (environment = this, i = 0; i < distance; ++i, environment = environment0) {
        environment0 = environment.enclosing;
        if (environment0 == null)
          break;
      }
      return environment;
    }
  };
  A.ParseError.prototype = {
    toString$0(_) {
      return this.cause;
    }
  };
  A.ParserRuntimeError.prototype = {
    toString$0(_) {
      return "__ " + this.token.toString$0(0) + " __";
    }
  };
  A.Return.prototype = {
    toString$0(_) {
      return A.S(this.value);
    }
  };
  A.ExpressionResultX.prototype = {};
  A.StmtState.prototype = {};
  A.Expr.prototype = {};
  A.ExprNull.prototype = {};
  A.ExprAssign.prototype = {};
  A.ExprBinary.prototype = {};
  A.ExprCall.prototype = {};
  A.ExprGet.prototype = {};
  A.ExprGrouping.prototype = {};
  A.ExprLiteral.prototype = {};
  A.ExprLogical.prototype = {};
  A.ExprSet.prototype = {};
  A.ExprSuper.prototype = {};
  A.ExprThis.prototype = {};
  A.ExprUnary.prototype = {};
  A.ExprVariable.prototype = {};
  A.Stmt.prototype = {};
  A.StmtNull.prototype = {};
  A.StmtBlock.prototype = {};
  A.StmtClass.prototype = {};
  A.StmtExpression.prototype = {};
  A.StmtFunction.prototype = {};
  A.StmtIf.prototype = {};
  A.StmtPrint.prototype = {};
  A.StmtReturn.prototype = {};
  A.StmtVar.prototype = {};
  A.StmtWhile.prototype = {};
  A.InterpreterInfoType.prototype = {
    _enumToString$0() {
      return "InterpreterInfoType." + this._name;
    }
  };
  A.InterpreterInfo.prototype = {};
  A.Interpreter.prototype = {
    Interpreter$0() {
      var t1 = this.globals;
      this.__Interpreter_environment_A = t1;
      t1.values.$indexSet(0, "clock", new A.LanguageCallableImpl(0, new A.Interpreter_closure(), "<native fn>"));
    },
    _wrapExpression$2(expression, message) {
      expression.result = new A.ExpressionResultX();
      return new A.InterpreterInfo(B.InterpreterInfoType_2, null, null, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
    },
    _wrapExprResult$3(expression, object, message) {
      expression.result = new A.ExpressionResultX();
      return new A.InterpreterInfo(B.InterpreterInfoType_3, object, null, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
    },
    interpret$1(statements) {
      return this.interpret$body$Interpreter(type$.List_Stmt._as(statements));
    },
    interpret$body$Interpreter(statements) {
      var $async$interpret$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_0, null, null, new A._AsyncCompleter(t2, t3))), $async$interpret$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$interpret$1, $async$controller);
            case 4:
              // returning from await.
              $async$handler = 6;
              t2 = statements.length, t4 = type$._StreamIterator_InterpreterInfo, _i = 0;
            case 9:
              // for condition
              if (!(_i < statements.length)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              statement = statements[_i];
              statement.state = new A.StmtState();
              t5 = $async$self.execute$1(statement);
              t5 = new A._StreamIterator(t5, t4);
              $async$handler = 12;
            case 15:
              // for condition
              $async$temp1 = A;
              $async$goto = 17;
              return A._asyncStarHelper(t5.moveNext$0(), $async$interpret$1, $async$controller);
            case 17:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              item = t5.get$current();
              yyy = item;
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 13];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$interpret$1, $async$controller);
            case 18:
              // after yield
              $async$goto = 19;
              return A._asyncStarHelper(yyy.completer.future, $async$interpret$1, $async$controller);
            case 19:
              // returning from await.
              statement.state = new A.StmtState();
              // goto for condition
              $async$goto = 15;
              break;
            case 16:
              // after for
              $async$next.push(14);
              // goto finally
              $async$goto = 13;
              break;
            case 12:
              // uncaught
              $async$next = [6];
            case 13:
              // finally
              $async$handler = 6;
              $async$goto = 20;
              return A._asyncStarHelper(t5.cancel$0(), $async$interpret$1, $async$controller);
            case 20:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 14:
              // after finally
              statement.state = new A.StmtState();
            case 10:
              // for update
              statements.length === t2 || (0, A.throwConcurrentModificationError)(statements), ++_i;
              // goto for condition
              $async$goto = 9;
              break;
            case 11:
              // after for
              $async$handler = 2;
              // goto after finally
              $async$goto = 8;
              break;
            case 6:
              // catch
              $async$handler = 5;
              $async$exception = $async$currentError;
              t2 = A.unwrapException($async$exception);
              $async$goto = t2 instanceof A.ParserRuntimeError ? 21 : 23;
              break;
            case 21:
              // then
              e = t2;
              t2 = e;
              t4 = t2.token;
              yyy0 = new A.InterpreterInfo(B.InterpreterInfoType_5, null, "[line " + t4.line + "]: " + t2.cause, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(type$.InterpreterInfo._as(yyy0)), $async$interpret$1, $async$controller);
            case 24:
              // after yield
              t1 = yyy0.completer;
              $async$goto = 25;
              return A._asyncStarHelper(t1.future, $async$interpret$1, $async$controller);
            case 25:
              // returning from await.
              // goto join
              $async$goto = 22;
              break;
            case 23:
              // else
              e0 = t2;
              s = A.getTraceFromException($async$exception);
              yyy1 = new A.InterpreterInfo(B.InterpreterInfoType_5, null, "[line " + -1 + "] Error: " + ("::: " + A.S(e0) + "\n" + A.S(s)), new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 26;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(type$.InterpreterInfo._as(yyy1)), $async$interpret$1, $async$controller);
            case 26:
              // after yield
              t1 = yyy1.completer;
              $async$goto = 27;
              return A._asyncStarHelper(t1.future, $async$interpret$1, $async$controller);
            case 27:
              // returning from await.
            case 22:
              // join
              // goto after finally
              $async$goto = 8;
              break;
            case 5:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 8:
              // after finally
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$interpret$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, statement, item, yyy, e, yyy0, e0, s, yyy1, t4, _i, t5, exception, t1, t2, t3, $async$exception, $async$temp1;
      return A._streamOfController($async$controller);
    },
    execute$1(stmt) {
      var $async$execute$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $label0$0: {
                if (stmt instanceof A.StmtVar) {
                  stream = $async$self.visitVarStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtWhile) {
                  stream = $async$self.visitWhileStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtBlock) {
                  stream = $async$self.visitBlockStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtClass) {
                  stream = $async$self.visitClassStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtExpression) {
                  stream = $async$self.visitExpressionStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtFunction) {
                  stream = $async$self.visitFunctionStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtIf) {
                  stream = $async$self.visitIfStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtPrint) {
                  stream = $async$self.visitPrintStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtReturn) {
                  stream = $async$self.visitReturnStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtNull) {
                  stream = $async$self.visitNullStmt$1(stmt);
                  break $label0$0;
                }
                stream = null;
              }
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar(stream), $async$execute$1, $async$controller);
            case 3:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$execute$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stream;
      return A._streamOfController($async$controller);
    },
    evaluate$1(expr) {
      var $async$evaluate$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $label0$0: {
                if (expr instanceof A.ExprLiteral) {
                  stream = $async$self.visitLiteralExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprBinary) {
                  stream = $async$self.visitBinaryExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprVariable) {
                  stream = $async$self.visitVariableExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprAssign) {
                  stream = $async$self.visitAssignExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprCall) {
                  stream = $async$self.visitCallExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprGet) {
                  stream = $async$self.visitGetExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprGrouping) {
                  stream = $async$self.visitGroupingExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprLogical) {
                  stream = $async$self.visitLogicalExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprSet) {
                  stream = $async$self.visitSetExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprThis) {
                  stream = $async$self.visitThisExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprSuper) {
                  stream = $async$self.visitSuperExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprUnary) {
                  stream = $async$self.visitUnaryExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprNull) {
                  stream = $async$self.visitNullExpr$1(expr);
                  break $label0$0;
                }
                stream = null;
              }
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar(stream), $async$evaluate$1, $async$controller);
            case 3:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$evaluate$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stream;
      return A._streamOfController($async$controller);
    },
    lookUpVariable$2($name, expr) {
      var t1,
        distance = this.locals.$index(0, expr);
      if (distance != null) {
        t1 = this.__Interpreter_environment_A;
        t1 === $ && A.throwLateFieldNI("environment");
        return t1.getAt$2(distance, $name.lexeme);
      } else
        return this.globals.$get$1($name);
    },
    stringify$1(object) {
      var text;
      if (typeof object == "number") {
        text = B.JSNumber_methods.toString$0(object);
        return B.JSString_methods.endsWith$1(text, ".0") ? B.JSString_methods.substring$2(text, 0, text.length - 2) : text;
      }
      return J.toString$0$(object);
    },
    isTruthy$1(object) {
      if (A._isBool(object))
        return object;
      return true;
    },
    isEqual$2(a, b) {
      return J.$eq$(a, b);
    },
    checkNumberOperand$2(op, operand) {
      if (typeof operand == "number")
        return;
      throw A.wrapException(A.Exception_Exception("Operand must ebe a number"));
    },
    checkNumberOperands$3(op, left, right) {
      if (typeof left == "number" && typeof right == "number")
        return;
      throw A.wrapException(A.Exception_Exception("Operands must be numbers"));
    },
    visitExpressionStmt$1(stmt) {
      return this.visitExpressionStmt$body$Interpreter(type$.StmtExpression._as(stmt));
    },
    visitExpressionStmt$body$Interpreter(stmt) {
      var $async$visitExpressionStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitExpressionStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitExpressionStmt$1, $async$controller);
            case 4:
              // returning from await.
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.evaluate$1(stmt.expression)), $async$visitExpressionStmt$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitExpressionStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitNullStmt$1(stmt) {
      return this.visitNullStmt$body$Interpreter(type$.StmtNull._as(stmt));
    },
    visitNullStmt$body$Interpreter(stmt) {
      var $async$visitNullStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t2, t3))), $async$visitNullStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$visitNullStmt$1, $async$controller);
            case 4:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_4, null, "Null statement: " + stmt.reason, new A._AsyncCompleter(t1, t3))), $async$visitNullStmt$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(t1, $async$visitNullStmt$1, $async$controller);
            case 6:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitNullStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], t1, t2, t3;
      return A._streamOfController($async$controller);
    },
    visitPrintStmt$1(stmt) {
      return this.visitPrintStmt$body$Interpreter(type$.StmtPrint._as(stmt));
    },
    visitPrintStmt$body$Interpreter(stmt) {
      var $async$visitPrintStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t2, t3))), $async$visitPrintStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$visitPrintStmt$1, $async$controller);
            case 4:
              // returning from await.
              value = $.$get$Language_NULL_OBJECT();
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(stmt.expression), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t2.moveNext$0(), $async$visitPrintStmt$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t2.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                value = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitPrintStmt$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitPrintStmt$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t2.cancel$0(), $async$visitPrintStmt$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t2 = $async$self.stringify$1(value);
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 14;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_4, null, t2, new A._AsyncCompleter(t1, t3))), $async$visitPrintStmt$1, $async$controller);
            case 14:
              // after yield
              $async$goto = 15;
              return A._asyncStarHelper(t1, $async$visitPrintStmt$1, $async$controller);
            case 15:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitPrintStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, item, yyy, t4, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitVarStmt$1(stmt) {
      return this.visitVarStmt$body$Interpreter(type$.StmtVar._as(stmt));
    },
    visitVarStmt$body$Interpreter(stmt) {
      var $async$visitVarStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitVarStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitVarStmt$1, $async$controller);
            case 4:
              // returning from await.
              value = $.$get$Language_NULL_OBJECT();
              t1 = type$.Object;
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(stmt.initializer), "stream", t1), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t2.moveNext$0(), $async$visitVarStmt$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t2.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t3 = item.object;
                t3.toString;
                value = t3;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitVarStmt$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitVarStmt$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t2.cancel$0(), $async$visitVarStmt$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t2 = $async$self.__Interpreter_environment_A;
              t2 === $ && A.throwLateFieldNI("environment");
              t2.values.$indexSet(0, stmt.name.lexeme, t1._as(value));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitVarStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, item, yyy, t2, t3, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitBlockStmt$1(stmt) {
      return this.visitBlockStmt$body$Interpreter(type$.StmtBlock._as(stmt));
    },
    visitBlockStmt$body$Interpreter(stmt) {
      var $async$visitBlockStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitBlockStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitBlockStmt$1, $async$controller);
            case 4:
              // returning from await.
              t1 = $async$self.__Interpreter_environment_A;
              t1 === $ && A.throwLateFieldNI("environment");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.executeBlock$2(stmt.statements, new A.Environment(t1, A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Object)))), $async$visitBlockStmt$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitBlockStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitFunctionStmt$1(stmt) {
      return this.visitFunctionStmt$body$Interpreter(type$.StmtFunction._as(stmt));
    },
    visitFunctionStmt$body$Interpreter(stmt) {
      var $async$visitFunctionStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitFunctionStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitFunctionStmt$1, $async$controller);
            case 4:
              // returning from await.
              t1 = $async$self.__Interpreter_environment_A;
              t1 === $ && A.throwLateFieldNI("environment");
              t1.values.$indexSet(0, stmt.name.lexeme, new A.LanguageFunction(stmt, t1, false));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitFunctionStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    executeBlock$2(statements, environment) {
      return this.executeBlock$body$Interpreter(type$.List_Stmt._as(statements), environment);
    },
    executeBlock$body$Interpreter(statements, environment) {
      var $async$executeBlock$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.__Interpreter_environment_A;
              t1 === $ && A.throwLateFieldNI("environment");
              previous = t1;
              $async$handler = 4;
              $async$self.__Interpreter_environment_A = environment;
              t1 = statements.length, t2 = type$.nullable_void_Function, t3 = type$._AsyncStreamController_InterpreterInfo, _i = 0;
            case 7:
              // for condition
              if (!(_i < statements.length)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              statement = statements[_i];
              statement.toString;
              controller = new A._AsyncStreamController(null, null, null, null, t3);
              t4 = $async$self.execute$1(statement);
              t5 = t4.$ti;
              t6 = t5._eval$1("~(1)?")._as(new A.Interpreter_executeBlock_closure(controller, statement));
              t7 = t2._as(new A.Interpreter_executeBlock_closure0(controller));
              t4._controller._subscribe$4(t5._eval$1("~(1)?")._as(t6), new A.Interpreter_executeBlock_closure1(controller), t7, false);
              t4 = controller;
              $async$goto = 10;
              $async$nextWhenCanceled = [1, 5];
              return A._asyncStarHelper(A._IterationMarker_yieldStar(new A._ControllerStream(t4, A._instanceType(t4)._eval$1("_ControllerStream<1>"))), $async$executeBlock$2, $async$controller);
            case 10:
              // after yield
            case 8:
              // for update
              statements.length === t1 || (0, A.throwConcurrentModificationError)(statements), ++_i;
              // goto for condition
              $async$goto = 7;
              break;
            case 9:
              // after for
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              $async$self.__Interpreter_environment_A = type$.Environment._as(previous);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$executeBlock$2, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, previous, statement, controller, t2, t3, _i, t4, t5, t6, t7, exception, t1, $async$exception;
      return A._streamOfController($async$controller);
    },
    visitIfStmt$1(stmt) {
      return this.visitIfStmt$body$Interpreter(type$.StmtIf._as(stmt));
    },
    visitIfStmt$body$Interpreter(stmt) {
      var $async$visitIfStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitIfStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitIfStmt$1, $async$controller);
            case 4:
              // returning from await.
              condition = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(stmt.condition), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitIfStmt$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                condition = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitIfStmt$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitIfStmt$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitIfStmt$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              $async$goto = $async$self.isTruthy$1(condition) ? 14 : 16;
              break;
            case 14:
              // then
              $async$goto = 17;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.execute$1(stmt.thenBranch)), $async$visitIfStmt$1, $async$controller);
            case 17:
              // after yield
              // goto join
              $async$goto = 15;
              break;
            case 16:
              // else
              t1 = stmt.elseBranch;
              $async$goto = !(t1 instanceof A.StmtNull) ? 18 : 19;
              break;
            case 18:
              // then
              $async$goto = 20;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.execute$1(t1)), $async$visitIfStmt$1, $async$controller);
            case 20:
              // after yield
            case 19:
              // join
            case 15:
              // join
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitIfStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, condition, item, yyy, t2, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitWhileStmt$1(stmt) {
      return this.visitWhileStmt$body$Interpreter(type$.StmtWhile._as(stmt));
    },
    visitWhileStmt$body$Interpreter(stmt) {
      var $async$visitWhileStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitWhileStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitWhileStmt$1, $async$controller);
            case 4:
              // returning from await.
              condition = $.$get$Language_NULL_OBJECT();
              t1 = stmt.condition;
              t2 = type$._StreamIterator_InterpreterInfo;
              t3 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(t1), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t3.moveNext$0(), $async$visitWhileStmt$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t3.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                condition = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitWhileStmt$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitWhileStmt$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t3.cancel$0(), $async$visitWhileStmt$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t3 = stmt.body;
            case 14:
              // for condition
              if (!$async$self.isTruthy$1(condition)) {
                // goto after for
                $async$goto = 15;
                break;
              }
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.execute$1(t3)), $async$visitWhileStmt$1, $async$controller);
            case 16:
              // after yield
              t4 = $async$self.evaluate$1(t1);
              t4 = new A._StreamIterator(t4, t2);
              $async$handler = 17;
            case 20:
              // for condition
              $async$temp1 = A;
              $async$goto = 22;
              return A._asyncStarHelper(t4.moveNext$0(), $async$visitWhileStmt$1, $async$controller);
            case 22:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 21;
                break;
              }
              item0 = t4.get$current();
              if (item0.type === B.InterpreterInfoType_3) {
                t5 = item0.object;
                t5.toString;
                condition = t5;
              }
              yyy0 = item0;
              $async$goto = 23;
              $async$nextWhenCanceled = [1, 18];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitWhileStmt$1, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitWhileStmt$1, $async$controller);
            case 24:
              // returning from await.
              // goto for condition
              $async$goto = 20;
              break;
            case 21:
              // after for
              $async$next.push(19);
              // goto finally
              $async$goto = 18;
              break;
            case 17:
              // uncaught
              $async$next = [2];
            case 18:
              // finally
              $async$handler = 2;
              $async$goto = 25;
              return A._asyncStarHelper(t4.cancel$0(), $async$visitWhileStmt$1, $async$controller);
            case 25:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 19:
              // after finally
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitWhileStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, condition, item, yyy, item0, yyy0, t2, t3, t4, t5, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitReturnStmt$1(stmt) {
      return this.visitReturnStmt$body$Interpreter(type$.StmtReturn._as(stmt));
    },
    visitReturnStmt$body$Interpreter(stmt) {
      var $async$visitReturnStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$visitReturnStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t1, $async$visitReturnStmt$1, $async$controller);
            case 4:
              // returning from await.
              value = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(stmt.value), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitReturnStmt$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                value = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitReturnStmt$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitReturnStmt$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitReturnStmt$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              throw A.wrapException(new A.Return(value));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitReturnStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, item, yyy, t2, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitClassStmt$1(stmt) {
      return this.visitClassStmt$body$Interpreter(type$.StmtClass._as(stmt));
    },
    visitClassStmt$body$Interpreter(stmt) {
      var $async$visitClassStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t2, t3))), $async$visitClassStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$visitClassStmt$1, $async$controller);
            case 4:
              // returning from await.
              t2 = stmt.superClass;
              t4 = t2 != null;
              $async$goto = t4 ? 5 : 7;
              break;
            case 5:
              // then
              obj = $.$get$Language_NULL_OBJECT();
              t5 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(t2), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 8;
            case 11:
              // for condition
              $async$temp1 = A;
              $async$goto = 13;
              return A._asyncStarHelper(t5.moveNext$0(), $async$visitClassStmt$1, $async$controller);
            case 13:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 12;
                break;
              }
              item = t5.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t6 = item.object;
                t6.toString;
                obj = t6;
              }
              yyy = item;
              $async$goto = 14;
              $async$nextWhenCanceled = [1, 9];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitClassStmt$1, $async$controller);
            case 14:
              // after yield
              $async$goto = 15;
              return A._asyncStarHelper(yyy.completer.future, $async$visitClassStmt$1, $async$controller);
            case 15:
              // returning from await.
              // goto for condition
              $async$goto = 11;
              break;
            case 12:
              // after for
              $async$next.push(10);
              // goto finally
              $async$goto = 9;
              break;
            case 8:
              // uncaught
              $async$next = [2];
            case 9:
              // finally
              $async$handler = 2;
              $async$goto = 16;
              return A._asyncStarHelper(t5.cancel$0(), $async$visitClassStmt$1, $async$controller);
            case 16:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 10:
              // after finally
              $async$goto = !(obj instanceof A.LanguageClass) ? 17 : 18;
              break;
            case 17:
              // then
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_4, null, "null", new A._AsyncCompleter(t1, t3))), $async$visitClassStmt$1, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(t1, $async$visitClassStmt$1, $async$controller);
            case 20:
              // returning from await.
              throw A.wrapException(A.ParserRuntimeError$("Superclass must be a class.", t2.name));
            case 18:
              // join
              superClass = obj;
              // goto join
              $async$goto = 6;
              break;
            case 7:
              // else
              superClass = null;
            case 6:
              // join
              t2 = $async$self.__Interpreter_environment_A;
              t2 === $ && A.throwLateFieldNI("environment");
              t5 = stmt.name;
              t6 = t5.lexeme;
              t2.values.$indexSet(0, t6, $.$get$Language_NULL_OBJECT());
              $async$goto = t4 ? 21 : 22;
              break;
            case 21:
              // then
              t2 = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Object);
              $async$self.__Interpreter_environment_A = new A.Environment($async$self.__Interpreter_environment_A, t2);
              superClass.toString;
              t2.$indexSet(0, "super", superClass);
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 23;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_1, null, null, new A._AsyncCompleter(t1, t3))), $async$visitClassStmt$1, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(t1, $async$visitClassStmt$1, $async$controller);
            case 24:
              // returning from await.
            case 22:
              // join
              methods = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.LanguageFunction);
              for (t1 = stmt.methods, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
                method = t1[_i];
                t3 = $async$self.__Interpreter_environment_A;
                t4 = method.name.lexeme;
                methods.$indexSet(0, t4, new A.LanguageFunction(method, t3, t4 === "init"));
              }
              if (superClass != null) {
                t1 = $async$self.__Interpreter_environment_A.enclosing;
                t1.toString;
                $async$self.__Interpreter_environment_A = t1;
              }
              $async$self.__Interpreter_environment_A.assign$2(t5, new A.LanguageClass(t6, superClass, methods));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitClassStmt$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, obj, item, yyy, t4, t5, t6, superClass, methods, _i, method, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitGetExpr$1(expr) {
      return this.visitGetExpr$body$Interpreter(type$.ExprGet._as(expr));
    },
    visitGetExpr$body$Interpreter(expr) {
      var $async$visitGetExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy0 = $async$self._wrapExpression$2(expr, "evaluate: visitGetExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitGetExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitGetExpr$1, $async$controller);
            case 4:
              // returning from await.
              object = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.object), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitGetExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                object = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitGetExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitGetExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitGetExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t1 = expr.name;
              $async$goto = object instanceof A.LanguageInstance ? 14 : 16;
              break;
            case 14:
              // then
              yyy = $async$self._wrapExprResult$3(expr, object.$get$1(t1), "Expr result");
              $async$goto = 17;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitGetExpr$1, $async$controller);
            case 17:
              // after yield
              $async$goto = 18;
              return A._asyncStarHelper(yyy.completer.future, $async$visitGetExpr$1, $async$controller);
            case 18:
              // returning from await.
              // goto join
              $async$goto = 15;
              break;
            case 16:
              // else
              throw A.wrapException(A.ParserRuntimeError$("Only instances have properties.", t1));
            case 15:
              // join
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitGetExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, object, item, yyy, t1, t2, yyy0, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitSetExpr$1(expr) {
      return this.visitSetExpr$body$Interpreter(type$.ExprSet._as(expr));
    },
    visitSetExpr$body$Interpreter(expr) {
      var $async$visitSetExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy1 = $async$self._wrapExpression$2(expr, "evaluate: visitSetExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$visitSetExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy1.completer.future, $async$visitSetExpr$1, $async$controller);
            case 4:
              // returning from await.
              object = A._Cell$named("object");
              t1 = type$.Object;
              t2 = type$._StreamIterator_InterpreterInfo;
              t3 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.object), "stream", t1), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t3.moveNext$0(), $async$visitSetExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t3.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                object._value = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitSetExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitSetExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t3.cancel$0(), $async$visitSetExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              if (!(object._readLocal$0() instanceof A.LanguageInstance))
                throw A.wrapException(A.ParserRuntimeError$("Only instances have fields.", expr.name));
              value = $.$get$Language_NULL_OBJECT();
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.value), "stream", t1), t2);
              $async$handler = 14;
            case 17:
              // for condition
              $async$temp1 = A;
              $async$goto = 19;
              return A._asyncStarHelper(t2.moveNext$0(), $async$visitSetExpr$1, $async$controller);
            case 19:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 18;
                break;
              }
              item0 = t2.get$current();
              if (item0.type === B.InterpreterInfoType_3) {
                t3 = item0.object;
                t3.toString;
                value = t3;
              }
              yyy0 = item0;
              $async$goto = 20;
              $async$nextWhenCanceled = [1, 15];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitSetExpr$1, $async$controller);
            case 20:
              // after yield
              $async$goto = 21;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitSetExpr$1, $async$controller);
            case 21:
              // returning from await.
              // goto for condition
              $async$goto = 17;
              break;
            case 18:
              // after for
              $async$next.push(16);
              // goto finally
              $async$goto = 15;
              break;
            case 14:
              // uncaught
              $async$next = [2];
            case 15:
              // finally
              $async$handler = 2;
              $async$goto = 22;
              return A._asyncStarHelper(t2.cancel$0(), $async$visitSetExpr$1, $async$controller);
            case 22:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 16:
              // after finally
              t2 = object._readLocal$0();
              t1 = t1._as(value);
              t2.fields.$indexSet(0, expr.name.lexeme, t1);
              yyy2 = $async$self._wrapExprResult$3(expr, value, "Expr result");
              $async$goto = 23;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitSetExpr$1, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitSetExpr$1, $async$controller);
            case 24:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitSetExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, object, item, yyy, value, item0, yyy0, t1, t2, t3, t4, yyy2, yyy1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitSuperExpr$1(expr) {
      return this.visitSuperExpr$body$Interpreter(type$.ExprSuper._as(expr));
    },
    visitSuperExpr$body$Interpreter(expr) {
      var $async$visitSuperExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy = $async$self._wrapExpression$2(expr, "evaluate: visitSuperExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitSuperExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy.completer.future, $async$visitSuperExpr$1, $async$controller);
            case 4:
              // returning from await.
              distance = $async$self.locals.$index(0, expr);
              if (distance == null)
                distance = -1;
              t1 = $async$self.__Interpreter_environment_A;
              t1 === $ && A.throwLateFieldNI("environment");
              superClass = type$.LanguageClass._as(t1.getAt$2(distance, "super"));
              object = type$.LanguageInstance._as($async$self.__Interpreter_environment_A.getAt$2(distance - 1, "this"));
              t1 = expr.method;
              method = superClass.findMethod$1(t1.lexeme);
              if (method == null)
                throw A.wrapException(A.ParserRuntimeError$("Undefined property", t1));
              yyy2 = $async$self._wrapExprResult$3(expr, method.bind$1(object), "Expr result");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitSuperExpr$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitSuperExpr$1, $async$controller);
            case 6:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitSuperExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, distance, t1, superClass, object, method, yyy2, yyy;
      return A._streamOfController($async$controller);
    },
    visitThisExpr$1(expr) {
      return this.visitThisExpr$body$Interpreter(type$.ExprThis._as(expr));
    },
    visitThisExpr$body$Interpreter(expr) {
      var $async$visitThisExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy = $async$self._wrapExpression$2(expr, "evaluate: visitThisExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitThisExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy.completer.future, $async$visitThisExpr$1, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapExprResult$3(expr, $async$self.lookUpVariable$2(expr.keyword, expr), "Expr result");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitThisExpr$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitThisExpr$1, $async$controller);
            case 6:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitThisExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, yyy2, yyy;
      return A._streamOfController($async$controller);
    },
    visitLogicalExpr$1(expr) {
      return this.visitLogicalExpr$body$Interpreter(type$.ExprLogical._as(expr));
    },
    visitLogicalExpr$body$Interpreter(expr) {
      var $async$visitLogicalExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy1 = $async$self._wrapExpression$2(expr, "evaluate: visitLogicalExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$visitLogicalExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy1.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 4:
              // returning from await.
              left = A._Cell$named("left");
              t1 = type$.Object;
              t2 = type$._StreamIterator_InterpreterInfo;
              t3 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.left), "stream", t1), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t3.moveNext$0(), $async$visitLogicalExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t3.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                left._value = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitLogicalExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t3.cancel$0(), $async$visitLogicalExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t3 = expr.op.type;
              $async$goto = t3 === B.TokenType_30 ? 14 : 16;
              break;
            case 14:
              // then
              $async$goto = $async$self.isTruthy$1(left._readLocal$0()) ? 17 : 18;
              break;
            case 17:
              // then
              yyy = $async$self._wrapExprResult$3(expr, left._readLocal$0(), "Expr result");
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitLogicalExpr$1, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(yyy.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 20:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 18:
              // join
              // goto join
              $async$goto = 15;
              break;
            case 16:
              // else
              $async$goto = t3 === B.TokenType_22 ? 21 : 22;
              break;
            case 21:
              // then
              $async$goto = !$async$self.isTruthy$1(left._readLocal$0()) ? 23 : 24;
              break;
            case 23:
              // then
              yyy = $async$self._wrapExprResult$3(expr, left._readLocal$0(), "Expr result");
              $async$goto = 25;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitLogicalExpr$1, $async$controller);
            case 25:
              // after yield
              $async$goto = 26;
              return A._asyncStarHelper(yyy.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 26:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 24:
              // join
            case 22:
              // join
            case 15:
              // join
              right = A._Cell$named("right");
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.right), "stream", t1), t2);
              $async$handler = 27;
            case 30:
              // for condition
              $async$temp1 = A;
              $async$goto = 32;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitLogicalExpr$1, $async$controller);
            case 32:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 31;
                break;
              }
              item0 = t1.get$current();
              if (item0.type === B.InterpreterInfoType_3) {
                t2 = item0.object;
                t2.toString;
                right._value = t2;
              }
              yyy0 = item0;
              $async$goto = 33;
              $async$nextWhenCanceled = [1, 28];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitLogicalExpr$1, $async$controller);
            case 33:
              // after yield
              $async$goto = 34;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 34:
              // returning from await.
              // goto for condition
              $async$goto = 30;
              break;
            case 31:
              // after for
              $async$next.push(29);
              // goto finally
              $async$goto = 28;
              break;
            case 27:
              // uncaught
              $async$next = [2];
            case 28:
              // finally
              $async$handler = 2;
              $async$goto = 35;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitLogicalExpr$1, $async$controller);
            case 35:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 29:
              // after finally
              yyy2 = $async$self._wrapExprResult$3(expr, right._readLocal$0(), "Expr result");
              $async$goto = 36;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitLogicalExpr$1, $async$controller);
            case 36:
              // after yield
              $async$goto = 37;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitLogicalExpr$1, $async$controller);
            case 37:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitLogicalExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, left, item, yyy, right, item0, yyy0, t1, t2, t3, t4, yyy2, yyy1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitNullExpr$1(expr) {
      return this.visitNullExpr$body$Interpreter(type$.ExprNull._as(expr));
    },
    visitNullExpr$body$Interpreter(expr) {
      var $async$visitNullExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy = $async$self._wrapExpression$2(expr, "evaluate: visitNullExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitNullExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy.completer.future, $async$visitNullExpr$1, $async$controller);
            case 4:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitNullExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, yyy;
      return A._streamOfController($async$controller);
    },
    visitCallExpr$1(expr) {
      return this.visitCallExpr$body$Interpreter(type$.ExprCall._as(expr));
    },
    visitCallExpr$body$Interpreter(expr) {
      var $async$visitCallExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy2 = $async$self._wrapExpression$2(expr, "evaluate: visitCallExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitCallExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitCallExpr$1, $async$controller);
            case 4:
              // returning from await.
              callee = $.$get$Language_NULL_OBJECT();
              t1 = type$.Object;
              t2 = type$._StreamIterator_InterpreterInfo;
              t3 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.callee), "stream", t1), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t3.moveNext$0(), $async$visitCallExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t3.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                callee = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitCallExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitCallExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t3.cancel$0(), $async$visitCallExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              $arguments = A._setArrayType([], type$.JSArray_Object);
              t3 = expr.$arguments, t4 = t3.length, _i = 0;
            case 14:
              // for condition
              if (!(_i < t3.length)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              argumentExpr = t3[_i];
              argument = $.$get$Language_NULL_OBJECT();
              t5 = $async$self.evaluate$1(argumentExpr);
              t5 = new A._StreamIterator(t5, t2);
              $async$handler = 17;
            case 20:
              // for condition
              $async$temp1 = A;
              $async$goto = 22;
              return A._asyncStarHelper(t5.moveNext$0(), $async$visitCallExpr$1, $async$controller);
            case 22:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 21;
                break;
              }
              item0 = t5.get$current();
              if (item0.type === B.InterpreterInfoType_3) {
                t6 = item0.object;
                t6.toString;
                argument = t6;
              }
              yyy0 = item0;
              $async$goto = 23;
              $async$nextWhenCanceled = [1, 18];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitCallExpr$1, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitCallExpr$1, $async$controller);
            case 24:
              // returning from await.
              // goto for condition
              $async$goto = 20;
              break;
            case 21:
              // after for
              $async$next.push(19);
              // goto finally
              $async$goto = 18;
              break;
            case 17:
              // uncaught
              $async$next = [2];
            case 18:
              // finally
              $async$handler = 2;
              $async$goto = 25;
              return A._asyncStarHelper(t5.cancel$0(), $async$visitCallExpr$1, $async$controller);
            case 25:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 19:
              // after finally
              J.add$1$ax($arguments, argument);
            case 15:
              // for update
              t3.length === t4 || (0, A.throwConcurrentModificationError)(t3), ++_i;
              // goto for condition
              $async$goto = 14;
              break;
            case 16:
              // after for
              if (!type$.LanguageCallable._is(callee))
                throw A.wrapException(A.ParserRuntimeError$("Can only call functions and classes but have '" + J.get$runtimeType$(callee).toString$0(0) + "'", expr.paren));
              $function = callee;
              if (J.get$length$asx($arguments) !== $function.arity$0())
                throw A.wrapException(A.ParserRuntimeError$("Expected " + $function.arity$0() + " arguments but got " + J.get$length$asx($arguments), expr.paren));
              callResult = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($function.call$2($async$self, $arguments), "stream", t1), t2);
              $async$handler = 26;
            case 29:
              // for condition
              $async$temp1 = A;
              $async$goto = 31;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitCallExpr$1, $async$controller);
            case 31:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 30;
                break;
              }
              item1 = t1.get$current();
              if (item1.type === B.InterpreterInfoType_3) {
                t2 = item1.object;
                t2.toString;
                callResult = t2;
              }
              yyy1 = item1;
              $async$goto = 32;
              $async$nextWhenCanceled = [1, 27];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$visitCallExpr$1, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(yyy1.completer.future, $async$visitCallExpr$1, $async$controller);
            case 33:
              // returning from await.
              // goto for condition
              $async$goto = 29;
              break;
            case 30:
              // after for
              $async$next.push(28);
              // goto finally
              $async$goto = 27;
              break;
            case 26:
              // uncaught
              $async$next = [2];
            case 27:
              // finally
              $async$handler = 2;
              $async$goto = 34;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitCallExpr$1, $async$controller);
            case 34:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 28:
              // after finally
              yyy2 = $async$self._wrapExprResult$3(expr, callResult, "Expr result");
              $async$goto = 35;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitCallExpr$1, $async$controller);
            case 35:
              // after yield
              $async$goto = 36;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitCallExpr$1, $async$controller);
            case 36:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitCallExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, callee, item, yyy, $arguments, argumentExpr, argument, item0, yyy0, $function, callResult, item1, yyy1, t1, t2, t3, t4, _i, t5, t6, yyy2, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitVariableExpr$1(expr) {
      return this.visitVariableExpr$body$Interpreter(type$.ExprVariable._as(expr));
    },
    visitVariableExpr$body$Interpreter(expr) {
      var $async$visitVariableExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy = $async$self._wrapExpression$2(expr, "evaluate: visitVariableExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitVariableExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy.completer.future, $async$visitVariableExpr$1, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapExprResult$3(expr, $async$self.lookUpVariable$2(expr.name, expr), "Expr result");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitVariableExpr$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitVariableExpr$1, $async$controller);
            case 6:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitVariableExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, yyy2, yyy;
      return A._streamOfController($async$controller);
    },
    visitLiteralExpr$1(expr) {
      return this.visitLiteralExpr$body$Interpreter(type$.ExprLiteral._as(expr));
    },
    visitLiteralExpr$body$Interpreter(expr) {
      var $async$visitLiteralExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy = $async$self._wrapExpression$2(expr, "evaluate: visitLiteralExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitLiteralExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy.completer.future, $async$visitLiteralExpr$1, $async$controller);
            case 4:
              // returning from await.
              t1 = expr.value;
              yyy2 = $async$self._wrapExprResult$3(expr, t1 == null ? "nil" : t1, "Expr result");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitLiteralExpr$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitLiteralExpr$1, $async$controller);
            case 6:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitLiteralExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, yyy2, yyy;
      return A._streamOfController($async$controller);
    },
    visitGroupingExpr$1(expr) {
      return this.visitGroupingExpr$body$Interpreter(type$.ExprGrouping._as(expr));
    },
    visitGroupingExpr$body$Interpreter(expr) {
      var $async$visitGroupingExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy0 = $async$self._wrapExpression$2(expr, "evaluate: visitGroupingExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitGroupingExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitGroupingExpr$1, $async$controller);
            case 4:
              // returning from await.
              result = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.expression), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitGroupingExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                result = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitGroupingExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitGroupingExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitGroupingExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              yyy2 = $async$self._wrapExprResult$3(expr, result, "Expr result");
              $async$goto = 14;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitGroupingExpr$1, $async$controller);
            case 14:
              // after yield
              $async$goto = 15;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitGroupingExpr$1, $async$controller);
            case 15:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitGroupingExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, result, item, yyy, t1, t2, yyy2, yyy0, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitUnaryExpr$1(expr) {
      return this.visitUnaryExpr$body$Interpreter(type$.ExprUnary._as(expr));
    },
    visitUnaryExpr$body$Interpreter(expr) {
      var $async$visitUnaryExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy0 = $async$self._wrapExpression$2(expr, "evaluate: visitUnaryExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitUnaryExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitUnaryExpr$1, $async$controller);
            case 4:
              // returning from await.
              right = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.right), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitUnaryExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                right = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitUnaryExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitUnaryExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitUnaryExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t1 = expr.op;
            case 14:
              // switch
              switch (t1.type) {
                case B.TokenType_6:
                  // goto case
                  $async$goto = 16;
                  break;
                case B.TokenType_11:
                  // goto case
                  $async$goto = 17;
                  break;
                default:
                  // goto default
                  $async$goto = 18;
                  break;
              }
              break;
            case 16:
              // case
              $async$self.checkNumberOperand$2(t1, right);
              yyy = $async$self._wrapExprResult$3(expr, -A._asDouble(right), "Expr result");
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitUnaryExpr$1, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(yyy.completer.future, $async$visitUnaryExpr$1, $async$controller);
            case 20:
              // returning from await.
              // goto after switch
              $async$goto = 15;
              break;
            case 17:
              // case
              yyy = $async$self._wrapExprResult$3(expr, !$async$self.isTruthy$1(right), "Expr result");
              $async$goto = 21;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitUnaryExpr$1, $async$controller);
            case 21:
              // after yield
              $async$goto = 22;
              return A._asyncStarHelper(yyy.completer.future, $async$visitUnaryExpr$1, $async$controller);
            case 22:
              // returning from await.
              // goto after switch
              $async$goto = 15;
              break;
            case 18:
              // default
              throw A.wrapException(A.ParserRuntimeError$("Unsupported unary expression", t1));
            case 15:
              // after switch
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitUnaryExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, right, item, yyy, t1, t2, yyy0, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitBinaryExpr$1(expr) {
      return this.visitBinaryExpr$body$Interpreter(type$.ExprBinary._as(expr));
    },
    visitBinaryExpr$body$Interpreter(expr) {
      var $async$visitBinaryExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy1 = $async$self._wrapExpression$2(expr, "evaluate: visitBinaryExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$visitBinaryExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy1.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 4:
              // returning from await.
              left = $.$get$Language_NULL_OBJECT();
              t1 = type$.Object;
              t2 = type$._StreamIterator_InterpreterInfo;
              t3 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.left), "stream", t1), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t3.moveNext$0(), $async$visitBinaryExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t3.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t4 = item.object;
                t4.toString;
                left = t4;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t3.cancel$0(), $async$visitBinaryExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              right = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.right), "stream", t1), t2);
              $async$handler = 14;
            case 17:
              // for condition
              $async$temp1 = A;
              $async$goto = 19;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitBinaryExpr$1, $async$controller);
            case 19:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 18;
                break;
              }
              item0 = t1.get$current();
              if (item0.type === B.InterpreterInfoType_3) {
                t2 = item0.object;
                t2.toString;
                right = t2;
              }
              yyy0 = item0;
              $async$goto = 20;
              $async$nextWhenCanceled = [1, 15];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitBinaryExpr$1, $async$controller);
            case 20:
              // after yield
              $async$goto = 21;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 21:
              // returning from await.
              // goto for condition
              $async$goto = 17;
              break;
            case 18:
              // after for
              $async$next.push(16);
              // goto finally
              $async$goto = 15;
              break;
            case 14:
              // uncaught
              $async$next = [2];
            case 15:
              // finally
              $async$handler = 2;
              $async$goto = 22;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitBinaryExpr$1, $async$controller);
            case 22:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 16:
              // after finally
              t1 = expr.op;
            case 23:
              // switch
              switch (t1.type) {
                case B.TokenType_15:
                  // goto case
                  $async$goto = 25;
                  break;
                case B.TokenType_16:
                  // goto case
                  $async$goto = 26;
                  break;
                case B.TokenType_17:
                  // goto case
                  $async$goto = 27;
                  break;
                case B.TokenType_18:
                  // goto case
                  $async$goto = 28;
                  break;
                case B.TokenType_6:
                  // goto case
                  $async$goto = 29;
                  break;
                case B.TokenType_7:
                  // goto case
                  $async$goto = 30;
                  break;
                case B.TokenType_9:
                  // goto case
                  $async$goto = 31;
                  break;
                case B.TokenType_10:
                  // goto case
                  $async$goto = 32;
                  break;
                case B.TokenType_12:
                  // goto case
                  $async$goto = 33;
                  break;
                case B.TokenType_14:
                  // goto case
                  $async$goto = 34;
                  break;
                default:
                  // goto default
                  $async$goto = 35;
                  break;
              }
              break;
            case 25:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) > A._asDouble(right), "Expr result");
              $async$goto = 36;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 36:
              // after yield
              $async$goto = 37;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 37:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 26:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) >= A._asDouble(right), "Expr result");
              $async$goto = 38;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 38:
              // after yield
              $async$goto = 39;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 39:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 27:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) < A._asDouble(right), "Expr result");
              $async$goto = 40;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 40:
              // after yield
              $async$goto = 41;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 41:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 28:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) <= A._asDouble(right), "Expr result");
              $async$goto = 42;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 42:
              // after yield
              $async$goto = 43;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 43:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 29:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) - A._asDouble(right), "Expr result");
              $async$goto = 44;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 44:
              // after yield
              $async$goto = 45;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 45:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 30:
              // case
              $async$goto = typeof left == "number" && typeof right == "number" ? 46 : 48;
              break;
            case 46:
              // then
              t1 = left;
              t2 = right;
              if (typeof t1 !== "number") {
                t1.$add();
                // goto return
                $async$goto = 1;
                break;
              }
              if (typeof t2 !== "number") {
                A.iae(t2);
                // goto return
                $async$goto = 1;
                break;
              }
              yyy = $async$self._wrapExprResult$3(expr, t1 + t2, "Expr result");
              $async$goto = 49;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 49:
              // after yield
              $async$goto = 50;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 50:
              // returning from await.
              // goto join
              $async$goto = 47;
              break;
            case 48:
              // else
              $async$goto = typeof left == "string" && typeof right == "string" ? 51 : 53;
              break;
            case 51:
              // then
              yyy = $async$self._wrapExprResult$3(expr, J.$add$ansx(left, right), "Expr result");
              $async$goto = 54;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 54:
              // after yield
              $async$goto = 55;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 55:
              // returning from await.
              // goto join
              $async$goto = 52;
              break;
            case 53:
              // else
              yyy = $async$self._wrapExprResult$3(expr, J.toString$0$(left) + J.toString$0$(right), "Expr result");
              $async$goto = 56;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 56:
              // after yield
              $async$goto = 57;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 57:
              // returning from await.
            case 52:
              // join
            case 47:
              // join
              // goto after switch
              $async$goto = 24;
              break;
            case 31:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) / A._asDouble(right), "Expr result");
              $async$goto = 58;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 58:
              // after yield
              $async$goto = 59;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 59:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 32:
              // case
              $async$self.checkNumberOperands$3(t1, left, right);
              yyy = $async$self._wrapExprResult$3(expr, A._asDouble(left) * A._asDouble(right), "Expr result");
              $async$goto = 60;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 60:
              // after yield
              $async$goto = 61;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 61:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 33:
              // case
              yyy = $async$self._wrapExprResult$3(expr, !$async$self.isEqual$2(left, right), "Expr result");
              $async$goto = 62;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 62:
              // after yield
              $async$goto = 63;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 63:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 34:
              // case
              yyy = $async$self._wrapExprResult$3(expr, !$async$self.isEqual$2(left, right), "Expr result");
              $async$goto = 64;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitBinaryExpr$1, $async$controller);
            case 64:
              // after yield
              $async$goto = 65;
              return A._asyncStarHelper(yyy.completer.future, $async$visitBinaryExpr$1, $async$controller);
            case 65:
              // returning from await.
              // goto after switch
              $async$goto = 24;
              break;
            case 35:
              // default
              throw A.wrapException(A.ParserRuntimeError$("Unsupported binary expression", t1));
            case 24:
              // after switch
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitBinaryExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, left, item, yyy, right, item0, yyy0, t1, t2, t3, t4, yyy1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    visitAssignExpr$1(expr) {
      return this.visitAssignExpr$body$Interpreter(type$.ExprAssign._as(expr));
    },
    visitAssignExpr$body$Interpreter(expr) {
      var $async$visitAssignExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              yyy0 = $async$self._wrapExpression$2(expr, "evaluate: visitAssignExpr");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$visitAssignExpr$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(yyy0.completer.future, $async$visitAssignExpr$1, $async$controller);
            case 4:
              // returning from await.
              value = $.$get$Language_NULL_OBJECT();
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.evaluate$1(expr.value), "stream", type$.Object), type$._StreamIterator_InterpreterInfo);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t1.moveNext$0(), $async$visitAssignExpr$1, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t1.get$current();
              if (item.type === B.InterpreterInfoType_3) {
                t2 = item.object;
                t2.toString;
                value = t2;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$visitAssignExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$visitAssignExpr$1, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t1.cancel$0(), $async$visitAssignExpr$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t1 = $async$self.__Interpreter_environment_A;
              t1 === $ && A.throwLateFieldNI("environment");
              t1.assign$2(expr.name, value);
              yyy2 = $async$self._wrapExprResult$3(expr, value, "Expr result");
              $async$goto = 14;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$visitAssignExpr$1, $async$controller);
            case 14:
              // after yield
              $async$goto = 15;
              return A._asyncStarHelper(yyy2.completer.future, $async$visitAssignExpr$1, $async$controller);
            case 15:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitAssignExpr$1, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, item, yyy, t1, t2, yyy2, yyy0, $async$temp1;
      return A._streamOfController($async$controller);
    }
  };
  A.Interpreter_closure.prototype = {
    call$2(interpreter, argumnets) {
      return this.$call$body$Interpreter_closure(type$.Interpreter._as(interpreter), type$.List_Object._as(argumnets));
    },
    $call$body$Interpreter_closure(interpreter, argumnets) {
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = Date.now();
              t2 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.InterpreterInfo(B.InterpreterInfoType_3, t1 / 1000, null, new A._AsyncCompleter(t2, type$._AsyncCompleter_dynamic))), $async$call$2, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$call$2, $async$controller);
            case 4:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$2, type$.InterpreterInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], t1, t2;
      return A._streamOfController($async$controller);
    },
    $signature: 19
  };
  A.Interpreter_executeBlock_closure.prototype = {
    call$1(item) {
      this.controller.add$1(0, type$.InterpreterInfo._as(item));
      A.Future_Future$delayed(new A.Duration(100000), new A.Interpreter_executeBlock__closure(this.statement), type$.Null);
    },
    $signature: 7
  };
  A.Interpreter_executeBlock__closure.prototype = {
    call$0() {
    },
    $signature: 2
  };
  A.Interpreter_executeBlock_closure1.prototype = {
    call$2(error, stack) {
      var t1 = this.controller,
        t2 = error == null ? type$.Object._as(error) : error;
      t1.addError$2(t2, type$.nullable_StackTrace._as(stack));
      t1.close$0();
    },
    $signature: 20
  };
  A.Interpreter_executeBlock_closure0.prototype = {
    call$0() {
      this.controller.close$0();
    },
    $signature: 0
  };
  A.ParserStateType.prototype = {
    _enumToString$0() {
      return "ParserStateType." + this._name;
    }
  };
  A.ParserState.prototype = {
    finish$0() {
      var t1 = this.completer;
      if ((t1.future._state & 30) === 0)
        t1.complete$1(0);
    }
  };
  A.Parser.prototype = {
    addError$2(token, error) {
      B.JSArray_methods.add$1(this.errors, "Line " + token.line + ": [" + token.type._name + " " + token.lexeme + "] " + error);
      return new A.ParserState(null, null, B.ParserStateType_10, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_int), type$._AsyncCompleter_int));
    },
    _wrapStatement$4$message$partExpression$type(stmt, message, partExpression, type) {
      var t1 = $.Zone__current;
      this.isInner = true;
      return new A.ParserState(stmt, null, type, new A._AsyncCompleter(new A._Future(t1, type$._Future_int), type$._AsyncCompleter_int));
    },
    _wrapStatement$1(stmt) {
      return this._wrapStatement$4$message$partExpression$type(stmt, "", null, B.ParserStateType_1);
    },
    _wrapStatement$3$message$type(stmt, message, type) {
      return this._wrapStatement$4$message$partExpression$type(stmt, message, null, type);
    },
    _wrapStatementPartGen$2$message(stmt, message) {
      A.Primitives_objectHashCode(stmt);
      return this._wrapStatement$3$message$type(stmt, message, B.ParserStateType_2);
    },
    _wrapStatementPartGen$1(stmt) {
      return this._wrapStatementPartGen$2$message(stmt, "=");
    },
    advance$0() {
      var t1 = this.tokens,
        t2 = this.current,
        t3 = t1.length;
      if (!(t2 < t3))
        return A.ioore(t1, t2);
      t2 = (t1[t2].type !== B.TokenType_41 ? this.current = t2 + 1 : t2) - 1;
      if (!(t2 >= 0 && t2 < t3))
        return A.ioore(t1, t2);
      return t1[t2];
    },
    peek$0() {
      var t1 = this.tokens,
        t2 = this.current;
      if (!(t2 < t1.length))
        return A.ioore(t1, t2);
      return t1[t2];
    },
    check$1(type) {
      var t1 = this.tokens,
        t2 = this.current;
      if (!(t2 < t1.length))
        return A.ioore(t1, t2);
      t2 = t1[t2].type;
      if (t2 === B.TokenType_41)
        return false;
      return t2 === type;
    },
    match$1(types) {
      var t1, _i, t2, t3, _this = this;
      type$.List_TokenType._as(types);
      for (t1 = types.length, _i = 0; _i < types.length; types.length === t1 || (0, A.throwConcurrentModificationError)(types), ++_i)
        if (_this.check$1(types[_i])) {
          t1 = _this.tokens;
          t2 = _this.current;
          t3 = t1.length;
          if (!(t2 < t3))
            return A.ioore(t1, t2);
          t2 = (t1[t2].type !== B.TokenType_41 ? _this.current = t2 + 1 : t2) - 1;
          if (!(t2 >= 0 && t2 < t3))
            return A.ioore(t1, t2);
          return true;
        }
      return false;
    },
    consume$2(type, message) {
      var _this = this;
      if (_this.check$1(type))
        return _this.advance$0();
      throw A.wrapException(A.Exception_Exception(_this.error$2(_this.peek$0(), message)));
    },
    error$2(token, message) {
      A.Language_error(token, message);
      this.addError$2(token, message);
      return new A.ParseError("Parsing error: " + message);
    },
    parseStreamed$0() {
      var $async$parseStreamed$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.tokens;
            case 3:
              // while condition
              t2 = $async$self.current;
              if (!(t2 < t1.length)) {
                A.ioore(t1, t2);
                // goto return
                $async$goto = 1;
                break;
              }
              if (!(t1[t2].type !== B.TokenType_41)) {
                // goto after while
                $async$goto = 4;
                break;
              }
              $async$self.isInner = false;
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declaration$0()), $async$parseStreamed$0, $async$controller);
            case 5:
              // after yield
              ++$async$self.topStatementCounter;
              // goto while condition
              $async$goto = 3;
              break;
            case 4:
              // after while
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$parseStreamed$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t2, t1;
      return A._streamOfController($async$controller);
    },
    synchronize$0() {
      var t1, t2, t3, t4, t5, t6, _this = this;
      _this.advance$0();
      t1 = _this.tokens;
      while (true) {
        t2 = _this.current;
        t3 = t1.length;
        if (!(t2 < t3))
          return A.ioore(t1, t2);
        t4 = t1[t2].type;
        t5 = t4 !== B.TokenType_41;
        if (!t5)
          break;
        t6 = t2 - 1;
        if (!(t6 >= 0 && t6 < t3))
          return A.ioore(t1, t6);
        if (t1[t6].type === B.TokenType_8)
          return;
        switch (t4) {
          case B.TokenType_23:
          case B.TokenType_26:
          case B.TokenType_36:
          case B.TokenType_27:
          case B.TokenType_28:
          case B.TokenType_37:
          case B.TokenType_31:
          case B.TokenType_32:
            return;
          default:
            break;
        }
        t2 = (t5 ? _this.current = t2 + 1 : t2) - 1;
        if (!(t2 >= 0 && t2 < t3))
          return A.ioore(t1, t2);
      }
    },
    declaration$0() {
      var $async$declaration$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$declaration$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$declaration$0, $async$controller);
            case 4:
              // returning from await.
              $async$handler = 6;
              t2 = type$.JSArray_TokenType;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_23], t2)) ? 9 : 11;
              break;
            case 9:
              // then
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.classDeclaration$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 12;
            case 15:
              // for condition
              $async$temp1 = A;
              $async$goto = 17;
              return A._asyncStarHelper(t2.moveNext$0(), $async$declaration$0, $async$controller);
            case 17:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              item = t2.get$current();
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 13];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$declaration$0, $async$controller);
            case 18:
              // after yield
              // goto for condition
              $async$goto = 15;
              break;
            case 16:
              // after for
              $async$next.push(14);
              // goto finally
              $async$goto = 13;
              break;
            case 12:
              // uncaught
              $async$next = [6];
            case 13:
              // finally
              $async$handler = 6;
              $async$goto = 19;
              return A._asyncStarHelper(t2.cancel$0(), $async$declaration$0, $async$controller);
            case 19:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 14:
              // after finally
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_26], t2)) ? 20 : 22;
              break;
            case 20:
              // then
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.function$1("function"), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 23;
            case 26:
              // for condition
              $async$temp1 = A;
              $async$goto = 28;
              return A._asyncStarHelper(t2.moveNext$0(), $async$declaration$0, $async$controller);
            case 28:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 27;
                break;
              }
              item0 = t2.get$current();
              $async$goto = 29;
              $async$nextWhenCanceled = [1, 24];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item0), $async$declaration$0, $async$controller);
            case 29:
              // after yield
              // goto for condition
              $async$goto = 26;
              break;
            case 27:
              // after for
              $async$next.push(25);
              // goto finally
              $async$goto = 24;
              break;
            case 23:
              // uncaught
              $async$next = [6];
            case 24:
              // finally
              $async$handler = 6;
              $async$goto = 30;
              return A._asyncStarHelper(t2.cancel$0(), $async$declaration$0, $async$controller);
            case 30:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 25:
              // after finally
              // goto join
              $async$goto = 21;
              break;
            case 22:
              // else
              t4 = type$.Object;
              t5 = type$._StreamIterator_ParserState;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_36], t2)) ? 31 : 33;
              break;
            case 31:
              // then
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.varDeclaration$0(), "stream", t4), t5);
              $async$handler = 34;
            case 37:
              // for condition
              $async$temp1 = A;
              $async$goto = 39;
              return A._asyncStarHelper(t2.moveNext$0(), $async$declaration$0, $async$controller);
            case 39:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 38;
                break;
              }
              item1 = t2.get$current();
              $async$goto = 40;
              $async$nextWhenCanceled = [1, 35];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item1), $async$declaration$0, $async$controller);
            case 40:
              // after yield
              // goto for condition
              $async$goto = 37;
              break;
            case 38:
              // after for
              $async$next.push(36);
              // goto finally
              $async$goto = 35;
              break;
            case 34:
              // uncaught
              $async$next = [6];
            case 35:
              // finally
              $async$handler = 6;
              $async$goto = 41;
              return A._asyncStarHelper(t2.cancel$0(), $async$declaration$0, $async$controller);
            case 41:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 36:
              // after finally
              // goto join
              $async$goto = 32;
              break;
            case 33:
              // else
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", t4), t5);
              $async$handler = 42;
            case 45:
              // for condition
              $async$temp1 = A;
              $async$goto = 47;
              return A._asyncStarHelper(t2.moveNext$0(), $async$declaration$0, $async$controller);
            case 47:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 46;
                break;
              }
              item2 = t2.get$current();
              $async$goto = 48;
              $async$nextWhenCanceled = [1, 43];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item2), $async$declaration$0, $async$controller);
            case 48:
              // after yield
              // goto for condition
              $async$goto = 45;
              break;
            case 46:
              // after for
              $async$next.push(44);
              // goto finally
              $async$goto = 43;
              break;
            case 42:
              // uncaught
              $async$next = [6];
            case 43:
              // finally
              $async$handler = 6;
              $async$goto = 49;
              return A._asyncStarHelper(t2.cancel$0(), $async$declaration$0, $async$controller);
            case 49:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 44:
              // after finally
            case 32:
              // join
            case 21:
              // join
            case 10:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 8;
              break;
            case 6:
              // catch
              $async$handler = 5;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              $async$self.synchronize$0();
              A.S(e);
              $async$goto = 50;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(new A.StmtNull("error in declaration", new A.StmtState()), null, B.ParserStateType_10, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3))), $async$declaration$0, $async$controller);
            case 50:
              // after yield
              // goto after finally
              $async$goto = 8;
              break;
            case 5:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 8:
              // after finally
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 51;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$declaration$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(t1, $async$declaration$0, $async$controller);
            case 52:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$declaration$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, item, item0, item1, item2, e, t4, t5, exception, t1, t2, t3, $async$exception, $async$temp1;
      return A._streamOfController($async$controller);
    },
    statement$0() {
      var $async$statement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t3 = type$._Future_int;
              t4 = new A._Future($.Zone__current, t3);
              t5 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t4, t5))), $async$statement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t4, $async$statement$0, $async$controller);
            case 4:
              // returning from await.
              t4 = type$.JSArray_TokenType;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_27], t4)) ? 5 : 7;
              break;
            case 5:
              // then
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.forStatement$0()), $async$statement$0, $async$controller);
            case 8:
              // after yield
              // goto join
              $async$goto = 6;
              break;
            case 7:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_28], t4)) ? 9 : 11;
              break;
            case 9:
              // then
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.ifStatement$0()), $async$statement$0, $async$controller);
            case 12:
              // after yield
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_31], t4)) ? 13 : 15;
              break;
            case 13:
              // then
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.printStatement$0()), $async$statement$0, $async$controller);
            case 16:
              // after yield
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_32], t4)) ? 17 : 19;
              break;
            case 17:
              // then
              $async$goto = 20;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.returnStatement$0()), $async$statement$0, $async$controller);
            case 20:
              // after yield
              // goto join
              $async$goto = 18;
              break;
            case 19:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_37], t4)) ? 21 : 23;
              break;
            case 21:
              // then
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.whileStatement$0()), $async$statement$0, $async$controller);
            case 24:
              // after yield
              // goto join
              $async$goto = 22;
              break;
            case 23:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_2], t4)) ? 25 : 27;
              break;
            case 25:
              // then
              statements = A._setArrayType([], type$.JSArray_Stmt);
              yyy1 = $async$self._wrapStatementPartGen$1(new A.StmtBlock(statements, new A.StmtState()));
              $async$goto = 28;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$statement$0, $async$controller);
            case 28:
              // after yield
              $async$goto = 29;
              return A._asyncStarHelper(yyy1.completer.future, $async$statement$0, $async$controller);
            case 29:
              // returning from await.
              x = new A.StmtNull("", new A.StmtState());
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.block$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 30;
              t6 = type$.Stmt;
            case 33:
              // for condition
              $async$temp1 = A;
              $async$goto = 35;
              return A._asyncStarHelper(t4.moveNext$0(), $async$statement$0, $async$controller);
            case 35:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 34;
                break;
              }
              item = t4.get$current();
              if (item.type === B.ParserStateType_1) {
                t7 = item.statement;
                t7.toString;
                J.add$1$ax(statements, t7);
              }
              t7 = item.type;
              $async$goto = t7 === B.ParserStateType_1 || t7 === B.ParserStateType_2 || t7 === B.ParserStateType_3 || t7 === B.ParserStateType_4 ? 36 : 38;
              break;
            case 36:
              // then
              t7 = item.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item.statement;
              t7.toString;
              x = t7;
              $async$goto = item.type === B.ParserStateType_1 ? 39 : 41;
              break;
            case 39:
              // then
              t1 = A.List_List$of(statements, t6);
              t7 = new A.StmtBlock(t1, new A.StmtState());
              A.Primitives_objectHashCode(t7);
              t8 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t7, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t8, t3), t5));
              $async$goto = 42;
              $async$nextWhenCanceled = [1, 31];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$statement$0, $async$controller);
            case 42:
              // after yield
              $async$goto = 43;
              return A._asyncStarHelper(yyy.completer.future, $async$statement$0, $async$controller);
            case 43:
              // returning from await.
              // goto join
              $async$goto = 40;
              break;
            case 41:
              // else
              t2 = A.List_List$of(statements, t6);
              J.add$1$ax(t2, x);
              t7 = new A.StmtBlock(t2, new A.StmtState());
              A.Primitives_objectHashCode(t7);
              t8 = $.Zone__current;
              $async$self.isInner = true;
              yyy0 = new A.ParserState(t7, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t8, t3), t5));
              $async$goto = 44;
              $async$nextWhenCanceled = [1, 31];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$statement$0, $async$controller);
            case 44:
              // after yield
              $async$goto = 45;
              return A._asyncStarHelper(yyy0.completer.future, $async$statement$0, $async$controller);
            case 45:
              // returning from await.
            case 40:
              // join
              // goto join
              $async$goto = 37;
              break;
            case 38:
              // else
              $async$goto = 46;
              $async$nextWhenCanceled = [1, 31];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$statement$0, $async$controller);
            case 46:
              // after yield
            case 37:
              // join
              // goto for condition
              $async$goto = 33;
              break;
            case 34:
              // after for
              $async$next.push(32);
              // goto finally
              $async$goto = 31;
              break;
            case 30:
              // uncaught
              $async$next = [2];
            case 31:
              // finally
              $async$handler = 2;
              $async$goto = 47;
              return A._asyncStarHelper(t4.cancel$0(), $async$statement$0, $async$controller);
            case 47:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 32:
              // after finally
              yyy2 = $async$self._wrapStatement$1(new A.StmtBlock(statements, new A.StmtState()));
              $async$goto = 48;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$statement$0, $async$controller);
            case 48:
              // after yield
              $async$goto = 49;
              return A._asyncStarHelper(yyy2.completer.future, $async$statement$0, $async$controller);
            case 49:
              // returning from await.
              // goto join
              $async$goto = 26;
              break;
            case 27:
              // else
              $async$goto = 50;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.expressionStatement$0()), $async$statement$0, $async$controller);
            case 50:
              // after yield
            case 26:
              // join
            case 22:
              // join
            case 18:
              // join
            case 14:
              // join
            case 10:
              // join
            case 6:
              // join
              t1 = new A._Future($.Zone__current, t3);
              $async$goto = 51;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t5))), $async$statement$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(t1, $async$statement$0, $async$controller);
            case 52:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$statement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, statements, x, item, t1, yyy, t2, yyy0, yyy1, t6, t7, t8, yyy2, t3, t4, t5, $async$temp1;
      return A._streamOfController($async$controller);
    },
    classDeclaration$0() {
      var $async$classDeclaration$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$classDeclaration$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$classDeclaration$0, $async$controller);
            case 4:
              // returning from await.
              t2 = type$.JSArray_StmtFunction;
              yyy2 = $async$self._wrapStatementPartGen$1(new A.StmtClass(A.Token_Token$empty(), null, A._setArrayType([], t2), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$classDeclaration$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$classDeclaration$0, $async$controller);
            case 6:
              // returning from await.
              $name = $async$self.consume$2(B.TokenType_19, "Expect class name.");
              superclass = null;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_17], type$.JSArray_TokenType)) ? 7 : 8;
              break;
            case 7:
              // then
              $async$self.consume$2(B.TokenType_19, "Expect superclass name.");
              t4 = $async$self.tokens;
              t5 = $async$self.current - 1;
              if (!(t5 >= 0 && t5 < t4.length)) {
                A.ioore(t4, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              superclass = new A.ExprVariable(t4[t5], new A.ExpressionResultX());
              yyy1 = $async$self._wrapStatementPartGen$1(new A.StmtClass($name, superclass, A._setArrayType([], t2), new A.StmtState()));
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$classDeclaration$0, $async$controller);
            case 9:
              // after yield
              $async$goto = 10;
              return A._asyncStarHelper(yyy1.completer.future, $async$classDeclaration$0, $async$controller);
            case 10:
              // returning from await.
            case 8:
              // join
              $async$self.consume$2(B.TokenType_2, "Expect '{' before class body.");
              methods = A._setArrayType([], t2);
              x = A._Cell$named("x");
              t4 = type$.StmtFunction;
              t5 = type$._StreamIterator_ParserState;
              t6 = $async$self.tokens;
            case 11:
              // while condition
              if (!$async$self.check$1(B.TokenType_3)) {
                t7 = $async$self.current;
                if (!(t7 < t6.length)) {
                  A.ioore(t6, t7);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t7 = t6[t7].type !== B.TokenType_41;
              } else
                t7 = false;
              if (!t7) {
                // goto after while
                $async$goto = 12;
                break;
              }
              t7 = $async$self.function$1("method");
              t7 = new A._StreamIterator(t7, t5);
              $async$handler = 13;
            case 16:
              // for condition
              $async$temp1 = A;
              $async$goto = 18;
              return A._asyncStarHelper(t7.moveNext$0(), $async$classDeclaration$0, $async$controller);
            case 18:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 17;
                break;
              }
              item = t7.get$current();
              if (item.type === B.ParserStateType_1) {
                t8 = item.statement;
                t8.toString;
                J.add$1$ax(methods, t4._as(t8));
              }
              t8 = item.type;
              $async$goto = t8 === B.ParserStateType_1 || t8 === B.ParserStateType_2 || t8 === B.ParserStateType_3 || t8 === B.ParserStateType_4 ? 19 : 21;
              break;
            case 19:
              // then
              t8 = item.completer;
              t9 = t8.future;
              if ((t9._state & 30) === 0) {
                t8 = t8.$ti;
                t8._eval$1("1/?")._as(0);
                t9._asyncComplete$1(t8._eval$1("1/")._as(0));
              }
              t8 = item.statement;
              t8.toString;
              x._value = t4._as(t8);
              $async$goto = item.type === B.ParserStateType_1 ? 22 : 24;
              break;
            case 22:
              // then
              t8 = new A.StmtClass($name, superclass, methods, new A.StmtState());
              A.Primitives_objectHashCode(t8);
              t9 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t8, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t9, t1), t3));
              $async$goto = 25;
              $async$nextWhenCanceled = [1, 14];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$classDeclaration$0, $async$controller);
            case 25:
              // after yield
              $async$goto = 26;
              return A._asyncStarHelper(yyy.completer.future, $async$classDeclaration$0, $async$controller);
            case 26:
              // returning from await.
              // goto join
              $async$goto = 23;
              break;
            case 24:
              // else
              t8 = superclass;
              t9 = x;
              t10 = t9._value;
              if (t10 == null ? t9 == null : t10 === t9)
                A.throwExpression(A.LateError$localNI(t9.__late_helper$_name));
              t8 = new A.StmtClass($name, t8, J.$add$ansx(methods, A._setArrayType([t10], t2)), new A.StmtState());
              A.Primitives_objectHashCode(t8);
              t9 = $.Zone__current;
              $async$self.isInner = true;
              yyy0 = new A.ParserState(t8, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t9, t1), t3));
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 14];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$classDeclaration$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$classDeclaration$0, $async$controller);
            case 28:
              // returning from await.
            case 23:
              // join
              // goto join
              $async$goto = 20;
              break;
            case 21:
              // else
              $async$goto = 29;
              $async$nextWhenCanceled = [1, 14];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$classDeclaration$0, $async$controller);
            case 29:
              // after yield
            case 20:
              // join
              // goto for condition
              $async$goto = 16;
              break;
            case 17:
              // after for
              $async$next.push(15);
              // goto finally
              $async$goto = 14;
              break;
            case 13:
              // uncaught
              $async$next = [2];
            case 14:
              // finally
              $async$handler = 2;
              $async$goto = 30;
              return A._asyncStarHelper(t7.cancel$0(), $async$classDeclaration$0, $async$controller);
            case 30:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 15:
              // after finally
              // goto while condition
              $async$goto = 11;
              break;
            case 12:
              // after while
              $async$self.consume$2(B.TokenType_3, "Expect '}' after class body");
              yyy4 = $async$self._wrapStatement$1(new A.StmtClass($name, superclass, methods, new A.StmtState()));
              $async$goto = 31;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$classDeclaration$0, $async$controller);
            case 31:
              // after yield
              $async$goto = 32;
              return A._asyncStarHelper(yyy4.completer.future, $async$classDeclaration$0, $async$controller);
            case 32:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 33;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$classDeclaration$0, $async$controller);
            case 33:
              // after yield
              $async$goto = 34;
              return A._asyncStarHelper(t1, $async$classDeclaration$0, $async$controller);
            case 34:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$classDeclaration$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, $name, superclass, methods, x, item, yyy, yyy0, yyy2, t4, t5, yyy1, t6, t7, t8, t9, t10, yyy4, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    function$1(kind) {
      var $async$function$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$function$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$function$1, $async$controller);
            case 4:
              // returning from await.
              t2 = type$.JSArray_Token;
              t4 = type$.JSArray_Stmt;
              yyy3 = $async$self._wrapStatementPartGen$1(new A.StmtFunction(A.Token_Token$empty(), A._setArrayType([], t2), A._setArrayType([], t4), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$function$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy3.completer.future, $async$function$1, $async$controller);
            case 6:
              // returning from await.
              $name = $async$self.consume$2(B.TokenType_19, "Expect '" + kind + "' name.");
              yyy4 = $async$self._wrapStatementPartGen$1(new A.StmtFunction($name, A._setArrayType([], t2), A._setArrayType([], t4), new A.StmtState()));
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$function$1, $async$controller);
            case 7:
              // after yield
              $async$goto = 8;
              return A._asyncStarHelper(yyy4.completer.future, $async$function$1, $async$controller);
            case 8:
              // returning from await.
              $async$self.consume$2(B.TokenType_0, "Expect '(' after '" + kind + "' name");
              parameters = A._setArrayType([], t2);
              $async$goto = !$async$self.check$1(B.TokenType_1) ? 9 : 10;
              break;
            case 9:
              // then
              t2 = type$.JSArray_TokenType;
              t5 = $async$self.tokens;
            case 11:
              // do body
              $async$goto = J.get$length$asx(parameters) >= 255 ? 14 : 15;
              break;
            case 14:
              // then
              t6 = $async$self.current;
              if (!(t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              A.Language_error(t5[t6], "Can't have more than 255 arguments");
              t6 = $async$self.current;
              if (!(t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              yyy1 = $async$self.addError$2(t5[t6], "Can't have more than 255 arguments");
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$function$1, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(yyy1.completer.future, $async$function$1, $async$controller);
            case 17:
              // returning from await.
            case 15:
              // join
              J.add$1$ax(parameters, $async$self.consume$2(B.TokenType_19, "Expect parameter name"));
              yyy1 = $async$self._wrapStatementPartGen$1(new A.StmtFunction($name, parameters, A._setArrayType([], t4), new A.StmtState()));
              $async$goto = 18;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$function$1, $async$controller);
            case 18:
              // after yield
              $async$goto = 19;
              return A._asyncStarHelper(yyy1.completer.future, $async$function$1, $async$controller);
            case 19:
              // returning from await.
            case 12:
              // do condition
              if ($async$self.match$1(A._setArrayType([B.TokenType_4], t2))) {
                // goto do body
                $async$goto = 11;
                break;
              }
            case 13:
              // after do
            case 10:
              // join
              $async$self.consume$2(B.TokenType_1, "Expect ')' after parameters");
              $async$self.consume$2(B.TokenType_2, "Expect '{' before '" + kind + "' body");
              body = A._setArrayType([], t4);
              x = new A.StmtNull("", new A.StmtState());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.block$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 20;
            case 23:
              // for condition
              $async$temp1 = A;
              $async$goto = 25;
              return A._asyncStarHelper(t2.moveNext$0(), $async$function$1, $async$controller);
            case 25:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 24;
                break;
              }
              item = t2.get$current();
              if (item.type === B.ParserStateType_1) {
                t5 = item.statement;
                t5.toString;
                J.add$1$ax(body, t5);
              }
              t5 = item.type;
              $async$goto = t5 === B.ParserStateType_1 || t5 === B.ParserStateType_2 || t5 === B.ParserStateType_3 || t5 === B.ParserStateType_4 ? 26 : 28;
              break;
            case 26:
              // then
              t5 = item.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item.statement;
              t5.toString;
              x = t5;
              $async$goto = item.type === B.ParserStateType_1 ? 29 : 31;
              break;
            case 29:
              // then
              t5 = new A.StmtFunction($name, parameters, body, new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 32;
              $async$nextWhenCanceled = [1, 21];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$function$1, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(yyy.completer.future, $async$function$1, $async$controller);
            case 33:
              // returning from await.
              // goto join
              $async$goto = 30;
              break;
            case 31:
              // else
              t5 = new A.StmtFunction($name, parameters, J.$add$ansx(body, A._setArrayType([x], t4)), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy0 = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 34;
              $async$nextWhenCanceled = [1, 21];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$function$1, $async$controller);
            case 34:
              // after yield
              $async$goto = 35;
              return A._asyncStarHelper(yyy0.completer.future, $async$function$1, $async$controller);
            case 35:
              // returning from await.
            case 30:
              // join
              // goto join
              $async$goto = 27;
              break;
            case 28:
              // else
              $async$goto = 36;
              $async$nextWhenCanceled = [1, 21];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$function$1, $async$controller);
            case 36:
              // after yield
            case 27:
              // join
              // goto for condition
              $async$goto = 23;
              break;
            case 24:
              // after for
              $async$next.push(22);
              // goto finally
              $async$goto = 21;
              break;
            case 20:
              // uncaught
              $async$next = [2];
            case 21:
              // finally
              $async$handler = 2;
              $async$goto = 37;
              return A._asyncStarHelper(t2.cancel$0(), $async$function$1, $async$controller);
            case 37:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 22:
              // after finally
              yyy5 = $async$self._wrapStatement$1(new A.StmtFunction($name, parameters, body, new A.StmtState()));
              $async$goto = 38;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy5), $async$function$1, $async$controller);
            case 38:
              // after yield
              $async$goto = 39;
              return A._asyncStarHelper(yyy5.completer.future, $async$function$1, $async$controller);
            case 39:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 40;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$function$1, $async$controller);
            case 40:
              // after yield
              $async$goto = 41;
              return A._asyncStarHelper(t1, $async$function$1, $async$controller);
            case 41:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$function$1, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, $name, parameters, body, x, item, yyy, yyy0, t4, yyy3, yyy4, t5, t6, yyy1, yyy5, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    block$0() {
      var $async$block$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$block$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$block$0, $async$controller);
            case 4:
              // returning from await.
              t2 = $async$self.tokens;
            case 5:
              // while condition
              if (!$async$self.check$1(B.TokenType_3)) {
                t4 = $async$self.current;
                if (!(t4 < t2.length)) {
                  A.ioore(t2, t4);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t4 = t2[t4].type !== B.TokenType_41;
              } else
                t4 = false;
              if (!t4) {
                // goto after while
                $async$goto = 6;
                break;
              }
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declaration$0()), $async$block$0, $async$controller);
            case 7:
              // after yield
              // goto while condition
              $async$goto = 5;
              break;
            case 6:
              // after while
              $async$self.consume$2(B.TokenType_3, "Expect '}' after block.");
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$block$0, $async$controller);
            case 8:
              // after yield
              $async$goto = 9;
              return A._asyncStarHelper(t1, $async$block$0, $async$controller);
            case 9:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$block$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t4, t1, t2, t3;
      return A._streamOfController($async$controller);
    },
    whileStatement$0() {
      var $async$whileStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$whileStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$whileStatement$0, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapStatementPartGen$1(new A.StmtWhile(new A.ExprNull(new A.ExpressionResultX()), new A.StmtNull("", new A.StmtState()), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$whileStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$whileStatement$0, $async$controller);
            case 6:
              // returning from await.
              $async$self.consume$2(B.TokenType_0, "Expect '(' after 'while'");
              condition = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$.Object;
              t4 = type$._StreamIterator_ParserState;
              t5 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", t2), t4);
              $async$handler = 7;
              t6 = type$.Expr;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t5.moveNext$0(), $async$whileStatement$0, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              item = t5.get$current();
              t7 = item.type;
              $async$goto = t7 === B.ParserStateType_5 || t7 === B.ParserStateType_6 ? 13 : 15;
              break;
            case 13:
              // then
              t7 = item.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item.expression;
              t7.toString;
              condition = t7;
              t7 = condition;
              A.Primitives_objectHashCode(t6._as(condition));
              t8 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(new A.StmtWhile(t7, new A.StmtNull("", new A.StmtState()), new A.StmtState()), null, B.ParserStateType_4, new A._AsyncCompleter(new A._Future(t8, t1), t3));
              $async$goto = 16;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$whileStatement$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(yyy.completer.future, $async$whileStatement$0, $async$controller);
            case 17:
              // returning from await.
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$whileStatement$0, $async$controller);
            case 18:
              // after yield
            case 14:
              // join
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [2];
            case 8:
              // finally
              $async$handler = 2;
              $async$goto = 19;
              return A._asyncStarHelper(t5.cancel$0(), $async$whileStatement$0, $async$controller);
            case 19:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$self.consume$2(B.TokenType_1, "Expect ')' after condition");
              body = new A.StmtNull("NULL statement", new A.StmtState());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", t2), t4);
              $async$handler = 20;
            case 23:
              // for condition
              $async$temp1 = A;
              $async$goto = 25;
              return A._asyncStarHelper(t2.moveNext$0(), $async$whileStatement$0, $async$controller);
            case 25:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 24;
                break;
              }
              item0 = t2.get$current();
              t4 = item0.type;
              $async$goto = t4 === B.ParserStateType_1 || t4 === B.ParserStateType_2 || t4 === B.ParserStateType_3 || t4 === B.ParserStateType_4 ? 26 : 28;
              break;
            case 26:
              // then
              t4 = item0.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item0.statement;
              t4.toString;
              body = t4;
              t4 = new A.StmtWhile(condition, body, new A.StmtState());
              A.Primitives_objectHashCode(t4);
              t5 = $.Zone__current;
              $async$self.isInner = true;
              yyy0 = new A.ParserState(t4, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t5, t1), t3));
              $async$goto = 29;
              $async$nextWhenCanceled = [1, 21];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$whileStatement$0, $async$controller);
            case 29:
              // after yield
              $async$goto = 30;
              return A._asyncStarHelper(yyy0.completer.future, $async$whileStatement$0, $async$controller);
            case 30:
              // returning from await.
              // goto join
              $async$goto = 27;
              break;
            case 28:
              // else
              $async$goto = 31;
              $async$nextWhenCanceled = [1, 21];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item0), $async$whileStatement$0, $async$controller);
            case 31:
              // after yield
            case 27:
              // join
              // goto for condition
              $async$goto = 23;
              break;
            case 24:
              // after for
              $async$next.push(22);
              // goto finally
              $async$goto = 21;
              break;
            case 20:
              // uncaught
              $async$next = [2];
            case 21:
              // finally
              $async$handler = 2;
              $async$goto = 32;
              return A._asyncStarHelper(t2.cancel$0(), $async$whileStatement$0, $async$controller);
            case 32:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 22:
              // after finally
              yyy3 = $async$self._wrapStatement$1(new A.StmtWhile(condition, body, new A.StmtState()));
              $async$goto = 33;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$whileStatement$0, $async$controller);
            case 33:
              // after yield
              $async$goto = 34;
              return A._asyncStarHelper(yyy3.completer.future, $async$whileStatement$0, $async$controller);
            case 34:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 35;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$whileStatement$0, $async$controller);
            case 35:
              // after yield
              $async$goto = 36;
              return A._asyncStarHelper(t1, $async$whileStatement$0, $async$controller);
            case 36:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$whileStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, condition, item, yyy, body, item0, yyy0, yyy2, t4, t5, t6, t7, t8, yyy3, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    printStatement$0() {
      var $async$printStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$printStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$printStatement$0, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapStatementPartGen$1(new A.StmtPrint(new A.ExprNull(new A.ExpressionResultX()), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$printStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$printStatement$0, $async$controller);
            case 6:
              // returning from await.
              value = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 7;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t2.moveNext$0(), $async$printStatement$0, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              item = t2.get$current();
              t4 = item.type;
              $async$goto = t4 === B.ParserStateType_5 || t4 === B.ParserStateType_6 ? 13 : 15;
              break;
            case 13:
              // then
              t4 = item.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item.expression;
              t4.toString;
              value = t4;
              t4 = new A.StmtPrint(value, new A.StmtState());
              A.Primitives_objectHashCode(t4);
              t5 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t4, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t5, t1), t3));
              $async$goto = 16;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$printStatement$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(yyy.completer.future, $async$printStatement$0, $async$controller);
            case 17:
              // returning from await.
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$printStatement$0, $async$controller);
            case 18:
              // after yield
            case 14:
              // join
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [2];
            case 8:
              // finally
              $async$handler = 2;
              $async$goto = 19;
              return A._asyncStarHelper(t2.cancel$0(), $async$printStatement$0, $async$controller);
            case 19:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              yyy3 = $async$self._wrapStatement$1(new A.StmtPrint(value, new A.StmtState()));
              $async$goto = 20;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$printStatement$0, $async$controller);
            case 20:
              // after yield
              $async$goto = 21;
              return A._asyncStarHelper(yyy3.completer.future, $async$printStatement$0, $async$controller);
            case 21:
              // returning from await.
              $async$self.consume$2(B.TokenType_8, "Expect ';' after value.");
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 22;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$printStatement$0, $async$controller);
            case 22:
              // after yield
              $async$goto = 23;
              return A._asyncStarHelper(t1, $async$printStatement$0, $async$controller);
            case 23:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$printStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, item, yyy, yyy2, t4, t5, yyy3, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    returnStatement$0() {
      var $async$returnStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$returnStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$returnStatement$0, $async$controller);
            case 4:
              // returning from await.
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              keyword = t2[t4];
              yyy2 = $async$self._wrapStatementPartGen$1(new A.StmtReturn(keyword, new A.ExprNull(new A.ExpressionResultX()), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$returnStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$returnStatement$0, $async$controller);
            case 6:
              // returning from await.
              value = new A.ExprNull(new A.ExpressionResultX());
              $async$goto = !$async$self.check$1(B.TokenType_8) ? 7 : 8;
              break;
            case 7:
              // then
              value = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 9;
            case 12:
              // for condition
              $async$temp1 = A;
              $async$goto = 14;
              return A._asyncStarHelper(t2.moveNext$0(), $async$returnStatement$0, $async$controller);
            case 14:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 13;
                break;
              }
              item = t2.get$current();
              t4 = item.type;
              $async$goto = t4 === B.ParserStateType_5 || t4 === B.ParserStateType_6 ? 15 : 16;
              break;
            case 15:
              // then
              t4 = item.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item.expression;
              t4.toString;
              value = t4;
              t4 = new A.StmtReturn(keyword, value, new A.StmtState());
              A.Primitives_objectHashCode(t4);
              t5 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t4, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t5, t1), t3));
              $async$goto = 17;
              $async$nextWhenCanceled = [1, 10];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$returnStatement$0, $async$controller);
            case 17:
              // after yield
              $async$goto = 18;
              return A._asyncStarHelper(yyy.completer.future, $async$returnStatement$0, $async$controller);
            case 18:
              // returning from await.
            case 16:
              // join
              yyy0 = item;
              $async$goto = 19;
              $async$nextWhenCanceled = [1, 10];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$returnStatement$0, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(yyy0.completer.future, $async$returnStatement$0, $async$controller);
            case 20:
              // returning from await.
              // goto for condition
              $async$goto = 12;
              break;
            case 13:
              // after for
              $async$next.push(11);
              // goto finally
              $async$goto = 10;
              break;
            case 9:
              // uncaught
              $async$next = [2];
            case 10:
              // finally
              $async$handler = 2;
              $async$goto = 21;
              return A._asyncStarHelper(t2.cancel$0(), $async$returnStatement$0, $async$controller);
            case 21:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 11:
              // after finally
            case 8:
              // join
              $async$self.consume$2(B.TokenType_8, "Expect ';' after return value");
              yyy3 = $async$self._wrapStatement$1(new A.StmtReturn(keyword, value, new A.StmtState()));
              $async$goto = 22;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$returnStatement$0, $async$controller);
            case 22:
              // after yield
              $async$goto = 23;
              return A._asyncStarHelper(yyy3.completer.future, $async$returnStatement$0, $async$controller);
            case 23:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$returnStatement$0, $async$controller);
            case 24:
              // after yield
              $async$goto = 25;
              return A._asyncStarHelper(t1, $async$returnStatement$0, $async$controller);
            case 25:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$returnStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, keyword, value, item, yyy, yyy0, t4, yyy2, t5, yyy3, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    ifStatement$0() {
      var $async$ifStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$ifStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$ifStatement$0, $async$controller);
            case 4:
              // returning from await.
              yyy20 = $async$self._wrapStatementPartGen$1(new A.StmtIf(new A.ExprNull(new A.ExpressionResultX()), new A.StmtNull("", new A.StmtState()), new A.StmtNull("", new A.StmtState()), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy20), $async$ifStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy20.completer.future, $async$ifStatement$0, $async$controller);
            case 6:
              // returning from await.
              $async$self.consume$2(B.TokenType_0, "Expect '(' after 'if'.");
              condition = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$.Object;
              t4 = type$._StreamIterator_ParserState;
              t5 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", t2), t4);
              $async$handler = 7;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t5.moveNext$0(), $async$ifStatement$0, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              item = t5.get$current();
              t6 = item.type;
              $async$goto = t6 === B.ParserStateType_5 || t6 === B.ParserStateType_6 ? 13 : 15;
              break;
            case 13:
              // then
              t6 = item.completer;
              t7 = t6.future;
              if ((t7._state & 30) === 0) {
                t6 = t6.$ti;
                t6._eval$1("1/?")._as(0);
                t7._asyncComplete$1(t6._eval$1("1/")._as(0));
              }
              t6 = item.expression;
              t6.toString;
              condition = t6;
              t6 = new A.StmtIf(condition, new A.StmtNull("", new A.StmtState()), new A.StmtNull("", new A.StmtState()), new A.StmtState());
              A.Primitives_objectHashCode(t6);
              t7 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t6, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t7, t1), t3));
              $async$goto = 16;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$ifStatement$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(yyy.completer.future, $async$ifStatement$0, $async$controller);
            case 17:
              // returning from await.
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              yyy0 = item;
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$ifStatement$0, $async$controller);
            case 18:
              // after yield
              $async$goto = 19;
              return A._asyncStarHelper(yyy0.completer.future, $async$ifStatement$0, $async$controller);
            case 19:
              // returning from await.
            case 14:
              // join
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [2];
            case 8:
              // finally
              $async$handler = 2;
              $async$goto = 20;
              return A._asyncStarHelper(t5.cancel$0(), $async$ifStatement$0, $async$controller);
            case 20:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$self.consume$2(B.TokenType_1, "Expect ')' after if condition.");
              thenBranch = new A.StmtNull("Null stmt", new A.StmtState());
              t5 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", t2), t4);
              $async$handler = 21;
            case 24:
              // for condition
              $async$temp1 = A;
              $async$goto = 26;
              return A._asyncStarHelper(t5.moveNext$0(), $async$ifStatement$0, $async$controller);
            case 26:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 25;
                break;
              }
              item0 = t5.get$current();
              t6 = item0.type;
              $async$goto = t6 === B.ParserStateType_1 || t6 === B.ParserStateType_2 || t6 === B.ParserStateType_3 || t6 === B.ParserStateType_4 ? 27 : 29;
              break;
            case 27:
              // then
              t6 = item0.completer;
              t7 = t6.future;
              if ((t7._state & 30) === 0) {
                t6 = t6.$ti;
                t6._eval$1("1/?")._as(0);
                t7._asyncComplete$1(t6._eval$1("1/")._as(0));
              }
              t6 = item0.statement;
              t6.toString;
              thenBranch = t6;
              t6 = new A.StmtIf(condition, thenBranch, new A.StmtNull("", new A.StmtState()), new A.StmtState());
              A.Primitives_objectHashCode(t6);
              t7 = $.Zone__current;
              $async$self.isInner = true;
              yyy1 = new A.ParserState(t6, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t7, t1), t3));
              $async$goto = 30;
              $async$nextWhenCanceled = [1, 22];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$ifStatement$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(yyy1.completer.future, $async$ifStatement$0, $async$controller);
            case 31:
              // returning from await.
              // goto join
              $async$goto = 28;
              break;
            case 29:
              // else
              yyy2 = item0;
              $async$goto = 32;
              $async$nextWhenCanceled = [1, 22];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$ifStatement$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(yyy2.completer.future, $async$ifStatement$0, $async$controller);
            case 33:
              // returning from await.
            case 28:
              // join
              // goto for condition
              $async$goto = 24;
              break;
            case 25:
              // after for
              $async$next.push(23);
              // goto finally
              $async$goto = 22;
              break;
            case 21:
              // uncaught
              $async$next = [2];
            case 22:
              // finally
              $async$handler = 2;
              $async$goto = 34;
              return A._asyncStarHelper(t5.cancel$0(), $async$ifStatement$0, $async$controller);
            case 34:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 23:
              // after finally
              elseBranch = new A.StmtNull("Null statement", new A.StmtState());
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_24], type$.JSArray_TokenType)) ? 35 : 36;
              break;
            case 35:
              // then
              elseBranch = new A.StmtNull("Null stmt", new A.StmtState());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", t2), t4);
              $async$handler = 37;
            case 40:
              // for condition
              $async$temp1 = A;
              $async$goto = 42;
              return A._asyncStarHelper(t2.moveNext$0(), $async$ifStatement$0, $async$controller);
            case 42:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 41;
                break;
              }
              item1 = t2.get$current();
              t4 = item1.type;
              $async$goto = t4 === B.ParserStateType_1 || t4 === B.ParserStateType_2 || t4 === B.ParserStateType_3 || t4 === B.ParserStateType_4 ? 43 : 45;
              break;
            case 43:
              // then
              t4 = item1.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item1.statement;
              t4.toString;
              elseBranch = t4;
              t4 = new A.StmtIf(condition, thenBranch, elseBranch, new A.StmtState());
              A.Primitives_objectHashCode(t4);
              t5 = $.Zone__current;
              $async$self.isInner = true;
              yyy3 = new A.ParserState(t4, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t5, t1), t3));
              $async$goto = 46;
              $async$nextWhenCanceled = [1, 38];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$ifStatement$0, $async$controller);
            case 46:
              // after yield
              $async$goto = 47;
              return A._asyncStarHelper(yyy3.completer.future, $async$ifStatement$0, $async$controller);
            case 47:
              // returning from await.
              // goto join
              $async$goto = 44;
              break;
            case 45:
              // else
              yyy4 = item1;
              $async$goto = 48;
              $async$nextWhenCanceled = [1, 38];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$ifStatement$0, $async$controller);
            case 48:
              // after yield
              $async$goto = 49;
              return A._asyncStarHelper(yyy4.completer.future, $async$ifStatement$0, $async$controller);
            case 49:
              // returning from await.
            case 44:
              // join
              // goto for condition
              $async$goto = 40;
              break;
            case 41:
              // after for
              $async$next.push(39);
              // goto finally
              $async$goto = 38;
              break;
            case 37:
              // uncaught
              $async$next = [2];
            case 38:
              // finally
              $async$handler = 2;
              $async$goto = 50;
              return A._asyncStarHelper(t2.cancel$0(), $async$ifStatement$0, $async$controller);
            case 50:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 39:
              // after finally
            case 36:
              // join
              yyy3 = $async$self._wrapStatement$1(new A.StmtIf(condition, thenBranch, elseBranch, new A.StmtState()));
              $async$goto = 51;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$ifStatement$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(yyy3.completer.future, $async$ifStatement$0, $async$controller);
            case 52:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 53;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$ifStatement$0, $async$controller);
            case 53:
              // after yield
              $async$goto = 54;
              return A._asyncStarHelper(t1, $async$ifStatement$0, $async$controller);
            case 54:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$ifStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, condition, item, yyy, yyy0, thenBranch, item0, yyy1, yyy2, elseBranch, item1, yyy3, yyy4, yyy20, t4, t5, t6, t7, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    forStatement$0() {
      var $async$forStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$forStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$forStatement$0, $async$controller);
            case 4:
              // returning from await.
              $async$self.consume$2(B.TokenType_0, "Expect '(' after 'for'");
              t2 = type$.JSArray_Stmt;
              yyy20 = $async$self._wrapStatementPartGen$1(new A.StmtBlock(A._setArrayType([], t2), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy20), $async$forStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy20.completer.future, $async$forStatement$0, $async$controller);
            case 6:
              // returning from await.
              initializer = new A.StmtNull("null initializer", new A.StmtState());
              t4 = type$.JSArray_TokenType;
              $async$goto = !$async$self.match$1(A._setArrayType([B.TokenType_8], t4)) ? 7 : 8;
              break;
            case 7:
              // then
              t5 = type$.Object;
              t6 = type$._StreamIterator_ParserState;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_36], t4)) ? 9 : 11;
              break;
            case 9:
              // then
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.varDeclaration$0(), "stream", t5), t6);
              $async$handler = 12;
            case 15:
              // for condition
              $async$temp1 = A;
              $async$goto = 17;
              return A._asyncStarHelper(t4.moveNext$0(), $async$forStatement$0, $async$controller);
            case 17:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              $async$goto = t5 === B.ParserStateType_1 || t5 === B.ParserStateType_2 || t5 === B.ParserStateType_3 || t5 === B.ParserStateType_4 ? 18 : 20;
              break;
            case 18:
              // then
              t5 = item.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item.statement;
              t5.toString;
              initializer = t5;
              $async$goto = 21;
              $async$nextWhenCanceled = [1, 13];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$forStatement$0, $async$controller);
            case 21:
              // after yield
              t5 = new A.StmtBlock(A._setArrayType([initializer], t2), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 22;
              $async$nextWhenCanceled = [1, 13];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$forStatement$0, $async$controller);
            case 22:
              // after yield
              $async$goto = 23;
              return A._asyncStarHelper(yyy.completer.future, $async$forStatement$0, $async$controller);
            case 23:
              // returning from await.
              // goto join
              $async$goto = 19;
              break;
            case 20:
              // else
              $async$goto = 24;
              $async$nextWhenCanceled = [1, 13];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$forStatement$0, $async$controller);
            case 24:
              // after yield
            case 19:
              // join
              // goto for condition
              $async$goto = 15;
              break;
            case 16:
              // after for
              $async$next.push(14);
              // goto finally
              $async$goto = 13;
              break;
            case 12:
              // uncaught
              $async$next = [2];
            case 13:
              // finally
              $async$handler = 2;
              $async$goto = 25;
              return A._asyncStarHelper(t4.cancel$0(), $async$forStatement$0, $async$controller);
            case 25:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 14:
              // after finally
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", t5), t6);
              $async$handler = 26;
            case 29:
              // for condition
              $async$temp1 = A;
              $async$goto = 31;
              return A._asyncStarHelper(t4.moveNext$0(), $async$forStatement$0, $async$controller);
            case 31:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 30;
                break;
              }
              item0 = t4.get$current();
              t5 = item0.type;
              $async$goto = t5 === B.ParserStateType_1 || t5 === B.ParserStateType_2 || t5 === B.ParserStateType_3 || t5 === B.ParserStateType_4 ? 32 : 34;
              break;
            case 32:
              // then
              t5 = item0.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item0.statement;
              t5.toString;
              initializer = t5;
              t5 = new A.StmtBlock(A._setArrayType([initializer], t2), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy0 = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 35;
              $async$nextWhenCanceled = [1, 27];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$forStatement$0, $async$controller);
            case 35:
              // after yield
              $async$goto = 36;
              return A._asyncStarHelper(yyy0.completer.future, $async$forStatement$0, $async$controller);
            case 36:
              // returning from await.
              // goto join
              $async$goto = 33;
              break;
            case 34:
              // else
              yyy1 = item0;
              $async$goto = 37;
              $async$nextWhenCanceled = [1, 27];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$forStatement$0, $async$controller);
            case 37:
              // after yield
              $async$goto = 38;
              return A._asyncStarHelper(yyy1.completer.future, $async$forStatement$0, $async$controller);
            case 38:
              // returning from await.
            case 33:
              // join
              // goto for condition
              $async$goto = 29;
              break;
            case 30:
              // after for
              $async$next.push(28);
              // goto finally
              $async$goto = 27;
              break;
            case 26:
              // uncaught
              $async$next = [2];
            case 27:
              // finally
              $async$handler = 2;
              $async$goto = 39;
              return A._asyncStarHelper(t4.cancel$0(), $async$forStatement$0, $async$controller);
            case 39:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 28:
              // after finally
            case 10:
              // join
            case 8:
              // join
              condition = new A.ExprNull(new A.ExpressionResultX());
              $async$goto = !$async$self.check$1(B.TokenType_8) ? 40 : 41;
              break;
            case 40:
              // then
              condition = new A.ExprNull(new A.ExpressionResultX());
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 42;
            case 45:
              // for condition
              $async$temp1 = A;
              $async$goto = 47;
              return A._asyncStarHelper(t4.moveNext$0(), $async$forStatement$0, $async$controller);
            case 47:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 46;
                break;
              }
              item1 = t4.get$current();
              t5 = item1.type;
              $async$goto = t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6 ? 48 : 50;
              break;
            case 48:
              // then
              t5 = item1.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item1.expression;
              t5.toString;
              condition = t5;
              if (condition instanceof A.ExprNull)
                condition = new A.ExprLiteral(true, new A.ExpressionResultX());
              t5 = new A.StmtBlock(A._setArrayType([initializer, new A.StmtWhile(condition, new A.StmtNull("", new A.StmtState()), new A.StmtState())], t2), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy2 = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 51;
              $async$nextWhenCanceled = [1, 43];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$forStatement$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(yyy2.completer.future, $async$forStatement$0, $async$controller);
            case 52:
              // returning from await.
              // goto join
              $async$goto = 49;
              break;
            case 50:
              // else
              yyy3 = item1;
              $async$goto = 53;
              $async$nextWhenCanceled = [1, 43];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$forStatement$0, $async$controller);
            case 53:
              // after yield
              $async$goto = 54;
              return A._asyncStarHelper(yyy3.completer.future, $async$forStatement$0, $async$controller);
            case 54:
              // returning from await.
            case 49:
              // join
              // goto for condition
              $async$goto = 45;
              break;
            case 46:
              // after for
              $async$next.push(44);
              // goto finally
              $async$goto = 43;
              break;
            case 42:
              // uncaught
              $async$next = [2];
            case 43:
              // finally
              $async$handler = 2;
              $async$goto = 55;
              return A._asyncStarHelper(t4.cancel$0(), $async$forStatement$0, $async$controller);
            case 55:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 44:
              // after finally
            case 41:
              // join
              $async$self.consume$2(B.TokenType_8, "Expect ';' after loop condition");
              body = new A.StmtNull("Null stmt", new A.StmtState());
              increment = new A.ExprNull(new A.ExpressionResultX());
              $async$goto = !$async$self.check$1(B.TokenType_1) ? 56 : 57;
              break;
            case 56:
              // then
              increment = new A.ExprNull(new A.ExpressionResultX());
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 58;
            case 61:
              // for condition
              $async$temp1 = A;
              $async$goto = 63;
              return A._asyncStarHelper(t4.moveNext$0(), $async$forStatement$0, $async$controller);
            case 63:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 62;
                break;
              }
              item2 = t4.get$current();
              t5 = item2.type;
              $async$goto = t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6 ? 64 : 66;
              break;
            case 64:
              // then
              t5 = item2.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item2.expression;
              t5.toString;
              increment = t5;
              $async$goto = !(increment instanceof A.ExprNull) ? 67 : 68;
              break;
            case 67:
              // then
              t5 = new A.StmtBlock(A._setArrayType([initializer, new A.StmtWhile(condition, new A.StmtExpression(increment, new A.StmtState()), new A.StmtState())], t2), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy4 = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 69;
              $async$nextWhenCanceled = [1, 59];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$forStatement$0, $async$controller);
            case 69:
              // after yield
              $async$goto = 70;
              return A._asyncStarHelper(yyy4.completer.future, $async$forStatement$0, $async$controller);
            case 70:
              // returning from await.
            case 68:
              // join
              // goto join
              $async$goto = 65;
              break;
            case 66:
              // else
              yyy5 = item2;
              $async$goto = 71;
              $async$nextWhenCanceled = [1, 59];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy5), $async$forStatement$0, $async$controller);
            case 71:
              // after yield
              $async$goto = 72;
              return A._asyncStarHelper(yyy5.completer.future, $async$forStatement$0, $async$controller);
            case 72:
              // returning from await.
            case 65:
              // join
              // goto for condition
              $async$goto = 61;
              break;
            case 62:
              // after for
              $async$next.push(60);
              // goto finally
              $async$goto = 59;
              break;
            case 58:
              // uncaught
              $async$next = [2];
            case 59:
              // finally
              $async$handler = 2;
              $async$goto = 73;
              return A._asyncStarHelper(t4.cancel$0(), $async$forStatement$0, $async$controller);
            case 73:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 60:
              // after finally
            case 57:
              // join
              $async$self.consume$2(B.TokenType_1, "Expet ')' after for clause");
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.statement$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 74;
            case 77:
              // for condition
              $async$temp1 = A;
              $async$goto = 79;
              return A._asyncStarHelper(t4.moveNext$0(), $async$forStatement$0, $async$controller);
            case 79:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 78;
                break;
              }
              item3 = t4.get$current();
              t5 = item3.type;
              $async$goto = t5 === B.ParserStateType_1 || t5 === B.ParserStateType_2 || t5 === B.ParserStateType_3 || t5 === B.ParserStateType_4 ? 80 : 82;
              break;
            case 80:
              // then
              t5 = item3.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item3.statement;
              t5.toString;
              body = t5;
              t5 = new A.StmtBlock(A._setArrayType([initializer, new A.StmtWhile(condition, new A.StmtBlock(A._setArrayType([body, new A.StmtExpression(increment, new A.StmtState())], t2), new A.StmtState()), new A.StmtState())], t2), new A.StmtState());
              A.Primitives_objectHashCode(t5);
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy6 = new A.ParserState(t5, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 83;
              $async$nextWhenCanceled = [1, 75];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy6), $async$forStatement$0, $async$controller);
            case 83:
              // after yield
              $async$goto = 84;
              return A._asyncStarHelper(yyy6.completer.future, $async$forStatement$0, $async$controller);
            case 84:
              // returning from await.
              // goto join
              $async$goto = 81;
              break;
            case 82:
              // else
              yyy7 = item3;
              $async$goto = 85;
              $async$nextWhenCanceled = [1, 75];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy7), $async$forStatement$0, $async$controller);
            case 85:
              // after yield
              $async$goto = 86;
              return A._asyncStarHelper(yyy7.completer.future, $async$forStatement$0, $async$controller);
            case 86:
              // returning from await.
            case 81:
              // join
              // goto for condition
              $async$goto = 77;
              break;
            case 78:
              // after for
              $async$next.push(76);
              // goto finally
              $async$goto = 75;
              break;
            case 74:
              // uncaught
              $async$next = [2];
            case 75:
              // finally
              $async$handler = 2;
              $async$goto = 87;
              return A._asyncStarHelper(t4.cancel$0(), $async$forStatement$0, $async$controller);
            case 87:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 76:
              // after finally
              yyy3 = $async$self._wrapStatement$1(new A.StmtBlock(A._setArrayType([initializer, new A.StmtWhile(condition, new A.StmtBlock(A._setArrayType([body, new A.StmtExpression(increment, new A.StmtState())], t2), new A.StmtState()), new A.StmtState())], t2), new A.StmtState()));
              $async$goto = 88;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$forStatement$0, $async$controller);
            case 88:
              // after yield
              $async$goto = 89;
              return A._asyncStarHelper(yyy3.completer.future, $async$forStatement$0, $async$controller);
            case 89:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 90;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$forStatement$0, $async$controller);
            case 90:
              // after yield
              $async$goto = 91;
              return A._asyncStarHelper(t1, $async$forStatement$0, $async$controller);
            case 91:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$forStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, initializer, item, yyy, item0, yyy0, yyy1, condition, item1, yyy2, yyy3, body, increment, item2, yyy4, yyy5, item3, yyy6, yyy7, yyy20, t4, t5, t6, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    expressionStatement$0() {
      var $async$expressionStatement$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$expressionStatement$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$expressionStatement$0, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapStatementPartGen$1(new A.StmtExpression(new A.ExprNull(new A.ExpressionResultX()), new A.StmtState()));
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$expressionStatement$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$expressionStatement$0, $async$controller);
            case 6:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 7;
              t4 = type$.Expr;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t2.moveNext$0(), $async$expressionStatement$0, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              item = t2.get$current();
              t5 = item.type;
              $async$goto = t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6 ? 13 : 15;
              break;
            case 13:
              // then
              t5 = item.completer;
              t6 = t5.future;
              if ((t6._state & 30) === 0) {
                t5 = t5.$ti;
                t5._eval$1("1/?")._as(0);
                t6._asyncComplete$1(t5._eval$1("1/")._as(0));
              }
              t5 = item.expression;
              t5.toString;
              expr = t5;
              t5 = expr;
              A.Primitives_objectHashCode(t4._as(expr));
              t6 = $.Zone__current;
              $async$self.isInner = true;
              yyy3 = new A.ParserState(new A.StmtExpression(t5, new A.StmtState()), null, B.ParserStateType_4, new A._AsyncCompleter(new A._Future(t6, t1), t3));
              $async$goto = 16;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$expressionStatement$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(yyy3.completer.future, $async$expressionStatement$0, $async$controller);
            case 17:
              // returning from await.
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              yyy4 = item;
              $async$goto = 18;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$expressionStatement$0, $async$controller);
            case 18:
              // after yield
              $async$goto = 19;
              return A._asyncStarHelper(yyy4.completer.future, $async$expressionStatement$0, $async$controller);
            case 19:
              // returning from await.
            case 14:
              // join
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [2];
            case 8:
              // finally
              $async$handler = 2;
              $async$goto = 20;
              return A._asyncStarHelper(t2.cancel$0(), $async$expressionStatement$0, $async$controller);
            case 20:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$self.consume$2(B.TokenType_8, "Expect ';' after expression");
              yyy3 = $async$self._wrapStatement$1(new A.StmtExpression(expr, new A.StmtState()));
              $async$goto = 21;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$expressionStatement$0, $async$controller);
            case 21:
              // after yield
              $async$goto = 22;
              return A._asyncStarHelper(yyy3.completer.future, $async$expressionStatement$0, $async$controller);
            case 22:
              // returning from await.
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 23;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$expressionStatement$0, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(t1, $async$expressionStatement$0, $async$controller);
            case 24:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$expressionStatement$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy3, yyy4, yyy2, t4, t5, t6, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    varDeclaration$0() {
      var $async$varDeclaration$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$varDeclaration$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$varDeclaration$0, $async$controller);
            case 4:
              // returning from await.
              yyy2 = $async$self._wrapStatementPartGen$2$message(new A.StmtVar(A.Token_Token$empty(), new A.ExprNull(new A.ExpressionResultX()), new A.StmtState()), "AAAA");
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$varDeclaration$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(yyy2.completer.future, $async$varDeclaration$0, $async$controller);
            case 6:
              // returning from await.
              $name = $async$self.consume$2(B.TokenType_19, "Expect variable name");
              yyy3 = $async$self._wrapStatementPartGen$1(new A.StmtVar($name, new A.ExprNull(new A.ExpressionResultX()), new A.StmtState()));
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$varDeclaration$0, $async$controller);
            case 7:
              // after yield
              $async$goto = 8;
              return A._asyncStarHelper(yyy3.completer.future, $async$varDeclaration$0, $async$controller);
            case 8:
              // returning from await.
              initializer = new A.ExprNull(new A.ExpressionResultX());
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_13], type$.JSArray_TokenType)) ? 9 : 10;
              break;
            case 9:
              // then
              initializer = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 11;
            case 14:
              // for condition
              $async$temp1 = A;
              $async$goto = 16;
              return A._asyncStarHelper(t2.moveNext$0(), $async$varDeclaration$0, $async$controller);
            case 16:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 15;
                break;
              }
              item = t2.get$current();
              t4 = item.type;
              $async$goto = t4 === B.ParserStateType_5 || t4 === B.ParserStateType_6 ? 17 : 19;
              break;
            case 17:
              // then
              t4 = item.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item.expression;
              t4.toString;
              initializer = t4;
              t4 = new A.StmtVar($name, initializer, new A.StmtState());
              A.Primitives_objectHashCode(t4);
              t5 = $.Zone__current;
              $async$self.isInner = true;
              yyy = new A.ParserState(t4, null, B.ParserStateType_2, new A._AsyncCompleter(new A._Future(t5, t1), t3));
              $async$goto = 20;
              $async$nextWhenCanceled = [1, 12];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$varDeclaration$0, $async$controller);
            case 20:
              // after yield
              $async$goto = 21;
              return A._asyncStarHelper(yyy.completer.future, $async$varDeclaration$0, $async$controller);
            case 21:
              // returning from await.
              // goto join
              $async$goto = 18;
              break;
            case 19:
              // else
              yyy0 = item;
              $async$goto = 22;
              $async$nextWhenCanceled = [1, 12];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$varDeclaration$0, $async$controller);
            case 22:
              // after yield
              $async$goto = 23;
              return A._asyncStarHelper(yyy0.completer.future, $async$varDeclaration$0, $async$controller);
            case 23:
              // returning from await.
            case 18:
              // join
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              $async$next.push(13);
              // goto finally
              $async$goto = 12;
              break;
            case 11:
              // uncaught
              $async$next = [2];
            case 12:
              // finally
              $async$handler = 2;
              $async$goto = 24;
              return A._asyncStarHelper(t2.cancel$0(), $async$varDeclaration$0, $async$controller);
            case 24:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 13:
              // after finally
            case 10:
              // join
              yyy4 = $async$self._wrapStatement$1(new A.StmtVar($name, initializer, new A.StmtState()));
              $async$goto = 25;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy4), $async$varDeclaration$0, $async$controller);
            case 25:
              // after yield
              $async$goto = 26;
              return A._asyncStarHelper(yyy4.completer.future, $async$varDeclaration$0, $async$controller);
            case 26:
              // returning from await.
              $async$self.consume$2(B.TokenType_8, "Expect ';' after variable declaration");
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 27;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$varDeclaration$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(t1, $async$varDeclaration$0, $async$controller);
            case 28:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$varDeclaration$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, $name, initializer, item, yyy, yyy0, yyy2, yyy3, t4, t5, yyy4, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    expression$0() {
      var $async$expression$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$expression$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$expression$0, $async$controller);
            case 4:
              // returning from await.
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.assignment$0()), $async$expression$0, $async$controller);
            case 5:
              // after yield
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$expression$0, $async$controller);
            case 6:
              // after yield
              $async$goto = 7;
              return A._asyncStarHelper(t1, $async$expression$0, $async$controller);
            case 7:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$expression$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, t2, t3;
      return A._streamOfController($async$controller);
    },
    assignment$0() {
      var $async$assignment$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$assignment$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$assignment$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$.Object;
              t4 = type$._StreamIterator_ParserState;
              t5 = new A._StreamIterator(A.checkNotNullable($async$self.or$0(), "stream", t2), t4);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t5.moveNext$0(), $async$assignment$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t5.get$current();
              t6 = item.type;
              if (t6 === B.ParserStateType_5 || t6 === B.ParserStateType_6) {
                t6 = item.expression;
                t6.toString;
                expr = t6;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$assignment$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$assignment$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t5.cancel$0(), $async$assignment$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_13], type$.JSArray_TokenType)) ? 14 : 15;
              break;
            case 14:
              // then
              t5 = $async$self.tokens;
              t6 = $async$self.current - 1;
              if (!(t6 >= 0 && t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              equals = t5[t6];
              $async$goto = expr instanceof A.ExprVariable ? 16 : 18;
              break;
            case 16:
              // then
              $name = expr.name;
              t5 = new A.ExprAssign($name, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t5);
              t6 = new A._Future($.Zone__current, t1);
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t5, B.ParserStateType_6, new A._AsyncCompleter(t6, t3))), $async$assignment$0, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(t6, $async$assignment$0, $async$controller);
            case 20:
              // returning from await.
              value = new A.ExprNull(new A.ExpressionResultX());
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.assignment$0(), "stream", t2), t4);
              $async$handler = 21;
            case 24:
              // for condition
              $async$temp1 = A;
              $async$goto = 26;
              return A._asyncStarHelper(t4.moveNext$0(), $async$assignment$0, $async$controller);
            case 26:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 25;
                break;
              }
              item0 = t4.get$current();
              t2 = item0.type;
              $async$goto = t2 === B.ParserStateType_5 || t2 === B.ParserStateType_6 ? 27 : 29;
              break;
            case 27:
              // then
              t2 = item0.completer;
              t5 = t2.future;
              if ((t5._state & 30) === 0) {
                t2 = t2.$ti;
                t2._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t2._eval$1("1/")._as(0));
              }
              t2 = item0.expression;
              t2.toString;
              value = t2;
              t2 = new A.ExprAssign($name, value, new A.ExpressionResultX());
              A.Primitives_objectHashCode(t2);
              yyy0 = new A.ParserState(null, t2, B.ParserStateType_6, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 30;
              $async$nextWhenCanceled = [1, 22];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$assignment$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(yyy0.completer.future, $async$assignment$0, $async$controller);
            case 31:
              // returning from await.
              // goto join
              $async$goto = 28;
              break;
            case 29:
              // else
              yyy1 = item0;
              $async$goto = 32;
              $async$nextWhenCanceled = [1, 22];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$assignment$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(yyy1.completer.future, $async$assignment$0, $async$controller);
            case 33:
              // returning from await.
            case 28:
              // join
              // goto for condition
              $async$goto = 24;
              break;
            case 25:
              // after for
              $async$next.push(23);
              // goto finally
              $async$goto = 22;
              break;
            case 21:
              // uncaught
              $async$next = [2];
            case 22:
              // finally
              $async$handler = 2;
              $async$goto = 34;
              return A._asyncStarHelper(t4.cancel$0(), $async$assignment$0, $async$controller);
            case 34:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 23:
              // after finally
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              $async$goto = expr instanceof A.ExprGet ? 35 : 37;
              break;
            case 35:
              // then
              _get = expr;
              t5 = new A.ExprSet(_get.object, _get.name, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t5);
              t6 = new A._Future($.Zone__current, t1);
              $async$goto = 38;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t5, B.ParserStateType_6, new A._AsyncCompleter(t6, t3))), $async$assignment$0, $async$controller);
            case 38:
              // after yield
              $async$goto = 39;
              return A._asyncStarHelper(t6, $async$assignment$0, $async$controller);
            case 39:
              // returning from await.
              value0 = new A.ExprNull(new A.ExpressionResultX());
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.assignment$0(), "stream", t2), t4);
              $async$handler = 40;
            case 43:
              // for condition
              $async$temp1 = A;
              $async$goto = 45;
              return A._asyncStarHelper(t4.moveNext$0(), $async$assignment$0, $async$controller);
            case 45:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 44;
                break;
              }
              item1 = t4.get$current();
              t2 = item1.type;
              $async$goto = t2 === B.ParserStateType_5 || t2 === B.ParserStateType_6 ? 46 : 48;
              break;
            case 46:
              // then
              t2 = item1.completer;
              t5 = t2.future;
              if ((t5._state & 30) === 0) {
                t2 = t2.$ti;
                t2._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t2._eval$1("1/")._as(0));
              }
              t2 = item1.expression;
              t2.toString;
              value0 = t2;
              t2 = new A.ExprSet(_get.object, _get.name, value0, new A.ExpressionResultX());
              A.Primitives_objectHashCode(t2);
              yyy2 = new A.ParserState(null, t2, B.ParserStateType_6, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 49;
              $async$nextWhenCanceled = [1, 41];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$assignment$0, $async$controller);
            case 49:
              // after yield
              $async$goto = 50;
              return A._asyncStarHelper(yyy2.completer.future, $async$assignment$0, $async$controller);
            case 50:
              // returning from await.
              // goto join
              $async$goto = 47;
              break;
            case 48:
              // else
              yyy3 = item1;
              $async$goto = 51;
              $async$nextWhenCanceled = [1, 41];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy3), $async$assignment$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(yyy3.completer.future, $async$assignment$0, $async$controller);
            case 52:
              // returning from await.
            case 47:
              // join
              // goto for condition
              $async$goto = 43;
              break;
            case 44:
              // after for
              $async$next.push(42);
              // goto finally
              $async$goto = 41;
              break;
            case 40:
              // uncaught
              $async$next = [2];
            case 41:
              // finally
              $async$handler = 2;
              $async$goto = 53;
              return A._asyncStarHelper(t4.cancel$0(), $async$assignment$0, $async$controller);
            case 53:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 42:
              // after finally
              // goto join
              $async$goto = 36;
              break;
            case 37:
              // else
              $async$self.error$2(equals, "Invalid assignment target.");
              yyy = $async$self.addError$2(equals, "Invalid assignment target.");
              $async$goto = 54;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$assignment$0, $async$controller);
            case 54:
              // after yield
              $async$goto = 55;
              return A._asyncStarHelper(yyy.completer.future, $async$assignment$0, $async$controller);
            case 55:
              // returning from await.
            case 36:
              // join
            case 17:
              // join
            case 15:
              // join
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 56;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$assignment$0, $async$controller);
            case 56:
              // after yield
              $async$goto = 57;
              return A._asyncStarHelper(t1, $async$assignment$0, $async$controller);
            case 57:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$assignment$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, $name, value, item0, yyy0, yyy1, _get, value0, item1, yyy2, yyy3, t4, t5, t6, equals, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    or$0() {
      var $async$or$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$or$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$or$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.and$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$or$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$or$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$or$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$or$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = type$.Expr, t6 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_30], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t7 = $async$self.current - 1;
              if (!(t7 >= 0 && t7 < t6.length)) {
                A.ioore(t6, t7);
                // goto return
                $async$goto = 1;
                break;
              }
              op = t6[t7];
              t7 = new A.ExprLogical(expr, op, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t7);
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t7, B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$or$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t8, $async$or$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t8 = $async$self.and$0();
              t7 = new A._StreamIterator(t8, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t7.moveNext$0(), $async$or$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t7.get$current();
              t8 = item0.type;
              $async$goto = t8 === B.ParserStateType_5 || t8 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t8 = item0.completer;
              t9 = t8.future;
              if ((t9._state & 30) === 0) {
                t8 = t8.$ti;
                t8._eval$1("1/?")._as(0);
                t9._asyncComplete$1(t8._eval$1("1/")._as(0));
              }
              t8 = item0.expression;
              t8.toString;
              right = t8;
              t8 = new A.ExprLogical(expr, op, right, new A.ExpressionResultX());
              A.Primitives_objectHashCode(t8);
              yyy0 = new A.ParserState(null, t8, B.ParserStateType_5, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$or$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$or$0, $async$controller);
            case 28:
              // returning from await.
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy1 = item0;
              $async$goto = 29;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$or$0, $async$controller);
            case 29:
              // after yield
              $async$goto = 30;
              return A._asyncStarHelper(yyy1.completer.future, $async$or$0, $async$controller);
            case 30:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 31;
              return A._asyncStarHelper(t7.cancel$0(), $async$or$0, $async$controller);
            case 31:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprLogical(expr, op, right, new A.ExpressionResultX());
              t7 = t5._as(expr);
              A.Primitives_objectHashCode(t7);
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t7, B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$or$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t8, $async$or$0, $async$controller);
            case 33:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 34;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$or$0, $async$controller);
            case 34:
              // after yield
              $async$goto = 35;
              return A._asyncStarHelper(t1, $async$or$0, $async$controller);
            case 35:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$or$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, op, right, item0, yyy0, yyy1, t4, t5, t6, t7, t8, t9, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    and$0() {
      var $async$and$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$and$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$and$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.equality$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$and$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$and$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$and$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$and$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = type$.Expr, t6 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_22], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t7 = $async$self.current - 1;
              if (!(t7 >= 0 && t7 < t6.length)) {
                A.ioore(t6, t7);
                // goto return
                $async$goto = 1;
                break;
              }
              op = t6[t7];
              t7 = new A.ExprLogical(expr, op, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t7);
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t7, B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$and$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t8, $async$and$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t8 = $async$self.equality$0();
              t7 = new A._StreamIterator(t8, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t7.moveNext$0(), $async$and$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t7.get$current();
              t8 = item0.type;
              $async$goto = t8 === B.ParserStateType_5 || t8 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t8 = item0.completer;
              t9 = t8.future;
              if ((t9._state & 30) === 0) {
                t8 = t8.$ti;
                t8._eval$1("1/?")._as(0);
                t9._asyncComplete$1(t8._eval$1("1/")._as(0));
              }
              t8 = item0.expression;
              t8.toString;
              right = t8;
              t8 = new A.ExprLogical(expr, op, right, new A.ExpressionResultX());
              A.Primitives_objectHashCode(t8);
              yyy0 = new A.ParserState(null, t8, B.ParserStateType_5, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3));
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$and$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$and$0, $async$controller);
            case 28:
              // returning from await.
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy1 = item0;
              $async$goto = 29;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy1), $async$and$0, $async$controller);
            case 29:
              // after yield
              $async$goto = 30;
              return A._asyncStarHelper(yyy1.completer.future, $async$and$0, $async$controller);
            case 30:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 31;
              return A._asyncStarHelper(t7.cancel$0(), $async$and$0, $async$controller);
            case 31:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprLogical(expr, op, right, new A.ExpressionResultX());
              t7 = t5._as(expr);
              A.Primitives_objectHashCode(t7);
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t7, B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$and$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t8, $async$and$0, $async$controller);
            case 33:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 34;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$and$0, $async$controller);
            case 34:
              // after yield
              $async$goto = 35;
              return A._asyncStarHelper(t1, $async$and$0, $async$controller);
            case 35:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$and$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, op, right, item0, yyy0, yyy1, t4, t5, t6, t7, t8, t9, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    equality$0() {
      var $async$equality$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$equality$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$equality$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.comparison$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$equality$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.completer;
                t6 = t5.future;
                if ((t6._state & 30) === 0) {
                  t5 = t5.$ti;
                  t5._eval$1("1/?")._as(0);
                  t6._asyncComplete$1(t5._eval$1("1/")._as(0));
                }
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$equality$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$equality$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$equality$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_12, B.TokenType_14], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t6 = $async$self.current - 1;
              if (!(t6 >= 0 && t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              operator = t5[t6];
              t6 = new A.ExprBinary(expr, operator, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t6);
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$equality$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t7, $async$equality$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t7 = $async$self.comparison$0();
              t6 = new A._StreamIterator(t7, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t6.moveNext$0(), $async$equality$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t6.get$current();
              t7 = item0.type;
              $async$goto = t7 === B.ParserStateType_5 || t7 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t7 = item0.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item0.expression;
              t7.toString;
              right = t7;
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy0 = item0;
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$equality$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$equality$0, $async$controller);
            case 28:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 29;
              return A._asyncStarHelper(t6.cancel$0(), $async$equality$0, $async$controller);
            case 29:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprBinary(expr, operator, right, new A.ExpressionResultX());
              t6 = expr;
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 30;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$equality$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(t7, $async$equality$0, $async$controller);
            case 31:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$equality$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t1, $async$equality$0, $async$controller);
            case 33:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$equality$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, right, item0, yyy0, t4, t5, t6, operator, t7, t8, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    comparison$0() {
      var $async$comparison$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$comparison$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$comparison$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.term$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$comparison$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$comparison$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$comparison$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$comparison$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_15, B.TokenType_16, B.TokenType_17, B.TokenType_18], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t6 = $async$self.current - 1;
              if (!(t6 >= 0 && t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              operator = t5[t6];
              t6 = new A.ExprBinary(expr, operator, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t6);
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$comparison$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t7, $async$comparison$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t7 = $async$self.term$0();
              t6 = new A._StreamIterator(t7, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t6.moveNext$0(), $async$comparison$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t6.get$current();
              t7 = item0.type;
              $async$goto = t7 === B.ParserStateType_5 || t7 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t7 = item0.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item0.expression;
              t7.toString;
              right = t7;
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy0 = item0;
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$comparison$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$comparison$0, $async$controller);
            case 28:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 29;
              return A._asyncStarHelper(t6.cancel$0(), $async$comparison$0, $async$controller);
            case 29:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprBinary(expr, operator, right, new A.ExpressionResultX());
              t6 = expr;
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 30;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$comparison$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(t7, $async$comparison$0, $async$controller);
            case 31:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$comparison$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t1, $async$comparison$0, $async$controller);
            case 33:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$comparison$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, right, item0, yyy0, t4, t5, t6, operator, t7, t8, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    term$0() {
      var $async$term$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$term$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$term$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.factor$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$term$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$term$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$term$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$term$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_6, B.TokenType_7], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t6 = $async$self.current - 1;
              if (!(t6 >= 0 && t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              operator = t5[t6];
              t6 = new A.ExprBinary(expr, operator, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t6);
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$term$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t7, $async$term$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t7 = $async$self.factor$0();
              t6 = new A._StreamIterator(t7, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t6.moveNext$0(), $async$term$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t6.get$current();
              t7 = item0.type;
              $async$goto = t7 === B.ParserStateType_5 || t7 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t7 = item0.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item0.expression;
              t7.toString;
              right = t7;
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy0 = item0;
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$term$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$term$0, $async$controller);
            case 28:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 29;
              return A._asyncStarHelper(t6.cancel$0(), $async$term$0, $async$controller);
            case 29:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprBinary(expr, operator, right, new A.ExpressionResultX());
              t6 = expr;
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 30;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$term$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(t7, $async$term$0, $async$controller);
            case 31:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$term$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t1, $async$term$0, $async$controller);
            case 33:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$term$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, right, item0, yyy0, t4, t5, t6, operator, t7, t8, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    factor$0() {
      var $async$factor$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$factor$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$factor$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.unary$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$factor$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$factor$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$factor$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$factor$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.JSArray_TokenType, t5 = $async$self.tokens;
            case 14:
              // for condition
              if (!$async$self.match$1(A._setArrayType([B.TokenType_9, B.TokenType_10], t4))) {
                // goto after for
                $async$goto = 15;
                break;
              }
              t6 = $async$self.current - 1;
              if (!(t6 >= 0 && t6 < t5.length)) {
                A.ioore(t5, t6);
                // goto return
                $async$goto = 1;
                break;
              }
              operator = t5[t6];
              t6 = new A.ExprBinary(expr, operator, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t6);
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$factor$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t7, $async$factor$0, $async$controller);
            case 17:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t7 = $async$self.unary$0();
              t6 = new A._StreamIterator(t7, t2);
              $async$handler = 18;
            case 21:
              // for condition
              $async$temp1 = A;
              $async$goto = 23;
              return A._asyncStarHelper(t6.moveNext$0(), $async$factor$0, $async$controller);
            case 23:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              item0 = t6.get$current();
              t7 = item0.type;
              $async$goto = t7 === B.ParserStateType_5 || t7 === B.ParserStateType_6 ? 24 : 26;
              break;
            case 24:
              // then
              t7 = item0.completer;
              t8 = t7.future;
              if ((t8._state & 30) === 0) {
                t7 = t7.$ti;
                t7._eval$1("1/?")._as(0);
                t8._asyncComplete$1(t7._eval$1("1/")._as(0));
              }
              t7 = item0.expression;
              t7.toString;
              right = t7;
              // goto join
              $async$goto = 25;
              break;
            case 26:
              // else
              yyy0 = item0;
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 19];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$factor$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$factor$0, $async$controller);
            case 28:
              // returning from await.
            case 25:
              // join
              // goto for condition
              $async$goto = 21;
              break;
            case 22:
              // after for
              $async$next.push(20);
              // goto finally
              $async$goto = 19;
              break;
            case 18:
              // uncaught
              $async$next = [2];
            case 19:
              // finally
              $async$handler = 2;
              $async$goto = 29;
              return A._asyncStarHelper(t6.cancel$0(), $async$factor$0, $async$controller);
            case 29:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 20:
              // after finally
              expr = new A.ExprBinary(expr, operator, right, new A.ExpressionResultX());
              t6 = expr;
              t7 = new A._Future($.Zone__current, t1);
              $async$goto = 30;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t6, B.ParserStateType_5, new A._AsyncCompleter(t7, t3))), $async$factor$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(t7, $async$factor$0, $async$controller);
            case 31:
              // returning from await.
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$factor$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(t1, $async$factor$0, $async$controller);
            case 33:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$factor$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, right, item0, yyy0, t4, t5, t6, operator, t7, t8, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    unary$0() {
      var $async$unary$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$unary$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$unary$0, $async$controller);
            case 4:
              // returning from await.
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_11, B.TokenType_6], type$.JSArray_TokenType)) ? 5 : 7;
              break;
            case 5:
              // then
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              operator = t2[t4];
              t4 = new A.ExprUnary(operator, new A.ExprNull(new A.ExpressionResultX()), new A.ExpressionResultX());
              A.Primitives_objectHashCode(t4);
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t4, B.ParserStateType_6, new A._AsyncCompleter(t2, t3))), $async$unary$0, $async$controller);
            case 8:
              // after yield
              $async$goto = 9;
              return A._asyncStarHelper(t2, $async$unary$0, $async$controller);
            case 9:
              // returning from await.
              right = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.unary$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 10;
            case 13:
              // for condition
              $async$temp1 = A;
              $async$goto = 15;
              return A._asyncStarHelper(t2.moveNext$0(), $async$unary$0, $async$controller);
            case 15:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 14;
                break;
              }
              item = t2.get$current();
              t4 = item.type;
              $async$goto = t4 === B.ParserStateType_5 || t4 === B.ParserStateType_6 ? 16 : 18;
              break;
            case 16:
              // then
              t4 = item.completer;
              t5 = t4.future;
              if ((t5._state & 30) === 0) {
                t4 = t4.$ti;
                t4._eval$1("1/?")._as(0);
                t5._asyncComplete$1(t4._eval$1("1/")._as(0));
              }
              t4 = item.expression;
              t4.toString;
              right = t4;
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              yyy = item;
              $async$goto = 19;
              $async$nextWhenCanceled = [1, 11];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$unary$0, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(yyy.completer.future, $async$unary$0, $async$controller);
            case 20:
              // returning from await.
            case 17:
              // join
              // goto for condition
              $async$goto = 13;
              break;
            case 14:
              // after for
              $async$next.push(12);
              // goto finally
              $async$goto = 11;
              break;
            case 10:
              // uncaught
              $async$next = [2];
            case 11:
              // finally
              $async$handler = 2;
              $async$goto = 21;
              return A._asyncStarHelper(t2.cancel$0(), $async$unary$0, $async$controller);
            case 21:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 12:
              // after finally
              t2 = new A.ExprUnary(operator, right, new A.ExpressionResultX());
              A.Primitives_objectHashCode(t2);
              t4 = new A._Future($.Zone__current, t1);
              $async$goto = 22;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t2, B.ParserStateType_5, new A._AsyncCompleter(t4, t3))), $async$unary$0, $async$controller);
            case 22:
              // after yield
              $async$goto = 23;
              return A._asyncStarHelper(t4, $async$unary$0, $async$controller);
            case 23:
              // returning from await.
              // goto join
              $async$goto = 6;
              break;
            case 7:
              // else
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.call$0()), $async$unary$0, $async$controller);
            case 24:
              // after yield
            case 6:
              // join
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 25;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$unary$0, $async$controller);
            case 25:
              // after yield
              $async$goto = 26;
              return A._asyncStarHelper(t1, $async$unary$0, $async$controller);
            case 26:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$unary$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, right, item, yyy, t4, operator, t5, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    call$0() {
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$call$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$call$0, $async$controller);
            case 4:
              // returning from await.
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = type$._StreamIterator_ParserState;
              t4 = new A._StreamIterator(A.checkNotNullable($async$self.primary$0(), "stream", type$.Object), t2);
              $async$handler = 5;
            case 8:
              // for condition
              $async$temp1 = A;
              $async$goto = 10;
              return A._asyncStarHelper(t4.moveNext$0(), $async$call$0, $async$controller);
            case 10:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 9;
                break;
              }
              item = t4.get$current();
              t5 = item.type;
              if (t5 === B.ParserStateType_5 || t5 === B.ParserStateType_6) {
                t5 = item.completer;
                t6 = t5.future;
                if ((t6._state & 30) === 0) {
                  t5 = t5.$ti;
                  t5._eval$1("1/?")._as(0);
                  t6._asyncComplete$1(t5._eval$1("1/")._as(0));
                }
                t5 = item.expression;
                t5.toString;
                expr = t5;
              }
              yyy = item;
              $async$goto = 11;
              $async$nextWhenCanceled = [1, 6];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$call$0, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              return A._asyncStarHelper(yyy.completer.future, $async$call$0, $async$controller);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 8;
              break;
            case 9:
              // after for
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncStarHelper(t4.cancel$0(), $async$call$0, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              t4 = type$.Expr, t5 = type$.JSArray_TokenType, t6 = type$.JSArray_Expr;
            case 14:
              // for condition
              // trivial condition
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_0], t5)) ? 16 : 18;
              break;
            case 16:
              // then
              t7 = expr;
              t8 = A._setArrayType([], t6);
              t9 = new A._Future($.Zone__current, t1);
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprCall(t7, new A.Token(B.TokenType_40, "", null, -1), t8, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t9, t3))), $async$call$0, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(t9, $async$call$0, $async$controller);
            case 20:
              // returning from await.
              t9 = $async$self.finishCall$1(expr);
              t7 = new A._StreamIterator(t9, t2);
              $async$handler = 21;
            case 24:
              // for condition
              $async$temp1 = A;
              $async$goto = 26;
              return A._asyncStarHelper(t7.moveNext$0(), $async$call$0, $async$controller);
            case 26:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 25;
                break;
              }
              item0 = t7.get$current();
              t8 = item0.type;
              if (t8 === B.ParserStateType_5 || t8 === B.ParserStateType_6) {
                t8 = item0.expression;
                t8.toString;
                expr = t8;
              }
              yyy0 = item0;
              $async$goto = 27;
              $async$nextWhenCanceled = [1, 22];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$call$0, $async$controller);
            case 27:
              // after yield
              $async$goto = 28;
              return A._asyncStarHelper(yyy0.completer.future, $async$call$0, $async$controller);
            case 28:
              // returning from await.
              // goto for condition
              $async$goto = 24;
              break;
            case 25:
              // after for
              $async$next.push(23);
              // goto finally
              $async$goto = 22;
              break;
            case 21:
              // uncaught
              $async$next = [2];
            case 22:
              // finally
              $async$handler = 2;
              $async$goto = 29;
              return A._asyncStarHelper(t7.cancel$0(), $async$call$0, $async$controller);
            case 29:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 23:
              // after finally
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_5], t5)) ? 30 : 32;
              break;
            case 30:
              // then
              $name = $async$self.consume$2(B.TokenType_19, "Expect property name after '.'.");
              expr = new A.ExprGet(expr, $name, new A.ExpressionResultX());
              t7 = t4._as(expr);
              A.Primitives_objectHashCode(t7);
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 33;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, t7, B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$call$0, $async$controller);
            case 33:
              // after yield
              $async$goto = 34;
              return A._asyncStarHelper(t8, $async$call$0, $async$controller);
            case 34:
              // returning from await.
              // goto join
              $async$goto = 31;
              break;
            case 32:
              // else
              // goto after for
              $async$goto = 15;
              break;
            case 31:
              // join
            case 17:
              // join
              // goto for condition
              $async$goto = 14;
              break;
            case 15:
              // after for
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 35;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$call$0, $async$controller);
            case 35:
              // after yield
              $async$goto = 36;
              return A._asyncStarHelper(t1, $async$call$0, $async$controller);
            case 36:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, item0, yyy0, t4, t5, t6, t7, t8, t9, $name, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    finishCall$1(callee) {
      var $async$finishCall$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$finishCall$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$finishCall$1, $async$controller);
            case 4:
              // returning from await.
              $arguments = A._setArrayType([], type$.JSArray_Expr);
              $async$goto = !$async$self.check$1(B.TokenType_1) ? 5 : 6;
              break;
            case 5:
              // then
              t2 = type$.JSArray_TokenType;
              t4 = type$.Object;
              t5 = type$._StreamIterator_ParserState;
              t6 = $async$self.tokens;
            case 7:
              // do body
              $async$goto = $arguments.length >= 255 ? 10 : 11;
              break;
            case 10:
              // then
              t7 = $async$self.current;
              if (!(t7 < t6.length)) {
                A.ioore(t6, t7);
                // goto return
                $async$goto = 1;
                break;
              }
              A.Language_error(t6[t7], "Can't have more than 255 arguments");
              t7 = $async$self.current;
              if (!(t7 < t6.length)) {
                A.ioore(t6, t7);
                // goto return
                $async$goto = 1;
                break;
              }
              yyy0 = $async$self.addError$2(t6[t7], "Can't have more than 255 arguments");
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$finishCall$1, $async$controller);
            case 12:
              // after yield
              $async$goto = 13;
              return A._asyncStarHelper(yyy0.completer.future, $async$finishCall$1, $async$controller);
            case 13:
              // returning from await.
            case 11:
              // join
              expr = new A.ExprNull(new A.ExpressionResultX());
              t7 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", t4), t5);
              $async$handler = 14;
            case 17:
              // for condition
              $async$temp1 = A;
              $async$goto = 19;
              return A._asyncStarHelper(t7.moveNext$0(), $async$finishCall$1, $async$controller);
            case 19:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 18;
                break;
              }
              item = t7.get$current();
              t8 = item.type;
              $async$goto = t8 === B.ParserStateType_5 || t8 === B.ParserStateType_6 ? 20 : 22;
              break;
            case 20:
              // then
              t8 = item.completer;
              t9 = t8.future;
              if ((t9._state & 30) === 0) {
                t8 = t8.$ti;
                t8._eval$1("1/?")._as(0);
                t9._asyncComplete$1(t8._eval$1("1/")._as(0));
              }
              t8 = item.expression;
              t8.toString;
              expr = t8;
              // goto join
              $async$goto = 21;
              break;
            case 22:
              // else
              yyy = item;
              $async$goto = 23;
              $async$nextWhenCanceled = [1, 15];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$finishCall$1, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(yyy.completer.future, $async$finishCall$1, $async$controller);
            case 24:
              // returning from await.
            case 21:
              // join
              // goto for condition
              $async$goto = 17;
              break;
            case 18:
              // after for
              $async$next.push(16);
              // goto finally
              $async$goto = 15;
              break;
            case 14:
              // uncaught
              $async$next = [2];
            case 15:
              // finally
              $async$handler = 2;
              $async$goto = 25;
              return A._asyncStarHelper(t7.cancel$0(), $async$finishCall$1, $async$controller);
            case 25:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 16:
              // after finally
              B.JSArray_methods.add$1($arguments, expr);
              t7 = A.Token_Token$empty();
              t8 = new A._Future($.Zone__current, t1);
              $async$goto = 26;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprCall(callee, t7, $arguments, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t8, t3))), $async$finishCall$1, $async$controller);
            case 26:
              // after yield
              $async$goto = 27;
              return A._asyncStarHelper(t8, $async$finishCall$1, $async$controller);
            case 27:
              // returning from await.
            case 8:
              // do condition
              if ($async$self.match$1(A._setArrayType([B.TokenType_4], t2))) {
                // goto do body
                $async$goto = 7;
                break;
              }
            case 9:
              // after do
            case 6:
              // join
              $async$goto = 28;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprCall(callee, $async$self.consume$2(B.TokenType_1, "Expect ')' after arguments"), $arguments, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(new A._Future($.Zone__current, t1), t3))), $async$finishCall$1, $async$controller);
            case 28:
              // after yield
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 29;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$finishCall$1, $async$controller);
            case 29:
              // after yield
              $async$goto = 30;
              return A._asyncStarHelper(t1, $async$finishCall$1, $async$controller);
            case 30:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$finishCall$1, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, $arguments, t4, t5, t6, t7, yyy0, t8, t9, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    },
    primary$0() {
      var $async$primary$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$._Future_int;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_int;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_8, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 4:
              // returning from await.
              t2 = type$.JSArray_TokenType;
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_25], t2)) ? 5 : 7;
              break;
            case 5:
              // then
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprLiteral(false, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 8:
              // after yield
              $async$goto = 9;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 9:
              // returning from await.
              // goto join
              $async$goto = 6;
              break;
            case 7:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_35], t2)) ? 10 : 12;
              break;
            case 10:
              // then
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 13;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprLiteral(true, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 13:
              // after yield
              $async$goto = 14;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 14:
              // returning from await.
              // goto join
              $async$goto = 11;
              break;
            case 12:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_29], t2)) ? 15 : 17;
              break;
            case 15:
              // then
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 18;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprLiteral(null, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 18:
              // after yield
              $async$goto = 19;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 19:
              // returning from await.
              // goto join
              $async$goto = 16;
              break;
            case 17:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_21, B.TokenType_20], t2)) ? 20 : 22;
              break;
            case 20:
              // then
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              t4 = t2[t4];
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 23;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprLiteral(t4.literal, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 23:
              // after yield
              $async$goto = 24;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 24:
              // returning from await.
              // goto join
              $async$goto = 21;
              break;
            case 22:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_33], t2)) ? 25 : 27;
              break;
            case 25:
              // then
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              keyword = t2[t4];
              $async$self.consume$2(B.TokenType_5, "Expect '.' after 'super'.");
              method = $async$self.consume$2(B.TokenType_19, "Expect superclass method name.");
              t4 = new A._Future($.Zone__current, t1);
              $async$goto = 28;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprSuper(keyword, method, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t4, t3))), $async$primary$0, $async$controller);
            case 28:
              // after yield
              $async$goto = 29;
              return A._asyncStarHelper(t4, $async$primary$0, $async$controller);
            case 29:
              // returning from await.
              // goto join
              $async$goto = 26;
              break;
            case 27:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_34], t2)) ? 30 : 32;
              break;
            case 30:
              // then
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              t4 = t2[t4];
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 33;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprThis(t4, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 33:
              // after yield
              $async$goto = 34;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 34:
              // returning from await.
              // goto join
              $async$goto = 31;
              break;
            case 32:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_19], t2)) ? 35 : 37;
              break;
            case 35:
              // then
              t2 = $async$self.tokens;
              t4 = $async$self.current - 1;
              if (!(t4 >= 0 && t4 < t2.length)) {
                A.ioore(t2, t4);
                // goto return
                $async$goto = 1;
                break;
              }
              t4 = t2[t4];
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 38;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprVariable(t4, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t2, t3))), $async$primary$0, $async$controller);
            case 38:
              // after yield
              $async$goto = 39;
              return A._asyncStarHelper(t2, $async$primary$0, $async$controller);
            case 39:
              // returning from await.
              // goto join
              $async$goto = 36;
              break;
            case 37:
              // else
              $async$goto = $async$self.match$1(A._setArrayType([B.TokenType_0], t2)) ? 40 : 42;
              break;
            case 40:
              // then
              expr = new A.ExprNull(new A.ExpressionResultX());
              t2 = new A._StreamIterator(A.checkNotNullable($async$self.expression$0(), "stream", type$.Object), type$._StreamIterator_ParserState);
              $async$handler = 43;
            case 46:
              // for condition
              $async$temp1 = A;
              $async$goto = 48;
              return A._asyncStarHelper(t2.moveNext$0(), $async$primary$0, $async$controller);
            case 48:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 47;
                break;
              }
              item = t2.get$current();
              t4 = item.type;
              if (t4 === B.ParserStateType_5 || t4 === B.ParserStateType_6) {
                t4 = item.expression;
                t4.toString;
                expr = t4;
              }
              yyy = item;
              $async$goto = 49;
              $async$nextWhenCanceled = [1, 44];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$primary$0, $async$controller);
            case 49:
              // after yield
              $async$goto = 50;
              return A._asyncStarHelper(yyy.completer.future, $async$primary$0, $async$controller);
            case 50:
              // returning from await.
              // goto for condition
              $async$goto = 46;
              break;
            case 47:
              // after for
              $async$next.push(45);
              // goto finally
              $async$goto = 44;
              break;
            case 43:
              // uncaught
              $async$next = [2];
            case 44:
              // finally
              $async$handler = 2;
              $async$goto = 51;
              return A._asyncStarHelper(t2.cancel$0(), $async$primary$0, $async$controller);
            case 51:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 45:
              // after finally
              $async$self.consume$2(B.TokenType_1, "Expect ')' after expressoin.");
              t2 = expr;
              t4 = new A._Future($.Zone__current, t1);
              $async$goto = 52;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, new A.ExprGrouping(t2, new A.ExpressionResultX()), B.ParserStateType_5, new A._AsyncCompleter(t4, t3))), $async$primary$0, $async$controller);
            case 52:
              // after yield
              $async$goto = 53;
              return A._asyncStarHelper(t4, $async$primary$0, $async$controller);
            case 53:
              // returning from await.
              // goto join
              $async$goto = 41;
              break;
            case 42:
              // else
              t1 = $async$self.tokens;
              t2 = $async$self.current;
              if (!(t2 < t1.length)) {
                A.ioore(t1, t2);
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = t1[t2];
              yyy = $async$self.addError$2(t2, "Current token of '" + t2.type._name + "' is not expected.");
              $async$goto = 54;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$primary$0, $async$controller);
            case 54:
              // after yield
              $async$goto = 55;
              return A._asyncStarHelper(yyy.completer.future, $async$primary$0, $async$controller);
            case 55:
              // returning from await.
              throw A.wrapException(A.ParseError$("Current token of '" + $async$self.peek$0().type.toString$0(0) + "' is not expected."));
            case 41:
              // join
            case 36:
              // join
            case 31:
              // join
            case 26:
              // join
            case 21:
              // join
            case 16:
              // join
            case 11:
              // join
            case 6:
              // join
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 56;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ParserState(null, null, B.ParserStateType_9, new A._AsyncCompleter(t1, t3))), $async$primary$0, $async$controller);
            case 56:
              // after yield
              $async$goto = 57;
              return A._asyncStarHelper(t1, $async$primary$0, $async$controller);
            case 57:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$primary$0, type$.ParserState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expr, item, yyy, t4, keyword, method, t1, t2, t3, $async$temp1;
      return A._streamOfController($async$controller);
    }
  };
  A.FunctionType.prototype = {
    _enumToString$0() {
      return "FunctionType." + this._name;
    }
  };
  A.ClassType.prototype = {
    _enumToString$0() {
      return "ClassType." + this._name;
    }
  };
  A.ResolveInfoType.prototype = {
    _enumToString$0() {
      return "ResolveInfoType." + this._name;
    }
  };
  A.ResolveInfo.prototype = {};
  A.Resolver.prototype = {
    addError$2(token, message) {
      var $async$addError$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              error = A.Language_error(token, message);
              B.JSArray_methods.add$1($async$self.errors, error);
              t1 = $async$self.depth;
              t1 = A.ResolveInfo$(t1, B.JSString_methods.$mul("     ", t1) + error, B.ResolveInfoType_6);
              throw A.wrapException(t1);
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$addError$2, type$.ResolveInfo),
        $async$handler = 2, $async$currentError, $async$self = this, t1, error;
      return A._streamOfController($async$controller);
    },
    _addVisit$1(message) {
      B.JSString_methods.$mul("|    ", this.depth);
      B.JSArray_methods.add$1(this.outputData, new A.ResolveInfo());
    },
    _addScope$1(message) {
      B.JSString_methods.$mul("|    ", this.depth);
      B.JSArray_methods.add$1(this.outputData, new A.ResolveInfo());
    },
    _wrapStmt$2$message(stmt, message) {
      A.Primitives_objectHashCode(stmt);
      B.JSString_methods.$mul("|    ", this.depth);
      return new A.ResolveInfo();
    },
    _wrapExpr$2$message(expr, message) {
      A.Primitives_objectHashCode(expr);
      B.JSString_methods.$mul("|    ", this.depth);
      return new A.ResolveInfo();
    },
    _wrapResolve$1$message(message) {
      B.JSString_methods.$mul("|    ", this.depth);
      return new A.ResolveInfo();
    },
    _wrapAction$1$message(message) {
      B.JSString_methods.$mul("|    ", this.depth);
      return new A.ResolveInfo();
    },
    resolveAll$1(statements) {
      return this.resolveAll$body$Resolver(type$.List_Stmt._as(statements));
    },
    resolveAll$body$Resolver(statements) {
      var $async$resolveAll$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = statements.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < statements.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveStmt$1(statements[_i])), $async$resolveAll$1, $async$controller);
            case 6:
              // after yield
            case 4:
              // for update
              statements.length === t1 || (0, A.throwConcurrentModificationError)(statements), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$resolveAll$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, _i;
      return A._streamOfController($async$controller);
    },
    resolveStmt$1(stmt) {
      var $async$resolveStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ++$async$self.depth;
              stream = null;
              $label0$0: {
                if (stmt instanceof A.StmtVar) {
                  stream = $async$self.visitVarStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtWhile) {
                  stream = $async$self.visitWhileStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtBlock) {
                  stream = $async$self.visitBlockStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtClass) {
                  stream = $async$self.visitClassStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtExpression) {
                  stream = $async$self.visitExpressionStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtFunction) {
                  stream = $async$self.visitFunctionStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtIf) {
                  stream = $async$self.visitIfStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtPrint) {
                  stream = $async$self.visitPrintStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtReturn) {
                  stream = $async$self.visitReturnStmt$1(stmt);
                  break $label0$0;
                }
                if (stmt instanceof A.StmtNull) {
                  stream = $async$self.visitNullStmt$1(stmt);
                  break $label0$0;
                }
              }
              t1 = new A._StreamIterator(A.checkNotNullable(stream, "stream", type$.Object), type$._StreamIterator_ResolveInfo);
              $async$handler = 3;
            case 6:
              // for condition
              $async$temp1 = A;
              $async$goto = 8;
              return A._asyncStarHelper(t1.moveNext$0(), $async$resolveStmt$1, $async$controller);
            case 8:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              item = t1.get$current();
              $async$goto = 9;
              $async$nextWhenCanceled = [1, 4];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$resolveStmt$1, $async$controller);
            case 9:
              // after yield
              // goto for condition
              $async$goto = 6;
              break;
            case 7:
              // after for
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 10;
              return A._asyncStarHelper(t1.cancel$0(), $async$resolveStmt$1, $async$controller);
            case 10:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              --$async$self.depth;
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$resolveStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stream, item, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    resolveExpr$1(expr) {
      var $async$resolveExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ++$async$self.depth;
              stream = null;
              $label0$0: {
                if (expr instanceof A.ExprLiteral) {
                  stream = $async$self.visitLiteralExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprBinary) {
                  stream = $async$self.visitBinaryExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprVariable) {
                  stream = $async$self.visitVariableExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprAssign) {
                  stream = $async$self.visitAssignExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprCall) {
                  stream = $async$self.visitCallExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprGet) {
                  stream = $async$self.visitGetExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprGrouping) {
                  stream = $async$self.visitGroupingExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprLogical) {
                  stream = $async$self.visitLogicalExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprSet) {
                  stream = $async$self.visitSetExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprThis) {
                  stream = $async$self.visitThisExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprSuper) {
                  stream = $async$self.visitSuperExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprUnary) {
                  stream = $async$self.visitUnaryExpr$1(expr);
                  break $label0$0;
                }
                if (expr instanceof A.ExprNull) {
                  stream = $async$self.visitNullExpr$1(expr);
                  break $label0$0;
                }
              }
              t1 = new A._StreamIterator(A.checkNotNullable(stream, "stream", type$.Object), type$._StreamIterator_ResolveInfo);
              $async$handler = 3;
            case 6:
              // for condition
              $async$temp1 = A;
              $async$goto = 8;
              return A._asyncStarHelper(t1.moveNext$0(), $async$resolveExpr$1, $async$controller);
            case 8:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              item = t1.get$current();
              $async$goto = 9;
              $async$nextWhenCanceled = [1, 4];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(item), $async$resolveExpr$1, $async$controller);
            case 9:
              // after yield
              // goto for condition
              $async$goto = 6;
              break;
            case 7:
              // after for
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 10;
              return A._asyncStarHelper(t1.cancel$0(), $async$resolveExpr$1, $async$controller);
            case 10:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              --$async$self.depth;
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$resolveExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stream, item, t1, $async$temp1;
      return A._streamOfController($async$controller);
    },
    resolveLocal$2(expr, $name) {
      var $async$resolveLocal$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ++$async$self.depth;
              t1 = $name.lexeme;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapResolve$1$message("resolveLocal: '" + t1 + "'")), $async$resolveLocal$2, $async$controller);
            case 3:
              // after yield
              t2 = $async$self.scopes;
              i = t2.length - 1;
            case 4:
              // while condition
              if (!(i >= 0)) {
                found = false;
                // goto after while
                $async$goto = 5;
                break;
              }
              if (!(i < t2.length)) {
                A.ioore(t2, i);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = t2[i].containsKey$1(t1) ? 6 : 7;
              break;
            case 6:
              // then
              A.Primitives_objectHashCode(expr);
              B.JSString_methods.$mul("|    ", $async$self.depth);
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ResolveInfo()), $async$resolveLocal$2, $async$controller);
            case 8:
              // after yield
              $async$self.interpreter.locals.$indexSet(0, expr, t2.length - 1 - i);
              A.Primitives_objectHashCode(expr);
              B.JSString_methods.$mul("|    ", $async$self.depth);
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ResolveInfo()), $async$resolveLocal$2, $async$controller);
            case 9:
              // after yield
              found = true;
              // goto after while
              $async$goto = 5;
              break;
            case 7:
              // join
              --i;
              // goto while condition
              $async$goto = 4;
              break;
            case 5:
              // after while
              $async$goto = !found ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Name '" + t1 + "' NOT found in local scopes. DO NOTHING.")), $async$resolveLocal$2, $async$controller);
            case 12:
              // after yield
            case 11:
              // join
              --$async$self.depth;
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$resolveLocal$2, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, found, t2, i;
      return A._streamOfController($async$controller);
    },
    resolveFunction$2($function, type) {
      var $async$resolveFunction$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ++$async$self.depth;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapResolve$1$message("resolveFunction: " + type.toString$0(0))), $async$resolveFunction$2, $async$controller);
            case 3:
              // after yield
              enclosingFunction = $async$self.currentFunction;
              $async$self.currentFunction = type;
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.beginScope$0()), $async$resolveFunction$2, $async$controller);
            case 4:
              // after yield
              t1 = $function.params, t2 = t1.length, _i = 0;
            case 5:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              param = t1[_i];
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declare$1(param)), $async$resolveFunction$2, $async$controller);
            case 8:
              // after yield
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.define$1(param)), $async$resolveFunction$2, $async$controller);
            case 9:
              // after yield
            case 6:
              // for update
              t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
              $async$goto = 10;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveAll$1($function.body)), $async$resolveFunction$2, $async$controller);
            case 10:
              // after yield
              $async$goto = 11;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.endScope$0()), $async$resolveFunction$2, $async$controller);
            case 11:
              // after yield
              $async$self.currentFunction = enclosingFunction;
              --$async$self.depth;
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$resolveFunction$2, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, enclosingFunction, t1, t2, _i, param;
      return A._streamOfController($async$controller);
    },
    beginScope$0() {
      var $async$beginScope$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scopes;
              B.JSArray_methods.add$1(t1, new A.JsLinkedHashMap(type$.JsLinkedHashMap_String_bool));
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("BEGIN scope:" + A.S(t1))), $async$beginScope$0, $async$controller);
            case 3:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$beginScope$0, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    endScope$0() {
      var $async$endScope$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scopes;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("END scope:" + A.S(t1))), $async$endScope$0, $async$controller);
            case 3:
              // after yield
              if (0 >= t1.length) {
                A.ioore(t1, -1);
                // goto return
                $async$goto = 1;
                break;
              }
              t1.pop();
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$endScope$0, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    declare$1($name) {
      var $async$declare$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scopes;
              if (t1.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = $name.lexeme;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("DECLARE: '" + t2 + "'")), $async$declare$1, $async$controller);
            case 3:
              // after yield
              scope = B.JSArray_methods.get$last(t1);
              $async$goto = scope.containsKey$1(t2) ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2($name, "Already  declared variable with this name in this scope.")), $async$declare$1, $async$controller);
            case 6:
              // after yield
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // join
              scope.$indexSet(0, t2, false);
              $async$self._addScope$1("scopes: " + A.S(t1));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$declare$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t2, scope, t1;
      return A._streamOfController($async$controller);
    },
    define$1($name) {
      var $async$define$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scopes;
              if (t1.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = $name.lexeme;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("DEFINE: '" + t2 + "'")), $async$define$1, $async$controller);
            case 3:
              // after yield
              B.JSArray_methods.get$last(t1).$indexSet(0, t2, true);
              $async$self._addScope$1("scopes: " + A.S(t1));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$define$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t2, t1;
      return A._streamOfController($async$controller);
    },
    visitFunctionStmt$1(stmt) {
      return this.visitFunctionStmt$body$Resolver(type$.StmtFunction._as(stmt));
    },
    visitFunctionStmt$body$Resolver(stmt) {
      var $async$visitFunctionStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = stmt.name;
              t2 = t1.lexeme;
              $async$self._addVisit$1(stmt.toString$0(0) + " '" + t2 + "'");
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: " + A.getRuntimeTypeOfDartObject(stmt).toString$0(0) + " '" + t2 + "'")), $async$visitFunctionStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declare$1(t1)), $async$visitFunctionStmt$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.define$1(t1)), $async$visitFunctionStmt$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveFunction$2(stmt, B.FunctionType_1)), $async$visitFunctionStmt$1, $async$controller);
            case 6:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitFunctionStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, t2;
      return A._streamOfController($async$controller);
    },
    visitExpressionStmt$1(stmt) {
      return this.visitExpressionStmt$body$Resolver(type$.StmtExpression._as(stmt));
    },
    visitExpressionStmt$body$Resolver(stmt) {
      var $async$visitExpressionStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: ExpressionStmt")), $async$visitExpressionStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(stmt.expression)), $async$visitExpressionStmt$1, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitExpressionStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitPrintStmt$1(stmt) {
      return this.visitPrintStmt$body$Resolver(type$.StmtPrint._as(stmt));
    },
    visitPrintStmt$body$Resolver(stmt) {
      var $async$visitPrintStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: PrintStmt")), $async$visitPrintStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(stmt.expression)), $async$visitPrintStmt$1, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitPrintStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitReturnStmt$1(stmt) {
      return this.visitReturnStmt$body$Resolver(type$.StmtReturn._as(stmt));
    },
    visitReturnStmt$body$Resolver(stmt) {
      var $async$visitReturnStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: ReturnStmt")), $async$visitReturnStmt$1, $async$controller);
            case 3:
              // after yield
              $async$goto = $async$self.currentFunction === B.FunctionType_0 ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(stmt.keyword, "Can't return from top-level code")), $async$visitReturnStmt$1, $async$controller);
            case 6:
              // after yield
            case 5:
              // join
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified that return is not top level")), $async$visitReturnStmt$1, $async$controller);
            case 7:
              // after yield
              t1 = stmt.value;
              $async$goto = !(t1 instanceof A.ExprNull) ? 8 : 9;
              break;
            case 8:
              // then
              $async$goto = $async$self.currentFunction === B.FunctionType_2 ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(stmt.keyword, "Can't return a value from an initializer")), $async$visitReturnStmt$1, $async$controller);
            case 12:
              // after yield
            case 11:
              // join
              $async$goto = 13;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified not returning value from init")), $async$visitReturnStmt$1, $async$controller);
            case 13:
              // after yield
              $async$goto = 14;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(t1)), $async$visitReturnStmt$1, $async$controller);
            case 14:
              // after yield
            case 9:
              // join
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitReturnStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitWhileStmt$1(stmt) {
      return this.visitWhileStmt$body$Resolver(type$.StmtWhile._as(stmt));
    },
    visitWhileStmt$body$Resolver(stmt) {
      var $async$visitWhileStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: WhileStmt")), $async$visitWhileStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(stmt.condition)), $async$visitWhileStmt$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveStmt$1(stmt.body)), $async$visitWhileStmt$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitWhileStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitBlockStmt$1(stmt) {
      return this.visitBlockStmt$body$Resolver(type$.StmtBlock._as(stmt));
    },
    visitBlockStmt$body$Resolver(stmt) {
      var $async$visitBlockStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: BlockStmt")), $async$visitBlockStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.beginScope$0()), $async$visitBlockStmt$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveAll$1(stmt.statements)), $async$visitBlockStmt$1, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.endScope$0()), $async$visitBlockStmt$1, $async$controller);
            case 6:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitBlockStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitVarStmt$1(stmt) {
      return this.visitVarStmt$body$Resolver(type$.StmtVar._as(stmt));
    },
    visitVarStmt$body$Resolver(stmt) {
      var $async$visitVarStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: VarStmt")), $async$visitVarStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              t1 = stmt.name;
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declare$1(t1)), $async$visitVarStmt$1, $async$controller);
            case 4:
              // after yield
              t2 = stmt.initializer;
              $async$goto = !(t2 instanceof A.ExprNull) ? 5 : 6;
              break;
            case 5:
              // then
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(t2)), $async$visitVarStmt$1, $async$controller);
            case 7:
              // after yield
            case 6:
              // join
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.define$1(t1)), $async$visitVarStmt$1, $async$controller);
            case 8:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitVarStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, t2;
      return A._streamOfController($async$controller);
    },
    visitIfStmt$1(stmt) {
      return this.visitIfStmt$body$Resolver(type$.StmtIf._as(stmt));
    },
    visitIfStmt$body$Resolver(stmt) {
      var $async$visitIfStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: IfStmt")), $async$visitIfStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(stmt.condition)), $async$visitIfStmt$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveStmt$1(stmt.thenBranch)), $async$visitIfStmt$1, $async$controller);
            case 5:
              // after yield
              t1 = stmt.elseBranch;
              $async$goto = !(t1 instanceof A.StmtNull) ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveStmt$1(t1)), $async$visitIfStmt$1, $async$controller);
            case 8:
              // after yield
            case 7:
              // join
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitIfStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitClassStmt$1(stmt) {
      return this.visitClassStmt$body$Resolver(type$.StmtClass._as(stmt));
    },
    visitClassStmt$body$Resolver(stmt) {
      var $async$visitClassStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: ClassStmt")), $async$visitClassStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
              enclosingClass = $async$self.currentClass;
              $async$self.currentClass = B.ClassType_1;
              t1 = stmt.name;
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.declare$1(t1)), $async$visitClassStmt$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.define$1(t1)), $async$visitClassStmt$1, $async$controller);
            case 5:
              // after yield
              t2 = stmt.superClass;
              t3 = t2 != null;
              $async$goto = t3 && t1.lexeme === t2.name.lexeme ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(t2.name, "A class can't inherit from itself.")), $async$visitClassStmt$1, $async$controller);
            case 8:
              // after yield
            case 7:
              // join
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified class != superClass")), $async$visitClassStmt$1, $async$controller);
            case 9:
              // after yield
              $async$goto = t3 ? 10 : 11;
              break;
            case 10:
              // then
              $async$self.currentClass = B.ClassType_2;
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(t2)), $async$visitClassStmt$1, $async$controller);
            case 12:
              // after yield
            case 11:
              // join
              $async$goto = t3 ? 13 : 14;
              break;
            case 13:
              // then
              $async$goto = 15;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.beginScope$0()), $async$visitClassStmt$1, $async$controller);
            case 15:
              // after yield
              B.JSArray_methods.get$last($async$self.scopes).$indexSet(0, "super", true);
            case 14:
              // join
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.beginScope$0()), $async$visitClassStmt$1, $async$controller);
            case 16:
              // after yield
              B.JSArray_methods.get$last($async$self.scopes).$indexSet(0, "this", true);
              t1 = stmt.methods, t2 = t1.length, _i = 0;
            case 17:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 19;
                break;
              }
              method = t1[_i];
              $async$goto = 20;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveFunction$2(method, method.name.lexeme === "init" ? B.FunctionType_2 : B.FunctionType_3)), $async$visitClassStmt$1, $async$controller);
            case 20:
              // after yield
            case 18:
              // for update
              t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 17;
              break;
            case 19:
              // after for
              $async$goto = 21;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.endScope$0()), $async$visitClassStmt$1, $async$controller);
            case 21:
              // after yield
              $async$goto = t3 ? 22 : 23;
              break;
            case 22:
              // then
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.endScope$0()), $async$visitClassStmt$1, $async$controller);
            case 24:
              // after yield
            case 23:
              // join
              $async$self.currentClass = enclosingClass;
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitClassStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, enclosingClass, t1, t2, t3, _i, method;
      return A._streamOfController($async$controller);
    },
    visitNullStmt$1(stmt) {
      return this.visitNullStmt$body$Resolver(type$.StmtNull._as(stmt));
    },
    visitNullStmt$body$Resolver(stmt) {
      var $async$visitNullStmt$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapStmt$2$message(stmt, "ResolveStmt: NullStmt")), $async$visitNullStmt$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(stmt.toString$0(0));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitNullStmt$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitVariableExpr$1(expr) {
      return this.visitVariableExpr$body$Resolver(type$.ExprVariable._as(expr));
    },
    visitVariableExpr$body$Resolver(expr) {
      var $async$visitVariableExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: VariableExpr")), $async$visitVariableExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              t1 = $async$self.scopes;
              $async$goto = t1.length !== 0 && J.$eq$(B.JSArray_methods.get$last(t1).$index(0, expr.name.lexeme), false) ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(expr.name, "Can't read local variable in its own initializer")), $async$visitVariableExpr$1, $async$controller);
            case 6:
              // after yield
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // join
              $async$goto = t1.length > 0 ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified variable is not init with itself")), $async$visitVariableExpr$1, $async$controller);
            case 9:
              // after yield
            case 8:
              // join
              $async$goto = 10;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveLocal$2(expr, expr.name)), $async$visitVariableExpr$1, $async$controller);
            case 10:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitVariableExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitAssignExpr$1(expr) {
      return this.visitAssignExpr$body$Resolver(type$.ExprAssign._as(expr));
    },
    visitAssignExpr$body$Resolver(expr) {
      var $async$visitAssignExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: AssignExpr")), $async$visitAssignExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.value)), $async$visitAssignExpr$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveLocal$2(expr, expr.name)), $async$visitAssignExpr$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitAssignExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitBinaryExpr$1(expr) {
      return this.visitBinaryExpr$body$Resolver(type$.ExprBinary._as(expr));
    },
    visitBinaryExpr$body$Resolver(expr) {
      var $async$visitBinaryExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: BinaryExpr")), $async$visitBinaryExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.left)), $async$visitBinaryExpr$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.right)), $async$visitBinaryExpr$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitBinaryExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitCallExpr$1(expr) {
      return this.visitCallExpr$body$Resolver(type$.ExprCall._as(expr));
    },
    visitCallExpr$body$Resolver(expr) {
      var $async$visitCallExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: CallExpr")), $async$visitCallExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.callee)), $async$visitCallExpr$1, $async$controller);
            case 4:
              // after yield
              t1 = expr.$arguments, t2 = t1.length, _i = 0;
            case 5:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(t1[_i])), $async$visitCallExpr$1, $async$controller);
            case 8:
              // after yield
            case 6:
              // for update
              t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitCallExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, t2, _i;
      return A._streamOfController($async$controller);
    },
    visitGetExpr$1(expr) {
      return this.visitGetExpr$body$Resolver(type$.ExprGet._as(expr));
    },
    visitGetExpr$body$Resolver(expr) {
      var $async$visitGetExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: GetExpr")), $async$visitGetExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.object)), $async$visitGetExpr$1, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitGetExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitGroupingExpr$1(expr) {
      return this.visitGroupingExpr$body$Resolver(type$.ExprGrouping._as(expr));
    },
    visitGroupingExpr$body$Resolver(expr) {
      var $async$visitGroupingExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: GroupingExpr")), $async$visitGroupingExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.expression)), $async$visitGroupingExpr$1, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitGroupingExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitLiteralExpr$1(expr) {
      return this.visitLiteralExpr$body$Resolver(type$.ExprLiteral._as(expr));
    },
    visitLiteralExpr$body$Resolver(expr) {
      var $async$visitLiteralExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: LiteralExpr")), $async$visitLiteralExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0) + ": " + A.S(expr.value));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitLiteralExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitLogicalExpr$1(expr) {
      return this.visitLogicalExpr$body$Resolver(type$.ExprLogical._as(expr));
    },
    visitLogicalExpr$body$Resolver(expr) {
      var $async$visitLogicalExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: LogicalExpr")), $async$visitLogicalExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.left)), $async$visitLogicalExpr$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.right)), $async$visitLogicalExpr$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitLogicalExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitSetExpr$1(expr) {
      return this.visitSetExpr$body$Resolver(type$.ExprSet._as(expr));
    },
    visitSetExpr$body$Resolver(expr) {
      var $async$visitSetExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: SetExpr")), $async$visitSetExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.object)), $async$visitSetExpr$1, $async$controller);
            case 4:
              // after yield
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.value)), $async$visitSetExpr$1, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitSetExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitSuperExpr$1(expr) {
      return this.visitSuperExpr$body$Resolver(type$.ExprSuper._as(expr));
    },
    visitSuperExpr$body$Resolver(expr) {
      var $async$visitSuperExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: SuperExpr")), $async$visitSuperExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              t1 = $async$self.currentClass;
              $async$goto = t1 === B.ClassType_0 ? 4 : 6;
              break;
            case 4:
              // then
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(expr.keyword, "Can't user 'super' outside of a class.")), $async$visitSuperExpr$1, $async$controller);
            case 7:
              // after yield
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$goto = t1 !== B.ClassType_2 ? 8 : 9;
              break;
            case 8:
              // then
              $async$goto = 10;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(expr.keyword, "Can't user 'super' in a class with no superclass.")), $async$visitSuperExpr$1, $async$controller);
            case 10:
              // after yield
              // goto return
              $async$goto = 1;
              break;
            case 9:
              // join
            case 5:
              // join
              $async$goto = 11;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified super is used inside class")), $async$visitSuperExpr$1, $async$controller);
            case 11:
              // after yield
              $async$goto = 12;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified class has superclass")), $async$visitSuperExpr$1, $async$controller);
            case 12:
              // after yield
              $async$goto = 13;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveLocal$2(expr, expr.keyword)), $async$visitSuperExpr$1, $async$controller);
            case 13:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitSuperExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      return A._streamOfController($async$controller);
    },
    visitThisExpr$1(expr) {
      return this.visitThisExpr$body$Resolver(type$.ExprThis._as(expr));
    },
    visitThisExpr$body$Resolver(expr) {
      var $async$visitThisExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: ThisExpr")), $async$visitThisExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = $async$self.currentClass === B.ClassType_0 ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.addError$2(expr.keyword, "Can't use 'this' outside of a class.")), $async$visitThisExpr$1, $async$controller);
            case 6:
              // after yield
            case 5:
              // join
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapAction$1$message("Verified this is used inside a class")), $async$visitThisExpr$1, $async$controller);
            case 7:
              // after yield
              $async$goto = 8;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveLocal$2(expr, expr.keyword)), $async$visitThisExpr$1, $async$controller);
            case 8:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitThisExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitUnaryExpr$1(expr) {
      return this.visitUnaryExpr$body$Resolver(type$.ExprUnary._as(expr));
    },
    visitUnaryExpr$body$Resolver(expr) {
      var $async$visitUnaryExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "ResolveExpr: UnaryExpr")), $async$visitUnaryExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldStar($async$self.resolveExpr$1(expr.right)), $async$visitUnaryExpr$1, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitUnaryExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    },
    visitNullExpr$1(expr) {
      return this.visitNullExpr$body$Resolver(type$.ExprNull._as(expr));
    },
    visitNullExpr$body$Resolver(expr) {
      var $async$visitNullExpr$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle($async$self._wrapExpr$2$message(expr, "visitNullExpr")), $async$visitNullExpr$1, $async$controller);
            case 3:
              // after yield
              $async$self._addVisit$1(expr.toString$0(0));
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$visitNullExpr$1, type$.ResolveInfo),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this;
      return A._streamOfController($async$controller);
    }
  };
  A.ScanStateType.prototype = {
    _enumToString$0() {
      return "ScanStateType." + this._name;
    }
  };
  A.ScanState.prototype = {};
  A.Scanner.prototype = {
    addError$2(line, error) {
      var ee = "Line " + line + ": " + error;
      B.JSArray_methods.add$1(this.errors, ee);
      return this.addToken$2$literal(B.TokenType_38, ee);
    },
    advance$0() {
      var t1 = this.source,
        t2 = ++this.current - 1;
      if (!(t2 < t1.length))
        return A.ioore(t1, t2);
      return t1[t2];
    },
    advanceLine$0() {
      this.currentLineOffsetStart = this.current;
      ++this.line;
    },
    addToken$2$literal(type, literal) {
      var _this = this,
        token = new A.Token(type, _this.getSubstring$2(_this.start, _this.current), literal, _this.line);
      B.JSArray_methods.add$1(_this.tokens, token);
      return new A.ScanState(token, B.ScanStateType_2, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
    },
    addToken$1(type) {
      return this.addToken$2$literal(type, null);
    },
    match$1(expected) {
      var t1 = this.current,
        t2 = this.source;
      if (t1 >= t2.length)
        return false;
      if (t2[t1] !== expected)
        return false;
      this.current = t1 + 1;
      return true;
    },
    peek$0() {
      var t1 = this.current,
        t2 = this.source;
      if (t1 >= t2.length)
        return null;
      return t2[t1];
    },
    peekNext$0() {
      var t1 = this.current + 1,
        t2 = this.source;
      if (t1 >= t2.length)
        return null;
      return t2[t1];
    },
    isDigit$1(c) {
      if (c == null)
        return false;
      return c === "0" || c === "1" || c === "2" || c === "3" || c === "4" || c === "5" || c === "6" || c === "7" || c === "8" || c === "9";
    },
    isAlpha$1(c) {
      var result;
      if (0 >= c.length)
        return A.ioore(c, 0);
      if (!(c.charCodeAt(0) >= 97 && c.charCodeAt(0) <= 122))
        result = c.charCodeAt(0) >= 65 && c.charCodeAt(0) <= 90 || c.charCodeAt(0) === 95;
      else
        result = true;
      return result;
    },
    isAlphaNumeric$1(c) {
      var _this = this;
      if (c == null)
        return false;
      _this.isAlpha$1(c);
      _this.isDigit$1(c);
      return _this.isAlpha$1(c) || _this.isDigit$1(c);
    },
    number$0() {
      var $async$number$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.source, t2 = t1.length, t3 = type$._Future_dynamic, t4 = type$._AsyncCompleter_dynamic;
            case 3:
              // for condition
              if (!$async$self.isDigit$1($async$self.peek$0())) {
                // goto after for
                $async$goto = 4;
                break;
              }
              t5 = ++$async$self.current - 1;
              if (!(t5 < t2)) {
                A.ioore(t1, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              A._charDescription(t1[t5]);
              t5 = new A._Future($.Zone__current, t3);
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t5, t4))), $async$number$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(t5, $async$number$0, $async$controller);
            case 6:
              // returning from await.
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$goto = $async$self.peek$0() === "." && $async$self.isDigit$1($async$self.peekNext$0()) ? 7 : 8;
              break;
            case 7:
              // then
              $async$self.advance$0();
              t5 = new A._Future($.Zone__current, t3);
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t5, t4))), $async$number$0, $async$controller);
            case 9:
              // after yield
              $async$goto = 10;
              return A._asyncStarHelper(t5, $async$number$0, $async$controller);
            case 10:
              // returning from await.
            case 11:
              // for condition
              if (!$async$self.isDigit$1($async$self.peek$0())) {
                // goto after for
                $async$goto = 12;
                break;
              }
              t5 = ++$async$self.current - 1;
              if (!(t5 < t2)) {
                A.ioore(t1, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              t5 = new A._Future($.Zone__current, t3);
              $async$goto = 13;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t5, t4))), $async$number$0, $async$controller);
            case 13:
              // after yield
              $async$goto = 14;
              return A._asyncStarHelper(t5, $async$number$0, $async$controller);
            case 14:
              // returning from await.
              // goto for condition
              $async$goto = 11;
              break;
            case 12:
              // after for
            case 8:
              // join
              $async$handler = 16;
              n = A.double_parse($async$self.getSubstring$2($async$self.start, $async$self.current));
              yyy = $async$self.addToken$2$literal(B.TokenType_21, n);
              $async$goto = 19;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$number$0, $async$controller);
            case 19:
              // after yield
              $async$goto = 20;
              return A._asyncStarHelper(yyy.completer.future, $async$number$0, $async$controller);
            case 20:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 18;
              break;
            case 16:
              // catch
              $async$handler = 15;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              yyy0 = $async$self.addError$2($async$self.line, 'Error parsing string "' + $async$self.getSubstring$2($async$self.start, $async$self.current) + '", [start: ' + $async$self.start + ", end: " + $async$self.current + "]: " + A.S(e) + ": ");
              $async$goto = 21;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(type$.ScanState._as(yyy0)), $async$number$0, $async$controller);
            case 21:
              // after yield
              t1 = yyy0.completer;
              $async$goto = 22;
              return A._asyncStarHelper(t1.future, $async$number$0, $async$controller);
            case 22:
              // returning from await.
              // goto after finally
              $async$goto = 18;
              break;
            case 15:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 18:
              // after finally
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$number$0, type$.ScanState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, n, yyy, e, yyy0, t1, t2, t3, t4, t5, exception, $async$exception;
      return A._streamOfController($async$controller);
    },
    identifier$0() {
      var $async$identifier$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.source, t2 = t1.length, t3 = type$._Future_dynamic, t4 = type$._AsyncCompleter_dynamic;
            case 3:
              // for condition
              if (!$async$self.isAlphaNumeric$1($async$self.peek$0())) {
                // goto after for
                $async$goto = 4;
                break;
              }
              t5 = ++$async$self.current - 1;
              if (!(t5 < t2)) {
                A.ioore(t1, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              A._charDescription(t1[t5]);
              t5 = new A._Future($.Zone__current, t3);
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t5, t4))), $async$identifier$0, $async$controller);
            case 5:
              // after yield
              $async$goto = 6;
              return A._asyncStarHelper(t5, $async$identifier$0, $async$controller);
            case 6:
              // returning from await.
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              text = $async$self.getSubstring$2($async$self.start, $async$self.current);
              type = $.$get$Scanner_keywords().$index(0, text);
              yyy = $async$self.addToken$1(type == null ? B.TokenType_19 : type);
              $async$goto = 7;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$identifier$0, $async$controller);
            case 7:
              // after yield
              $async$goto = 8;
              return A._asyncStarHelper(yyy.completer.future, $async$identifier$0, $async$controller);
            case 8:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$identifier$0, type$.ScanState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, t2, t3, t4, t5, text, type, yyy;
      return A._streamOfController($async$controller);
    },
    getSubstring$2(start, end) {
      var t1 = this.source,
        max = t1.length;
      if (start > end)
        return "a";
      if (start > max)
        return "b";
      return B.JSString_methods.substring$2(t1, start, end > max ? max : end);
    },
    scanToken$0() {
      var $async$scanToken$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              c = $async$self.advance$0();
            case 3:
              // switch
              switch (c) {
                case "(":
                  // goto case
                  $async$goto = 5;
                  break;
                case ")":
                  // goto case
                  $async$goto = 6;
                  break;
                case "{":
                  // goto case
                  $async$goto = 7;
                  break;
                case "}":
                  // goto case
                  $async$goto = 8;
                  break;
                case ",":
                  // goto case
                  $async$goto = 9;
                  break;
                case ".":
                  // goto case
                  $async$goto = 10;
                  break;
                case "-":
                  // goto case
                  $async$goto = 11;
                  break;
                case "+":
                  // goto case
                  $async$goto = 12;
                  break;
                case ";":
                  // goto case
                  $async$goto = 13;
                  break;
                case "*":
                  // goto case
                  $async$goto = 14;
                  break;
                case "!":
                  // goto case
                  $async$goto = 15;
                  break;
                case "=":
                  // goto case
                  $async$goto = 16;
                  break;
                case "<":
                  // goto case
                  $async$goto = 17;
                  break;
                case ">":
                  // goto case
                  $async$goto = 18;
                  break;
                case "/":
                  // goto case
                  $async$goto = 19;
                  break;
                case " ":
                  // goto case
                  $async$goto = 20;
                  break;
                case "\r":
                  // goto case
                  $async$goto = 21;
                  break;
                case "\t":
                  // goto case
                  $async$goto = 22;
                  break;
                case "\n":
                  // goto case
                  $async$goto = 23;
                  break;
                case '"':
                  // goto case
                  $async$goto = 24;
                  break;
                default:
                  // goto default
                  $async$goto = 25;
                  break;
              }
              break;
            case 5:
              // case
              yyy = $async$self.addToken$1(B.TokenType_0);
              $async$goto = 26;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 26:
              // after yield
              $async$goto = 27;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 27:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 6:
              // case
              yyy = $async$self.addToken$1(B.TokenType_1);
              $async$goto = 28;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 28:
              // after yield
              $async$goto = 29;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 29:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 7:
              // case
              yyy = $async$self.addToken$1(B.TokenType_2);
              $async$goto = 30;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 30:
              // after yield
              $async$goto = 31;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 31:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 8:
              // case
              yyy = $async$self.addToken$1(B.TokenType_3);
              $async$goto = 32;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 32:
              // after yield
              $async$goto = 33;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 33:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 9:
              // case
              yyy = $async$self.addToken$1(B.TokenType_4);
              $async$goto = 34;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 34:
              // after yield
              $async$goto = 35;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 35:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 10:
              // case
              yyy = $async$self.addToken$1(B.TokenType_5);
              $async$goto = 36;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 36:
              // after yield
              $async$goto = 37;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 37:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 11:
              // case
              yyy = $async$self.addToken$1(B.TokenType_6);
              $async$goto = 38;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 38:
              // after yield
              $async$goto = 39;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 39:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 12:
              // case
              yyy = $async$self.addToken$1(B.TokenType_7);
              $async$goto = 40;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 40:
              // after yield
              $async$goto = 41;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 41:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 13:
              // case
              yyy = $async$self.addToken$1(B.TokenType_8);
              $async$goto = 42;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 42:
              // after yield
              $async$goto = 43;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 43:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 14:
              // case
              yyy = $async$self.addToken$1(B.TokenType_10);
              $async$goto = 44;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 44:
              // after yield
              $async$goto = 45;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 45:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 15:
              // case
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 46;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 46:
              // after yield
              $async$goto = 47;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 47:
              // returning from await.
              $async$goto = $async$self.match$1("=") ? 48 : 50;
              break;
            case 48:
              // then
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 51;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, t3))), $async$scanToken$0, $async$controller);
            case 51:
              // after yield
              $async$goto = 52;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 52:
              // returning from await.
              yyy2 = $async$self.addToken$1(B.TokenType_12);
              $async$goto = 53;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 53:
              // after yield
              $async$goto = 54;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 54:
              // returning from await.
              // goto join
              $async$goto = 49;
              break;
            case 50:
              // else
              yyy = $async$self.addToken$1(B.TokenType_11);
              $async$goto = 55;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 55:
              // after yield
              $async$goto = 56;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 56:
              // returning from await.
            case 49:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 16:
              // case
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 57;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 57:
              // after yield
              $async$goto = 58;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 58:
              // returning from await.
              $async$goto = $async$self.match$1("=") ? 59 : 61;
              break;
            case 59:
              // then
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 62;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, t3))), $async$scanToken$0, $async$controller);
            case 62:
              // after yield
              $async$goto = 63;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 63:
              // returning from await.
              yyy2 = $async$self.addToken$1(B.TokenType_14);
              $async$goto = 64;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 64:
              // after yield
              $async$goto = 65;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 65:
              // returning from await.
              // goto join
              $async$goto = 60;
              break;
            case 61:
              // else
              yyy = $async$self.addToken$1(B.TokenType_13);
              $async$goto = 66;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 66:
              // after yield
              $async$goto = 67;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 67:
              // returning from await.
            case 60:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 17:
              // case
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 68;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 68:
              // after yield
              $async$goto = 69;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 69:
              // returning from await.
              $async$goto = $async$self.match$1("=") ? 70 : 72;
              break;
            case 70:
              // then
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 73;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, t3))), $async$scanToken$0, $async$controller);
            case 73:
              // after yield
              $async$goto = 74;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 74:
              // returning from await.
              yyy2 = $async$self.addToken$1(B.TokenType_18);
              $async$goto = 75;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 75:
              // after yield
              $async$goto = 76;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 76:
              // returning from await.
              // goto join
              $async$goto = 71;
              break;
            case 72:
              // else
              yyy = $async$self.addToken$1(B.TokenType_17);
              $async$goto = 77;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 77:
              // after yield
              $async$goto = 78;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 78:
              // returning from await.
            case 71:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 18:
              // case
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 79;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 79:
              // after yield
              $async$goto = 80;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 80:
              // returning from await.
              $async$goto = $async$self.match$1("=") ? 81 : 83;
              break;
            case 81:
              // then
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 84;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, t3))), $async$scanToken$0, $async$controller);
            case 84:
              // after yield
              $async$goto = 85;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 85:
              // returning from await.
              yyy2 = $async$self.addToken$1(B.TokenType_16);
              $async$goto = 86;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 86:
              // after yield
              $async$goto = 87;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 87:
              // returning from await.
              // goto join
              $async$goto = 82;
              break;
            case 83:
              // else
              yyy = $async$self.addToken$1(B.TokenType_15);
              $async$goto = 88;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 88:
              // after yield
              $async$goto = 89;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 89:
              // returning from await.
            case 82:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 19:
              // case
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 90;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 90:
              // after yield
              $async$goto = 91;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 91:
              // returning from await.
              $async$goto = $async$self.match$1("/") ? 92 : 94;
              break;
            case 92:
              // then
              t2 = new A._Future($.Zone__current, t1);
              $async$goto = 95;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 95:
              // after yield
              $async$goto = 96;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 96:
              // returning from await.
              t2 = $async$self.source;
              t4 = t2.length;
            case 97:
              // while condition
              if (!($async$self.peek$0() !== "\n" && $async$self.current < t4)) {
                // goto after while
                $async$goto = 98;
                break;
              }
              t5 = ++$async$self.current - 1;
              if (!(t5 < t4)) {
                A.ioore(t2, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              A._charDescription(t2[t5]);
              t5 = new A._Future($.Zone__current, t1);
              $async$goto = 99;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t5, t3))), $async$scanToken$0, $async$controller);
            case 99:
              // after yield
              $async$goto = 100;
              return A._asyncStarHelper(t5, $async$scanToken$0, $async$controller);
            case 100:
              // returning from await.
              // goto while condition
              $async$goto = 97;
              break;
            case 98:
              // after while
              // goto join
              $async$goto = 93;
              break;
            case 94:
              // else
              yyy = $async$self.addToken$1(B.TokenType_9);
              $async$goto = 101;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 101:
              // after yield
              $async$goto = 102;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 102:
              // returning from await.
            case 93:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 20:
              // case
            case 21:
              // case
            case 22:
              // case
              A._charDescription(c);
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 103;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$scanToken$0, $async$controller);
            case 103:
              // after yield
              $async$goto = 104;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 104:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 23:
              // case
              $async$self.advanceLine$0();
              A._charDescription(c);
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 105;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$scanToken$0, $async$controller);
            case 105:
              // after yield
              $async$goto = 106;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 106:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 24:
              // case
              A._charDescription(c);
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 107;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t2, t3))), $async$scanToken$0, $async$controller);
            case 107:
              // after yield
              $async$goto = 108;
              return A._asyncStarHelper(t2, $async$scanToken$0, $async$controller);
            case 108:
              // returning from await.
              t2 = $async$self.source;
              t4 = t2.length;
            case 109:
              // while condition
              if (!($async$self.peek$0() !== '"' && $async$self.current < t4)) {
                // goto after while
                $async$goto = 110;
                break;
              }
              t5 = $async$self.peek$0();
              t6 = $.Zone__current;
              t7 = $async$self.current + 1;
              $async$goto = t5 === "\n" ? 111 : 113;
              break;
            case 111:
              // then
              $async$self.current = t7;
              t5 = t7 - 1;
              if (!(t5 < t4)) {
                A.ioore(t2, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.currentLineOffsetStart = t7;
              ++$async$self.line;
              A._charDescription("\n");
              t6 = new A._Future(t6, t1);
              $async$goto = 114;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t6, t3))), $async$scanToken$0, $async$controller);
            case 114:
              // after yield
              $async$goto = 115;
              return A._asyncStarHelper(t6, $async$scanToken$0, $async$controller);
            case 115:
              // returning from await.
              // goto join
              $async$goto = 112;
              break;
            case 113:
              // else
              $async$self.current = t7;
              t5 = t7 - 1;
              if (!(t5 < t4)) {
                A.ioore(t2, t5);
                // goto return
                $async$goto = 1;
                break;
              }
              A._charDescription(t2[t5]);
              t6 = new A._Future(t6, t1);
              $async$goto = 116;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t6, t3))), $async$scanToken$0, $async$controller);
            case 116:
              // after yield
              $async$goto = 117;
              return A._asyncStarHelper(t6, $async$scanToken$0, $async$controller);
            case 117:
              // returning from await.
            case 112:
              // join
              // goto while condition
              $async$goto = 109;
              break;
            case 110:
              // after while
              $async$goto = $async$self.peek$0() === '"' ? 118 : 120;
              break;
            case 118:
              // then
              A._charDescription($async$self.peek$0());
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 121;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, t3))), $async$scanToken$0, $async$controller);
            case 121:
              // after yield
              $async$goto = 122;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 122:
              // returning from await.
              $async$self.advance$0();
              // goto join
              $async$goto = 119;
              break;
            case 120:
              // else
              $async$goto = $async$self.current >= t4 ? 123 : 124;
              break;
            case 123:
              // then
              yyy = $async$self.addError$2($async$self.line, "Unterminated string.");
              $async$goto = 125;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 125:
              // after yield
              $async$goto = 126;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 126:
              // returning from await.
            case 124:
              // join
            case 119:
              // join
              yyy2 = $async$self.addToken$2$literal(B.TokenType_20, $async$self.getSubstring$2($async$self.start + 1, $async$self.current - 1));
              $async$goto = 127;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 127:
              // after yield
              $async$goto = 128;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 128:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 25:
              // default
              $async$goto = $async$self.isDigit$1(c) ? 129 : 131;
              break;
            case 129:
              // then
              A._charDescription(c);
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 132;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$scanToken$0, $async$controller);
            case 132:
              // after yield
              $async$goto = 133;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 133:
              // returning from await.
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.number$0(), "stream", type$.Object), type$._StreamIterator_ScanState);
              $async$handler = 134;
            case 137:
              // for condition
              $async$temp1 = A;
              $async$goto = 139;
              return A._asyncStarHelper(t1.moveNext$0(), $async$scanToken$0, $async$controller);
            case 139:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 138;
                break;
              }
              item = t1.get$current();
              yyy = item;
              $async$goto = 140;
              $async$nextWhenCanceled = [1, 135];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 140:
              // after yield
              $async$goto = 141;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 141:
              // returning from await.
              // goto for condition
              $async$goto = 137;
              break;
            case 138:
              // after for
              $async$next.push(136);
              // goto finally
              $async$goto = 135;
              break;
            case 134:
              // uncaught
              $async$next = [2];
            case 135:
              // finally
              $async$handler = 2;
              $async$goto = 142;
              return A._asyncStarHelper(t1.cancel$0(), $async$scanToken$0, $async$controller);
            case 142:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 136:
              // after finally
              // goto join
              $async$goto = 130;
              break;
            case 131:
              // else
              $async$goto = $async$self.isAlpha$1(c) ? 143 : 145;
              break;
            case 143:
              // then
              A._charDescription(c);
              t1 = new A._Future($.Zone__current, type$._Future_dynamic);
              $async$goto = 146;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_1, new A._AsyncCompleter(t1, type$._AsyncCompleter_dynamic))), $async$scanToken$0, $async$controller);
            case 146:
              // after yield
              $async$goto = 147;
              return A._asyncStarHelper(t1, $async$scanToken$0, $async$controller);
            case 147:
              // returning from await.
              t1 = new A._StreamIterator(A.checkNotNullable($async$self.identifier$0(), "stream", type$.Object), type$._StreamIterator_ScanState);
              $async$handler = 148;
            case 151:
              // for condition
              $async$temp1 = A;
              $async$goto = 153;
              return A._asyncStarHelper(t1.moveNext$0(), $async$scanToken$0, $async$controller);
            case 153:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 152;
                break;
              }
              item0 = t1.get$current();
              yyy0 = item0;
              $async$goto = 154;
              $async$nextWhenCanceled = [1, 149];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy0), $async$scanToken$0, $async$controller);
            case 154:
              // after yield
              $async$goto = 155;
              return A._asyncStarHelper(yyy0.completer.future, $async$scanToken$0, $async$controller);
            case 155:
              // returning from await.
              // goto for condition
              $async$goto = 151;
              break;
            case 152:
              // after for
              $async$next.push(150);
              // goto finally
              $async$goto = 149;
              break;
            case 148:
              // uncaught
              $async$next = [2];
            case 149:
              // finally
              $async$handler = 2;
              $async$goto = 156;
              return A._asyncStarHelper(t1.cancel$0(), $async$scanToken$0, $async$controller);
            case 156:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 150:
              // after finally
              // goto join
              $async$goto = 144;
              break;
            case 145:
              // else
              t1 = $async$self.line;
              yyy = $async$self.addError$2(t1, "Unexpected character: '" + c + "', line: " + t1);
              $async$goto = 157;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanToken$0, $async$controller);
            case 157:
              // after yield
              $async$goto = 158;
              return A._asyncStarHelper(yyy.completer.future, $async$scanToken$0, $async$controller);
            case 158:
              // returning from await.
              t1 = "" + $async$self.line;
              yyy2 = $async$self.addToken$2$literal(B.TokenType_38, "Line " + t1 + ": Unexpected character: '" + c + "', line: " + t1);
              $async$goto = 159;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy2), $async$scanToken$0, $async$controller);
            case 159:
              // after yield
              $async$goto = 160;
              return A._asyncStarHelper(yyy2.completer.future, $async$scanToken$0, $async$controller);
            case 160:
              // returning from await.
            case 144:
              // join
            case 130:
              // join
              // goto after switch
              $async$goto = 4;
              break;
            case 4:
              // after switch
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$scanToken$0, type$.ScanState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, item, yyy, item0, yyy0, t1, t2, t3, yyy2, t4, t5, t6, t7, c, $async$temp1;
      return A._streamOfController($async$controller);
    },
    scanTokensStreamed$0() {
      var $async$scanTokensStreamed$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.current = 0;
              t1 = type$._Future_dynamic;
              t2 = new A._Future($.Zone__current, t1);
              t3 = type$._AsyncCompleter_dynamic;
              $async$goto = 3;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(null, B.ScanStateType_0, new A._AsyncCompleter(t2, t3))), $async$scanTokensStreamed$0, $async$controller);
            case 3:
              // after yield
              $async$goto = 4;
              return A._asyncStarHelper(t2, $async$scanTokensStreamed$0, $async$controller);
            case 4:
              // returning from await.
              t2 = $async$self.source.length, t4 = type$._StreamIterator_ScanState;
            case 5:
              // for condition
              if (!(t5 = $async$self.current, t5 < t2)) {
                // goto after for
                $async$goto = 6;
                break;
              }
              $async$self.start = t5;
              $async$self.startLineOffsetStart = $async$self.currentLineOffsetStart;
              $async$self.startLine = $async$self.line;
              stream = $async$self.scanToken$0();
              t5 = new A._StreamIterator(stream, t4);
              $async$handler = 7;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t5.moveNext$0(), $async$scanTokensStreamed$0, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              x = t5.get$current();
              yyy = x;
              $async$goto = 13;
              $async$nextWhenCanceled = [1, 8];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(yyy), $async$scanTokensStreamed$0, $async$controller);
            case 13:
              // after yield
              $async$goto = 14;
              return A._asyncStarHelper(yyy.completer.future, $async$scanTokensStreamed$0, $async$controller);
            case 14:
              // returning from await.
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [2];
            case 8:
              // finally
              $async$handler = 2;
              $async$goto = 15;
              return A._asyncStarHelper(t5.cancel$0(), $async$scanTokensStreamed$0, $async$controller);
            case 15:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              // goto for condition
              $async$goto = 5;
              break;
            case 6:
              // after for
              t2 = $async$self.line;
              t1 = new A._Future($.Zone__current, t1);
              $async$goto = 16;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(new A.ScanState(new A.Token(B.TokenType_41, "", null, t2), B.ScanStateType_2, new A._AsyncCompleter(t1, t3))), $async$scanTokensStreamed$0, $async$controller);
            case 16:
              // after yield
              $async$goto = 17;
              return A._asyncStarHelper(t1, $async$scanTokensStreamed$0, $async$controller);
            case 17:
              // returning from await.
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$scanTokensStreamed$0, type$.ScanState),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stream, x, yyy, t1, t2, t3, t4, t5, $async$temp1;
      return A._streamOfController($async$controller);
    }
  };
  A.TokenType.prototype = {
    _enumToString$0() {
      return "TokenType." + this._name;
    }
  };
  A.Token.prototype = {
    toString$0(_) {
      return this.type.toString$0(0) + " " + this.lexeme + " " + A.S(this.literal);
    }
  };
  A.isolateEntryInterpreter_sendy.prototype = {
    call$1(message) {
      A.print(message);
      type$.JSObject._as(self.self).postMessage(message);
    },
    $signature: 21
  };
  A.isolateEntryInterpreter_executeInContext.prototype = {
    $call$body$isolateEntryInterpreter_executeInContext(programText) {
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              _box_0.outputResult = "-----";
              data = programText;
              t1 = type$.JSArray_String;
              _box_0.errors = A._setArrayType([], t1);
              interpretStream = A._Cell$named("interpretStream");
              subscription = A._Cell$named("subscription");
              interpreter = A._Cell$named("interpreter");
              $async$handler = 4;
              t2 = type$.JSArray_Token;
              scanner = new A.Scanner(data, A._setArrayType([], t2), A._setArrayType([], t1));
              tokens = A._setArrayType([], t2);
              scanStream = scanner.scanTokensStreamed$0();
              t2 = new A._StreamIterator(A.checkNotNullable(scanStream, "stream", type$.Object), type$._StreamIterator_ScanState);
              $async$handler = 7;
            case 10:
              // for condition
              $async$temp1 = A;
              $async$goto = 12;
              return A._asyncStarHelper(t2.moveNext$0(), $async$call$1, $async$controller);
            case 12:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                // goto after for
                $async$goto = 11;
                break;
              }
              scanState = t2.get$current();
              if (scanState.type === B.ScanStateType_2) {
                t3 = scanState.token;
                t3.toString;
                token = t3;
                J.add$1$ax(tokens, token);
              }
              t3 = scanState.completer;
              t4 = t3.future;
              if ((t4._state & 30) === 0)
                t4._asyncComplete$1(t3.$ti._eval$1("1/")._as(null));
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [4];
            case 8:
              // finally
              $async$handler = 4;
              $async$goto = 13;
              return A._asyncStarHelper(t2.cancel$0(), $async$call$1, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              t2 = $async$self.sendy;
              t2.call$1("----: scanning done");
              errors = _box_0.errors = scanner.errors;
              t3 = errors.length, _i = 0;
            case 14:
              // for condition
              if (!(_i < errors.length)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              error = errors[_i];
              $async$goto = 17;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(error), $async$call$1, $async$controller);
            case 17:
              // after yield
            case 15:
              // for update
              errors.length === t3 || (0, A.throwConcurrentModificationError)(errors), ++_i;
              // goto for condition
              $async$goto = 14;
              break;
            case 16:
              // after for
              if (_box_0.errors.length !== 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              parser = new A.Parser(tokens, A._setArrayType([], t1));
              parseStream = parser.parseStreamed$0();
              statements = A._setArrayType([], type$.JSArray_Stmt);
              t3 = type$._Future_void;
              t4 = type$._AsyncCompleter_void;
              parseStreamCompleter = new A._AsyncCompleter(new A._Future($.Zone__current, t3), t4);
              parseStream.listen$3$onDone$onError(new A.isolateEntryInterpreter_executeInContext_closure(statements), new A.isolateEntryInterpreter_executeInContext_closure0(parseStreamCompleter), new A.isolateEntryInterpreter_executeInContext_closure1(_box_0, parseStreamCompleter));
              $async$goto = (parseStreamCompleter.future._state & 30) === 0 ? 18 : 19;
              break;
            case 18:
              // then
              $async$goto = 20;
              return A._asyncStarHelper(parseStreamCompleter.future, $async$call$1, $async$controller);
            case 20:
              // returning from await.
            case 19:
              // join
              t2.call$1("----: parsing done");
              errors = _box_0.errors = parser.errors;
              t5 = errors.length, _i = 0;
            case 21:
              // for condition
              if (!(_i < errors.length)) {
                // goto after for
                $async$goto = 23;
                break;
              }
              error0 = errors[_i];
              $async$goto = 24;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(error0), $async$call$1, $async$controller);
            case 24:
              // after yield
            case 22:
              // for update
              errors.length === t5 || (0, A.throwConcurrentModificationError)(errors), ++_i;
              // goto for condition
              $async$goto = 21;
              break;
            case 23:
              // after for
              if (_box_0.errors.length !== 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              interpreter._value = A.Interpreter$();
              t5 = interpreter._readLocal$0();
              t5.toString;
              resolver = new A.Resolver(t5, A._setArrayType([], type$.JSArray_Map_String_bool), A._setArrayType([], t1), B.FunctionType_0, B.ClassType_0, A._setArrayType([], type$.JSArray_ResolveInfo));
              resolverStream = resolver.resolveAll$1(statements);
              resolverStreamCompleter = new A._AsyncCompleter(new A._Future($.Zone__current, t3), t4);
              t4 = resolverStream;
              if (t4 != null)
                t4.listen$3$onDone$onError(new A.isolateEntryInterpreter_executeInContext_closure2(), new A.isolateEntryInterpreter_executeInContext_closure3(resolverStreamCompleter), new A.isolateEntryInterpreter_executeInContext_closure4(resolverStreamCompleter));
              $async$goto = 25;
              return A._asyncStarHelper(resolverStreamCompleter.future, $async$call$1, $async$controller);
            case 25:
              // returning from await.
              t2.call$1("----: resolving done");
              errors = _box_0.errors = resolver.errors;
              t1 = errors.length, _i = 0;
            case 26:
              // for condition
              if (!(_i < errors.length)) {
                // goto after for
                $async$goto = 28;
                break;
              }
              error1 = errors[_i];
              $async$goto = 29;
              $async$nextWhenCanceled = [1];
              return A._asyncStarHelper(A._IterationMarker_yieldSingle(error1), $async$call$1, $async$controller);
            case 29:
              // after yield
            case 27:
              // for update
              errors.length === t1 || (0, A.throwConcurrentModificationError)(errors), ++_i;
              // goto for condition
              $async$goto = 26;
              break;
            case 28:
              // after for
              if (_box_0.errors.length !== 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              interpretStream._value = interpreter._readLocal$0().interpret$1(statements);
              subscription._value = interpretStream._readLocal$0().listen$3$onDone$onError(new A.isolateEntryInterpreter_executeInContext_closure5(_box_0, t2), new A.isolateEntryInterpreter_executeInContext_closure6(t2), new A.isolateEntryInterpreter_executeInContext_closure7(t2));
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              A.getTraceFromException($async$exception);
              $async$self.sendy.call$1("ERROR: " + A.S(e));
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return A._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = A._makeAsyncStarStreamController($async$call$1, type$.String),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, data, interpretStream, subscription, interpreter, scanner, tokens, scanStream, scanState, token, error, parser, parseStream, statements, parseStreamCompleter, error0, resolver, resolverStream, resolverStreamCompleter, error1, e, t1, t2, t3, t4, errors, _i, t5, exception, _box_0, $async$exception, $async$temp1;
      return A._streamOfController($async$controller);
    },
    call$1(programText) {
      return this.$call$body$isolateEntryInterpreter_executeInContext(programText);
    },
    $signature: 22
  };
  A.isolateEntryInterpreter_executeInContext_closure.prototype = {
    call$1(parserState) {
      var t1;
      type$.ParserState._as(parserState);
      if (parserState.type === B.ParserStateType_1) {
        t1 = parserState.statement;
        t1.toString;
        B.JSArray_methods.add$1(this.statements, t1);
      }
      parserState.finish$0();
    },
    $signature: 23
  };
  A.isolateEntryInterpreter_executeInContext_closure0.prototype = {
    call$0() {
      var t1 = this.parseStreamCompleter;
      if ((t1.future._state & 30) === 0)
        t1.complete$0();
    },
    $signature: 0
  };
  A.isolateEntryInterpreter_executeInContext_closure1.prototype = {
    call$1(error) {
      var t1;
      B.JSArray_methods.add$1(this._box_0.errors, "Parse error: " + A.S(error));
      t1 = this.parseStreamCompleter;
      if ((t1.future._state & 30) === 0)
        t1.complete$0();
    },
    $signature: 1
  };
  A.isolateEntryInterpreter_executeInContext_closure2.prototype = {
    call$1(resolveTypeInfo) {
      type$.ResolveInfo._as(resolveTypeInfo);
    },
    $signature: 24
  };
  A.isolateEntryInterpreter_executeInContext_closure3.prototype = {
    call$0() {
      this.resolverStreamCompleter.complete$0();
    },
    $signature: 0
  };
  A.isolateEntryInterpreter_executeInContext_closure4.prototype = {
    call$1(error) {
      this.resolverStreamCompleter.complete$0();
    },
    $signature: 1
  };
  A.isolateEntryInterpreter_executeInContext_closure5.prototype = {
    call$1(interpreterInfo) {
      return this.$call$body$isolateEntryInterpreter_executeInContext_closure(type$.InterpreterInfo._as(interpreterInfo));
    },
    $call$body$isolateEntryInterpreter_executeInContext_closure(interpreterInfo) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, outputResult, t1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = interpreterInfo.completer;
              if ((t1.future._state & 30) === 0)
                t1.complete$0();
              t1 = interpreterInfo.type;
              if (t1 === B.InterpreterInfoType_4) {
                outputResult = A.S(interpreterInfo.output) + "\n";
                $async$self._box_0.outputResult = outputResult;
                $async$self.sendy.call$1("OUTPUT:" + outputResult);
              } else if (t1 === B.InterpreterInfoType_5) {
                t1 = $async$self._box_0;
                B.JSArray_methods.add$1(t1.errors, A.S(interpreterInfo.output));
                $async$self.sendy.call$1("ERROR:" + t1.outputResult);
              }
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 25
  };
  A.isolateEntryInterpreter_executeInContext_closure7.prototype = {
    call$1(error) {
      this.sendy.call$1("ERROR: error " + A.S(error) + "\n");
    },
    $signature: 1
  };
  A.isolateEntryInterpreter_executeInContext_closure6.prototype = {
    call$0() {
      this.sendy.call$1("FINISHED_EXECUTING");
    },
    $signature: 0
  };
  A.isolateEntryInterpreter_closure.prototype = {
    call$1($event) {
      var t1 = type$.JSObject,
        message = A._asString(t1._as($event).data);
      A.print("::: " + message);
      if (B.JSString_methods.startsWith$1(message, "START:")) {
        t1 = this.sendy;
        this.executeInContext.call$1(B.JSString_methods.substring$1(message, 6)).listen$3$onDone$onError(new A.isolateEntryInterpreter__closure(t1), new A.isolateEntryInterpreter__closure0(t1), new A.isolateEntryInterpreter__closure1(t1));
      } else if (message === "STOP") {
        this.sendy.call$1("Shutting down gracefully");
        t1._as(self.self).close();
      } else
        A.print(message);
    },
    $signature: 26
  };
  A.isolateEntryInterpreter__closure.prototype = {
    call$1(item) {
      this.sendy.call$1("ERROR:" + A._asString(item));
    },
    $signature: 27
  };
  A.isolateEntryInterpreter__closure1.prototype = {
    call$1(error) {
      var t1 = this.sendy;
      t1.call$1("Aye, got an error: " + A.S(error));
      t1.call$1("ERROR:" + A.S(error));
    },
    $signature: 1
  };
  A.isolateEntryInterpreter__closure0.prototype = {
    call$0() {
      this.sendy.call$1("Aye, done");
    },
    $signature: 0
  };
  (function aliases() {
    var _ = J.LegacyJavaScriptObject.prototype;
    _.super$LegacyJavaScriptObject$toString = _.toString$0;
  })();
  (function installTearOffs() {
    var _static_1 = hunkHelpers._static_1,
      _static_0 = hunkHelpers._static_0,
      _static_2 = hunkHelpers._static_2,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_0_u = hunkHelpers._instance_0u;
    _static_1(A, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 4);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 4);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 4);
    _static_0(A, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 0);
    _static_2(A, "async___nullErrorHandler$closure", "_nullErrorHandler", 3);
    _instance_2_u(A._Future.prototype, "get$_completeError", "_completeError$2", 3);
    var _;
    _instance_1_u(_ = A._StreamController.prototype, "get$_add", "_add$1", 6);
    _instance_2_u(_, "get$_addError", "_addError$2", 3);
    _instance_0_u(_, "get$_close", "_close$0", 0);
    _instance_0_u(_ = A._ControllerSubscription.prototype, "get$_onPause", "_onPause$0", 0);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 0);
    _instance_0_u(_ = A._BufferingStreamSubscription.prototype, "get$_onPause", "_onPause$0", 0);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 0);
    _instance_1_u(_ = A._StreamIterator.prototype, "get$_onData", "_onData$1", 6);
    _instance_2_u(_, "get$_onError", "_onError$2", 3);
    _instance_0_u(_, "get$_onDone", "_onDone$0", 0);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A.Object, null);
    _inheritMany(A.Object, [A.JS_CONST, J.Interceptor, J.ArrayIterator, A.Error, A.Closure, A.ListIterator, A.FixedLengthListMixin, A.TypeErrorDecoder, A.NullThrownFromJavaScriptException, A.ExceptionAndStackTrace, A._StackTrace, A.MapBase, A.LinkedHashMapCell, A._Cell, A.Rti, A._FunctionParameters, A._Type, A._TimerImpl, A._AsyncAwaitCompleter, A._AsyncStarStreamController, A._IterationMarker, A.AsyncError, A._Completer, A._FutureListener, A._Future, A._AsyncCallbackEntry, A.Stream, A._StreamController, A._AsyncStreamControllerDispatch, A._BufferingStreamSubscription, A._AddStreamState, A._DelayedEvent, A._DelayedDone, A._PendingEvents, A._StreamIterator, A._Zone, A.ListBase, A.Duration, A._Enum, A.OutOfMemoryError, A.StackOverflowError, A._Exception, A.FormatException, A.Null, A._StringStackTrace, A.StringBuffer, A.LanguageCallableImpl, A.LanguageFunction, A.LanguageClass, A.LanguageInstance, A.Environment, A.ParseError, A.ParserRuntimeError, A.Return, A.ExpressionResultX, A.StmtState, A.Expr, A.Stmt, A.InterpreterInfo, A.Interpreter, A.ParserState, A.Parser, A.ResolveInfo, A.Resolver, A.ScanState, A.Scanner, A.Token]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JavaScriptBigInt, J.JavaScriptSymbol, J.JSNumber, J.JSString]);
    _inheritMany(J.JavaScriptObject, [J.LegacyJavaScriptObject, J.JSArray, A.NativeByteBuffer, A.NativeTypedData]);
    _inheritMany(J.LegacyJavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSNumNotInt]);
    _inheritMany(A.Error, [A.LateError, A.TypeError, A.JsNoSuchMethodError, A.UnknownJsTypeError, A._CyclicInitializationError, A.RuntimeError, A.AssertionError, A._Error, A.ArgumentError, A.UnsupportedError, A.UnimplementedError, A.StateError, A.ConcurrentModificationError]);
    _inheritMany(A.Closure, [A.Closure0Args, A.Closure2Args, A.TearOffClosure, A.initHooks_closure, A.initHooks_closure1, A._AsyncRun__initializeScheduleImmediate_internalCallback, A._AsyncRun__initializeScheduleImmediate_closure, A._awaitOnObject_closure, A._asyncStarHelper_closure0, A._Future__chainForeignFuture_closure, A._Future__propagateToListeners_handleWhenCompleteCallback_closure, A.Stream_length_closure, A.LanguageFunction_call_closure, A.LanguageFunction_call_closure1, A.Interpreter_executeBlock_closure, A.isolateEntryInterpreter_sendy, A.isolateEntryInterpreter_executeInContext, A.isolateEntryInterpreter_executeInContext_closure, A.isolateEntryInterpreter_executeInContext_closure1, A.isolateEntryInterpreter_executeInContext_closure2, A.isolateEntryInterpreter_executeInContext_closure4, A.isolateEntryInterpreter_executeInContext_closure5, A.isolateEntryInterpreter_executeInContext_closure7, A.isolateEntryInterpreter_closure, A.isolateEntryInterpreter__closure, A.isolateEntryInterpreter__closure1]);
    _inheritMany(A.Closure0Args, [A.nullFuture_closure, A._AsyncRun__scheduleImmediateJsOverride_internalCallback, A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, A._TimerImpl_internalCallback, A._asyncStarHelper_closure, A._AsyncStarStreamController__resumeBody, A._AsyncStarStreamController__resumeBody_closure, A._AsyncStarStreamController_closure0, A._AsyncStarStreamController_closure1, A._AsyncStarStreamController_closure, A._AsyncStarStreamController__closure, A.Future_Future$delayed_closure, A._Future__addListener_closure, A._Future__prependListeners_closure, A._Future__chainForeignFuture_closure1, A._Future__chainCoreFutureAsync_closure, A._Future__asyncCompleteWithValue_closure, A._Future__asyncCompleteError_closure, A._Future__propagateToListeners_handleWhenCompleteCallback, A._Future__propagateToListeners_handleValueCallback, A._Future__propagateToListeners_handleError, A.Stream_length_closure0, A._StreamController__subscribe_closure, A._StreamController__recordCancel_complete, A._AddStreamState_cancel_closure, A._BufferingStreamSubscription__sendError_sendError, A._BufferingStreamSubscription__sendDone_sendDone, A._PendingEvents_schedule_closure, A._rootHandleError_closure, A._RootZone_bindCallbackGuarded_closure, A.LanguageFunction_call_closure0, A.Interpreter_executeBlock__closure, A.Interpreter_executeBlock_closure0, A.isolateEntryInterpreter_executeInContext_closure0, A.isolateEntryInterpreter_executeInContext_closure3, A.isolateEntryInterpreter_executeInContext_closure6, A.isolateEntryInterpreter__closure0]);
    _inherit(A.NullError, A.TypeError);
    _inheritMany(A.TearOffClosure, [A.StaticClosure, A.BoundClosure]);
    _inherit(A._AssertionError, A.AssertionError);
    _inherit(A.JsLinkedHashMap, A.MapBase);
    _inheritMany(A.Closure2Args, [A.initHooks_closure0, A._awaitOnObject_closure0, A._wrapJsFunctionForAsync_closure, A._Future__chainForeignFuture_closure0, A._AddStreamState_makeErrorHandler_closure, A.MapBase_mapToString_closure, A.Interpreter_closure, A.Interpreter_executeBlock_closure1]);
    _inheritMany(A.NativeTypedData, [A.NativeByteData, A.NativeTypedArray]);
    _inheritMany(A.NativeTypedArray, [A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfDouble, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfInt, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(A.NativeTypedArrayOfDouble, [A.NativeFloat32List, A.NativeFloat64List]);
    _inheritMany(A.NativeTypedArrayOfInt, [A.NativeInt16List, A.NativeInt32List, A.NativeInt8List, A.NativeUint16List, A.NativeUint32List, A.NativeUint8ClampedList, A.NativeUint8List]);
    _inherit(A._TypeError, A._Error);
    _inherit(A._AsyncCompleter, A._Completer);
    _inherit(A._AsyncStreamController, A._StreamController);
    _inherit(A._StreamImpl, A.Stream);
    _inherit(A._ControllerStream, A._StreamImpl);
    _inherit(A._ControllerSubscription, A._BufferingStreamSubscription);
    _inherit(A._StreamControllerAddStreamState, A._AddStreamState);
    _inheritMany(A._DelayedEvent, [A._DelayedData, A._DelayedError]);
    _inherit(A._RootZone, A._Zone);
    _inheritMany(A.ArgumentError, [A.RangeError, A.IndexError]);
    _inheritMany(A.Expr, [A.ExprNull, A.ExprAssign, A.ExprBinary, A.ExprCall, A.ExprGet, A.ExprGrouping, A.ExprLiteral, A.ExprLogical, A.ExprSet, A.ExprSuper, A.ExprThis, A.ExprUnary, A.ExprVariable]);
    _inheritMany(A.Stmt, [A.StmtNull, A.StmtBlock, A.StmtClass, A.StmtExpression, A.StmtFunction, A.StmtIf, A.StmtPrint, A.StmtReturn, A.StmtVar, A.StmtWhile]);
    _inheritMany(A._Enum, [A.InterpreterInfoType, A.ParserStateType, A.FunctionType, A.ClassType, A.ResolveInfoType, A.ScanStateType, A.TokenType]);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._AsyncStreamController, A._AsyncStreamControllerDispatch);
  })();
  var init = {
    typeUniverse: {eC: new Map(), tR: {}, eT: {}, tPV: {}, sEA: []},
    mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List", Object: "Object", Map: "Map"},
    mangledNames: {},
    types: ["~()", "Null(@)", "Null()", "~(Object,StackTrace)", "~(~())", "Null(Object,StackTrace)", "~(Object?)", "~(InterpreterInfo)", "Future<Null>()", "@(@)", "@(@,String)", "@(String)", "Null(~())", "~(@)", "Null(@,StackTrace)", "~(int,@)", "_Future<@>?()", "_Future<@>(@)", "~(Object?,Object?)", "Stream<InterpreterInfo>(Interpreter,List<Object>)", "Null(@,@)", "Null(String)", "Stream<String>(String)", "~(ParserState)", "~(ResolveInfo)", "Future<~>(InterpreterInfo)", "Null(JSObject)", "~(String)"],
    interceptorsByTag: null,
    leafTags: null,
    arrayRti: Symbol("$ti")
  };
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"JavaScriptFunction":"LegacyJavaScriptObject","PlainJavaScriptObject":"LegacyJavaScriptObject","UnknownJavaScriptObject":"LegacyJavaScriptObject","JSBool":{"bool":[],"TrustedGetRuntimeType":[]},"JSNull":{"Null":[],"TrustedGetRuntimeType":[]},"JavaScriptObject":{"JSObject":[]},"LegacyJavaScriptObject":{"JSObject":[]},"JSArray":{"List":["1"],"JSObject":[],"Iterable":["1"]},"JSUnmodifiableArray":{"JSArray":["1"],"List":["1"],"JSObject":[],"Iterable":["1"]},"JSNumber":{"double":[],"num":[]},"JSInt":{"double":[],"int":[],"num":[],"TrustedGetRuntimeType":[]},"JSNumNotInt":{"double":[],"num":[],"TrustedGetRuntimeType":[]},"JSString":{"String":[],"Pattern":[],"TrustedGetRuntimeType":[]},"LateError":{"Error":[]},"NullError":{"TypeError":[],"Error":[]},"JsNoSuchMethodError":{"Error":[]},"UnknownJsTypeError":{"Error":[]},"_StackTrace":{"StackTrace":[]},"Closure":{"Function":[]},"Closure0Args":{"Function":[]},"Closure2Args":{"Function":[]},"TearOffClosure":{"Function":[]},"StaticClosure":{"Function":[]},"BoundClosure":{"Function":[]},"_CyclicInitializationError":{"Error":[]},"RuntimeError":{"Error":[]},"_AssertionError":{"Error":[]},"JsLinkedHashMap":{"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"]},"NativeByteBuffer":{"JSObject":[],"TrustedGetRuntimeType":[]},"NativeTypedData":{"JSObject":[]},"NativeByteData":{"JSObject":[],"TrustedGetRuntimeType":[]},"NativeTypedArray":{"JavaScriptIndexingBehavior":["1"],"JSObject":[]},"NativeTypedArrayOfDouble":{"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"]},"NativeTypedArrayOfInt":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"]},"NativeFloat32List":{"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double"},"NativeFloat64List":{"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double"},"NativeInt16List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeInt32List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeInt8List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint16List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint32List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint8ClampedList":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint8List":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"_Error":{"Error":[]},"_TypeError":{"TypeError":[],"Error":[]},"_Future":{"Future":["1"]},"_AsyncAwaitCompleter":{"Completer":["1"]},"AsyncError":{"Error":[]},"_Completer":{"Completer":["1"]},"_AsyncCompleter":{"_Completer":["1"],"Completer":["1"]},"_StreamController":{"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_AsyncStreamController":{"_AsyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_ControllerStream":{"_StreamImpl":["1"],"Stream":["1"]},"_ControllerSubscription":{"_BufferingStreamSubscription":["1"],"StreamSubscription":["1"],"_EventDispatch":["1"]},"_StreamControllerAddStreamState":{"_AddStreamState":["1"]},"_BufferingStreamSubscription":{"StreamSubscription":["1"],"_EventDispatch":["1"]},"_StreamImpl":{"Stream":["1"]},"_DelayedData":{"_DelayedEvent":["1"]},"_DelayedError":{"_DelayedEvent":["@"]},"_DelayedDone":{"_DelayedEvent":["@"]},"_Zone":{"Zone":[]},"_RootZone":{"_Zone":[],"Zone":[]},"MapBase":{"Map":["1","2"]},"double":{"num":[]},"int":{"num":[]},"List":{"Iterable":["1"]},"String":{"Pattern":[]},"AssertionError":{"Error":[]},"TypeError":{"Error":[]},"ArgumentError":{"Error":[]},"RangeError":{"Error":[]},"IndexError":{"Error":[]},"UnsupportedError":{"Error":[]},"UnimplementedError":{"Error":[]},"StateError":{"Error":[]},"ConcurrentModificationError":{"Error":[]},"OutOfMemoryError":{"Error":[]},"StackOverflowError":{"Error":[]},"_StringStackTrace":{"StackTrace":[]},"LanguageFunction":{"LanguageCallable":[]},"LanguageCallableImpl":{"LanguageCallable":[]},"LanguageClass":{"LanguageCallable":[]},"StmtFunction":{"Stmt":[]},"ExprNull":{"Expr":[]},"ExprAssign":{"Expr":[]},"ExprBinary":{"Expr":[]},"ExprCall":{"Expr":[]},"ExprGet":{"Expr":[]},"ExprGrouping":{"Expr":[]},"ExprLiteral":{"Expr":[]},"ExprLogical":{"Expr":[]},"ExprSet":{"Expr":[]},"ExprSuper":{"Expr":[]},"ExprThis":{"Expr":[]},"ExprUnary":{"Expr":[]},"ExprVariable":{"Expr":[]},"StmtNull":{"Stmt":[]},"StmtBlock":{"Stmt":[]},"StmtClass":{"Stmt":[]},"StmtExpression":{"Stmt":[]},"StmtIf":{"Stmt":[]},"StmtPrint":{"Stmt":[]},"StmtReturn":{"Stmt":[]},"StmtVar":{"Stmt":[]},"StmtWhile":{"Stmt":[]},"Int8List":{"List":["int"],"Iterable":["int"]},"Uint8List":{"List":["int"],"Iterable":["int"]},"Uint8ClampedList":{"List":["int"],"Iterable":["int"]},"Int16List":{"List":["int"],"Iterable":["int"]},"Uint16List":{"List":["int"],"Iterable":["int"]},"Int32List":{"List":["int"],"Iterable":["int"]},"Uint32List":{"List":["int"],"Iterable":["int"]},"Float32List":{"List":["double"],"Iterable":["double"]},"Float64List":{"List":["double"],"Iterable":["double"]}}'));
  A._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"NativeTypedArray":1,"_DelayedEvent":1}'));
  var string$ = {
    Error_: "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a value of the returned future's type"
  };
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      $env_1_1_void: findType("@<~>"),
      AsyncError: findType("AsyncError"),
      Environment: findType("Environment"),
      Error: findType("Error"),
      Expr: findType("Expr"),
      ExprAssign: findType("ExprAssign"),
      ExprBinary: findType("ExprBinary"),
      ExprCall: findType("ExprCall"),
      ExprGet: findType("ExprGet"),
      ExprGrouping: findType("ExprGrouping"),
      ExprLiteral: findType("ExprLiteral"),
      ExprLogical: findType("ExprLogical"),
      ExprNull: findType("ExprNull"),
      ExprSet: findType("ExprSet"),
      ExprSuper: findType("ExprSuper"),
      ExprThis: findType("ExprThis"),
      ExprUnary: findType("ExprUnary"),
      ExprVariable: findType("ExprVariable"),
      Function: findType("Function"),
      Future_dynamic: findType("Future<@>"),
      Interpreter: findType("Interpreter"),
      InterpreterInfo: findType("InterpreterInfo"),
      JSArray_Expr: findType("JSArray<Expr>"),
      JSArray_Map_String_bool: findType("JSArray<Map<String,bool>>"),
      JSArray_Object: findType("JSArray<Object>"),
      JSArray_ResolveInfo: findType("JSArray<ResolveInfo>"),
      JSArray_Stmt: findType("JSArray<Stmt>"),
      JSArray_StmtFunction: findType("JSArray<StmtFunction>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_Token: findType("JSArray<Token>"),
      JSArray_TokenType: findType("JSArray<TokenType>"),
      JSArray_dynamic: findType("JSArray<@>"),
      JSNull: findType("JSNull"),
      JSObject: findType("JSObject"),
      JavaScriptFunction: findType("JavaScriptFunction"),
      JavaScriptIndexingBehavior_dynamic: findType("JavaScriptIndexingBehavior<@>"),
      JsLinkedHashMap_String_bool: findType("JsLinkedHashMap<String,bool>"),
      LanguageCallable: findType("LanguageCallable"),
      LanguageClass: findType("LanguageClass"),
      LanguageFunction: findType("LanguageFunction"),
      LanguageInstance: findType("LanguageInstance"),
      List_Object: findType("List<Object>"),
      List_Stmt: findType("List<Stmt>"),
      List_TokenType: findType("List<TokenType>"),
      Null: findType("Null"),
      Object: findType("Object"),
      ParserState: findType("ParserState"),
      Record: findType("Record"),
      ResolveInfo: findType("ResolveInfo"),
      ScanState: findType("ScanState"),
      StackTrace: findType("StackTrace"),
      Stmt: findType("Stmt"),
      StmtBlock: findType("StmtBlock"),
      StmtClass: findType("StmtClass"),
      StmtExpression: findType("StmtExpression"),
      StmtFunction: findType("StmtFunction"),
      StmtIf: findType("StmtIf"),
      StmtNull: findType("StmtNull"),
      StmtPrint: findType("StmtPrint"),
      StmtReturn: findType("StmtReturn"),
      StmtVar: findType("StmtVar"),
      StmtWhile: findType("StmtWhile"),
      Stream_dynamic: findType("Stream<@>"),
      String: findType("String"),
      TrustedGetRuntimeType: findType("TrustedGetRuntimeType"),
      TypeError: findType("TypeError"),
      UnknownJavaScriptObject: findType("UnknownJavaScriptObject"),
      _AsyncCompleter_dynamic: findType("_AsyncCompleter<@>"),
      _AsyncCompleter_int: findType("_AsyncCompleter<int>"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _AsyncStreamController_InterpreterInfo: findType("_AsyncStreamController<InterpreterInfo>"),
      _Future_Null: findType("_Future<Null>"),
      _Future_bool: findType("_Future<bool>"),
      _Future_dynamic: findType("_Future<@>"),
      _Future_int: findType("_Future<int>"),
      _Future_void: findType("_Future<~>"),
      _StreamControllerAddStreamState_nullable_Object: findType("_StreamControllerAddStreamState<Object?>"),
      _StreamIterator_InterpreterInfo: findType("_StreamIterator<InterpreterInfo>"),
      _StreamIterator_ParserState: findType("_StreamIterator<ParserState>"),
      _StreamIterator_ResolveInfo: findType("_StreamIterator<ResolveInfo>"),
      _StreamIterator_ScanState: findType("_StreamIterator<ScanState>"),
      bool: findType("bool"),
      bool_Function_Object: findType("bool(Object)"),
      double: findType("double"),
      dynamic: findType("@"),
      dynamic_Function: findType("@()"),
      dynamic_Function_Object: findType("@(Object)"),
      dynamic_Function_Object_StackTrace: findType("@(Object,StackTrace)"),
      int: findType("int"),
      legacy_Never: findType("0&*"),
      legacy_Object: findType("Object*"),
      nullable_Future_Null: findType("Future<Null>?"),
      nullable_Object: findType("Object?"),
      nullable_StackTrace: findType("StackTrace?"),
      nullable__DelayedEvent_dynamic: findType("_DelayedEvent<@>?"),
      nullable__FutureListener_dynamic_dynamic: findType("_FutureListener<@,@>?"),
      nullable_void_Function: findType("~()?"),
      num: findType("num"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_Object: findType("~(Object)"),
      void_Function_Object_StackTrace: findType("~(Object,StackTrace)"),
      void_Function_int_dynamic: findType("~(int,@)")
    };
  })();
  (function constants() {
    B.Interceptor_methods = J.Interceptor.prototype;
    B.JSArray_methods = J.JSArray.prototype;
    B.JSInt_methods = J.JSInt.prototype;
    B.JSNumber_methods = J.JSNumber.prototype;
    B.JSString_methods = J.JSString.prototype;
    B.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    B.JavaScriptObject_methods = J.JavaScriptObject.prototype;
    B.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    B.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    B.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    B.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof HTMLElement == "function";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    B.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var userAgent = navigator.userAgent;
    if (typeof userAgent != "string") return hooks;
    if (userAgent.indexOf("DumpRenderTree") >= 0) return hooks;
    if (userAgent.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    B.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    B.C_JS_CONST5 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    B.C_JS_CONST4 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    B.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    B.C_JS_CONST3 = function(hooks) { return hooks; }
;
    B.C_OutOfMemoryError = new A.OutOfMemoryError();
    B.C__DelayedDone = new A._DelayedDone();
    B.C__RootZone = new A._RootZone();
    B.C__StringStackTrace = new A._StringStackTrace();
    B.ClassType_0 = new A.ClassType("NONE");
    B.ClassType_1 = new A.ClassType("CLASS");
    B.ClassType_2 = new A.ClassType("SUBCLASS");
    B.Duration_0 = new A.Duration(0);
    B.FunctionType_0 = new A.FunctionType("NONE");
    B.FunctionType_1 = new A.FunctionType("FUNCTION");
    B.FunctionType_2 = new A.FunctionType("INITIALIZER");
    B.FunctionType_3 = new A.FunctionType("METHOD");
    B.InterpreterInfoType_0 = new A.InterpreterInfoType("normal");
    B.InterpreterInfoType_1 = new A.InterpreterInfoType("statement_part");
    B.InterpreterInfoType_2 = new A.InterpreterInfoType("expression");
    B.InterpreterInfoType_3 = new A.InterpreterInfoType("expression_result");
    B.InterpreterInfoType_4 = new A.InterpreterInfoType("output");
    B.InterpreterInfoType_5 = new A.InterpreterInfoType("error");
    B.ParserStateType_1 = new A.ParserStateType("statement");
    B.ParserStateType_10 = new A.ParserStateType("error");
    B.ParserStateType_2 = new A.ParserStateType("statement_part_gen");
    B.ParserStateType_3 = new A.ParserStateType("statement_part_stmt");
    B.ParserStateType_4 = new A.ParserStateType("statement_part_expr");
    B.ParserStateType_5 = new A.ParserStateType("expression");
    B.ParserStateType_6 = new A.ParserStateType("expression_part");
    B.ParserStateType_8 = new A.ParserStateType("stack_start");
    B.ParserStateType_9 = new A.ParserStateType("stack_end");
    B.ResolveInfoType_6 = new A.ResolveInfoType("error");
    B.ScanStateType_0 = new A.ScanStateType("init");
    B.ScanStateType_1 = new A.ScanStateType("normal");
    B.ScanStateType_2 = new A.ScanStateType("token");
    B.TokenType_0 = new A.TokenType("LEFT_PAREN");
    B.TokenType_1 = new A.TokenType("RIGHT_PAREN");
    B.TokenType_10 = new A.TokenType("STAR");
    B.TokenType_11 = new A.TokenType("BANG");
    B.TokenType_12 = new A.TokenType("BANG_EQUAL");
    B.TokenType_13 = new A.TokenType("EQUAL");
    B.TokenType_14 = new A.TokenType("EQUAL_EQUAL");
    B.TokenType_15 = new A.TokenType("GREATER");
    B.TokenType_16 = new A.TokenType("GREATER_EQUAL");
    B.TokenType_17 = new A.TokenType("LESS");
    B.TokenType_18 = new A.TokenType("LESS_EQUAL");
    B.TokenType_19 = new A.TokenType("IDENTIFIER");
    B.TokenType_2 = new A.TokenType("LEFT_BRACE");
    B.TokenType_20 = new A.TokenType("STRING");
    B.TokenType_21 = new A.TokenType("NUMBER");
    B.TokenType_22 = new A.TokenType("AND");
    B.TokenType_23 = new A.TokenType("CLASS");
    B.TokenType_24 = new A.TokenType("ELSE");
    B.TokenType_25 = new A.TokenType("FALSE");
    B.TokenType_26 = new A.TokenType("FUN");
    B.TokenType_27 = new A.TokenType("FOR");
    B.TokenType_28 = new A.TokenType("IF");
    B.TokenType_29 = new A.TokenType("NIL");
    B.TokenType_3 = new A.TokenType("RIGHT_BRACE");
    B.TokenType_30 = new A.TokenType("OR");
    B.TokenType_31 = new A.TokenType("PRINT");
    B.TokenType_32 = new A.TokenType("RETURN");
    B.TokenType_33 = new A.TokenType("SUPER");
    B.TokenType_34 = new A.TokenType("THIS");
    B.TokenType_35 = new A.TokenType("TRUE");
    B.TokenType_36 = new A.TokenType("VAR");
    B.TokenType_37 = new A.TokenType("WHILE");
    B.TokenType_38 = new A.TokenType("META_ERROR");
    B.TokenType_4 = new A.TokenType("COMMA");
    B.TokenType_40 = new A.TokenType("META_NULL_TOKEN");
    B.TokenType_41 = new A.TokenType("EOF");
    B.TokenType_5 = new A.TokenType("DOT");
    B.TokenType_6 = new A.TokenType("MINUS");
    B.TokenType_7 = new A.TokenType("PLUS");
    B.TokenType_8 = new A.TokenType("SEMICOLON");
    B.TokenType_9 = new A.TokenType("SLASH");
    B.Type_ByteBuffer_EOZ = A.typeLiteral("ByteBuffer");
    B.Type_ByteData_mF8 = A.typeLiteral("ByteData");
    B.Type_Float32List_Ymk = A.typeLiteral("Float32List");
    B.Type_Float64List_Ymk = A.typeLiteral("Float64List");
    B.Type_Int16List_cot = A.typeLiteral("Int16List");
    B.Type_Int32List_m1p = A.typeLiteral("Int32List");
    B.Type_Int8List_woc = A.typeLiteral("Int8List");
    B.Type_JSObject_0ua = A.typeLiteral("JSObject");
    B.Type_Uint16List_2mh = A.typeLiteral("Uint16List");
    B.Type_Uint32List_2mh = A.typeLiteral("Uint32List");
    B.Type_Uint8ClampedList_9Bb = A.typeLiteral("Uint8ClampedList");
    B.Type_Uint8List_CSc = A.typeLiteral("Uint8List");
  })();
  (function staticFields() {
    $._JS_INTEROP_INTERCEPTOR_TAG = null;
    $.toStringVisiting = A._setArrayType([], type$.JSArray_Object);
    $.Primitives__identityHashCodeProperty = null;
    $.BoundClosure__receiverFieldNameCache = null;
    $.BoundClosure__interceptorFieldNameCache = null;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = B.C__RootZone;
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal,
      _lazy = hunkHelpers.lazy;
    _lazyFinal($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", () => A.getIsolateAffinityTag("_$dart_dartClosure"));
    _lazyFinal($, "nullFuture", "$get$nullFuture", () => B.C__RootZone.run$1$1(new A.nullFuture_closure(), A.findType("Future<Null>")));
    _lazyFinal($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", () => A._AsyncRun__initializeScheduleImmediate());
    _lazyFinal($, "Future__nullFuture", "$get$Future__nullFuture", () => type$._Future_Null._as($.$get$nullFuture()));
    _lazyFinal($, "Future__falseFuture", "$get$Future__falseFuture", () => A._Future$zoneValue(false, B.C__RootZone, type$.bool));
    _lazy($, "Language_NULL_OBJECT", "$get$Language_NULL_OBJECT", () => new A.Object());
    _lazy($, "Scanner_keywords", "$get$Scanner_keywords", () => A.LinkedHashMap_LinkedHashMap$_literal(["and", B.TokenType_22, "class", B.TokenType_23, "else", B.TokenType_24, "false", B.TokenType_25, "for", B.TokenType_27, "fun", B.TokenType_26, "if", B.TokenType_28, "nil", B.TokenType_29, "or", B.TokenType_30, "print", B.TokenType_31, "return", B.TokenType_32, "super", B.TokenType_33, "this", B.TokenType_34, "true", B.TokenType_35, "var", B.TokenType_36, "while", B.TokenType_37], type$.String, A.findType("TokenType")));
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({ArrayBuffer: A.NativeByteBuffer, ArrayBufferView: A.NativeTypedData, DataView: A.NativeByteData, Float32Array: A.NativeFloat32List, Float64Array: A.NativeFloat64List, Int16Array: A.NativeInt16List, Int32Array: A.NativeInt32List, Int8Array: A.NativeInt8List, Uint16Array: A.NativeUint16List, Uint32Array: A.NativeUint32List, Uint8ClampedArray: A.NativeUint8ClampedList, CanvasPixelArray: A.NativeUint8ClampedList, Uint8Array: A.NativeUint8List});
    hunkHelpers.setOrUpdateLeafTags({ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false});
    A.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
  })();
  Function.prototype.call$0 = function() {
    return this();
  };
  Function.prototype.call$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$1$1 = function(a) {
    return this(a);
  };
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != "undefined") {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i) {
        scripts[i].removeEventListener("load", onLoad, false);
      }
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].addEventListener("load", onLoad, false);
    }
  })(function(currentScript) {
    init.currentScript = currentScript;
    var callMain = A.main;
    if (typeof dartMainRunner === "function") {
      dartMainRunner(callMain, []);
    } else {
      callMain([]);
    }
  });
})();
